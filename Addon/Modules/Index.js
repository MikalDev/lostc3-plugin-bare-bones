class EventDispatcher {
  constructor() {
    this._listeners = {};
  }

  addEventListener(type, listener) {
    const listeners = this._listeners;

    if (listeners[type] === undefined) {
      listeners[type] = [];
    }

    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }

    return this;
  }

  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];

    if (listenerArray !== undefined) {
      const index = listenerArray.indexOf(listener);

      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }

    return this;
  }

  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];

    if (listenerArray !== undefined) {
      // Make a copy, in case listeners are removed while iterating.
      const array = listenerArray.slice(0);

      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }

    return this;
  }

  dispose() {
    for (const key in this._listeners) {
      delete this._listeners[key];
    }
  }

}

/**
 * Represents a connection between two {@link GraphNode} resources in a {@link Graph}.
 *
 * The left node is considered the owner, and the right node the resource. The
 * owner is responsible for being able find and remove a reference to a resource, given
 * that link. The resource does not hold a reference to the link or to the owner,
 * although that reverse lookup can be done on the graph.
 */
class GraphEdge {
  constructor(_name, _parent, _child, _attributes = {}) {
    this._name = void 0;
    this._parent = void 0;
    this._child = void 0;
    this._attributes = void 0;
    this._disposed = false;
    this._name = _name;
    this._parent = _parent;
    this._child = _child;
    this._attributes = _attributes;

    if (!_parent.isOnGraph(_child)) {
      throw new Error('Cannot connect disconnected graphs.');
    }
  }
  /** Name (attribute name from parent {@link GraphNode}). */


  getName() {
    return this._name;
  }
  /** Owner node. */


  getParent() {
    return this._parent;
  }
  /** Resource node. */


  getChild() {
    return this._child;
  }
  /**
   * Sets the child node.
   *
   * @internal Only {@link Graph} implementations may safely call this method directly. Use
   * 	{@link Property.swap} or {@link Graph.swapChild} instead.
   */


  setChild(child) {
    this._child = child;
    return this;
  }
  /** Attributes of the graph node relationship. */


  getAttributes() {
    return this._attributes;
  }
  /** Destroys a (currently intact) edge, updating both the graph and the owner. */


  dispose() {
    if (this._disposed) return; // @ts-expect-error GraphEdge doesn't know types of parent GraphNode.

    this._parent._destroyRef(this);

    this._disposed = true;
  }
  /** Whether this link has been destroyed. */


  isDisposed() {
    return this._disposed;
  }

}

/**
 * A graph manages a network of {@link GraphNode} nodes, connected
 * by {@link @Link} edges.
 */

class Graph extends EventDispatcher {
  constructor(...args) {
    super(...args);
    this._emptySet = new Set();
    this._edges = new Set();
    this._parentEdges = new Map();
    this._childEdges = new Map();
  }

  /** Returns a list of all parent->child edges on this graph. */
  listEdges() {
    return Array.from(this._edges);
  }
  /** Returns a list of all edges on the graph having the given node as their child. */


  listParentEdges(node) {
    return Array.from(this._childEdges.get(node) || this._emptySet);
  }
  /** Returns a list of parent nodes for the given child node. */


  listParents(node) {
    const parentSet = new Set();

    for (const edge of this.listParentEdges(node)) {
      parentSet.add(edge.getParent());
    }

    return Array.from(parentSet);
  }
  /** Returns a list of all edges on the graph having the given node as their parent. */


  listChildEdges(node) {
    return Array.from(this._parentEdges.get(node) || this._emptySet);
  }
  /** Returns a list of child nodes for the given parent node. */


  listChildren(node) {
    const childSet = new Set();

    for (const edge of this.listChildEdges(node)) {
      childSet.add(edge.getChild());
    }

    return Array.from(childSet);
  }

  disconnectParents(node, filter) {
    for (const edge of this.listParentEdges(node)) {
      if (!filter || filter(edge.getParent())) {
        edge.dispose();
      }
    }

    return this;
  }
  /**********************************************************************************************
   * Internal.
   */

  /**
   * Creates a {@link GraphEdge} connecting two {@link GraphNode} instances. Edge is returned
   * for the caller to store.
   * @param a Owner
   * @param b Resource
   * @hidden
   * @internal
   */


  _createEdge(name, a, b, attributes) {
    const edge = new GraphEdge(name, a, b, attributes);

    this._edges.add(edge);

    const parent = edge.getParent();
    if (!this._parentEdges.has(parent)) this._parentEdges.set(parent, new Set());

    this._parentEdges.get(parent).add(edge);

    const child = edge.getChild();
    if (!this._childEdges.has(child)) this._childEdges.set(child, new Set());

    this._childEdges.get(child).add(edge);

    return edge;
  }
  /**
   * Detaches a {@link GraphEdge} from the {@link Graph}. Before calling this
   * method, ensure that the GraphEdge has first been detached from any
   * associated {@link GraphNode} attributes.
   * @hidden
   * @internal
   */


  _destroyEdge(edge) {
    this._edges.delete(edge);

    this._parentEdges.get(edge.getParent()).delete(edge);

    this._childEdges.get(edge.getChild()).delete(edge);

    return this;
  }

}

function _extends$2() {
  _extends$2 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends$2.apply(this, arguments);
}

/**
 * An ordered collection of {@link Ref Refs}, allowing duplicates. Removing
 * a Ref is an O(n) operation — use {@link RefSet} for faster removal, if
 * duplicates are not required.
 */
class RefList {
  constructor(refs) {
    this.list = [];

    if (refs) {
      for (const ref of refs) {
        this.list.push(ref);
      }
    }
  }

  add(ref) {
    this.list.push(ref);
  }

  remove(ref) {
    const index = this.list.indexOf(ref);
    if (index >= 0) this.list.splice(index, 1);
  }

  removeChild(child) {
    const refs = [];

    for (const ref of this.list) {
      if (ref.getChild() === child) {
        refs.push(ref);
      }
    }

    for (const ref of refs) {
      this.remove(ref);
    }

    return refs;
  }

  listRefsByChild(child) {
    const refs = [];

    for (const ref of this.list) {
      if (ref.getChild() === child) {
        refs.push(ref);
      }
    }

    return refs;
  }

  values() {
    return this.list;
  }

}
/**
 * An ordered collection of {@link Ref Refs}, without duplicates. Adding or
 * removing a Ref is typically O(1) or O(log(n)), and faster than
 * {@link RefList}. If support for duplicates is required, use {@link RefList}.
 */

class RefSet {
  constructor(refs) {
    this.set = new Set();
    this.map = new Map();

    if (refs) {
      for (const ref of refs) {
        this.add(ref);
      }
    }
  }

  add(ref) {
    const child = ref.getChild();
    this.removeChild(child);
    this.set.add(ref);
    this.map.set(child, ref);
  }

  remove(ref) {
    this.set.delete(ref);
    this.map.delete(ref.getChild());
  }

  removeChild(child) {
    const ref = this.map.get(child) || null;
    if (ref) this.remove(ref);
    return ref;
  }

  getRefByChild(child) {
    return this.map.get(child) || null;
  }

  values() {
    return Array.from(this.set);
  }

}
/**
 * Map (or dictionary) from string keys to {@link Ref Refs}.
 */

class RefMap {
  constructor(map) {
    this.map = {};

    if (map) {
      Object.assign(this.map, map);
    }
  }

  set(key, child) {
    this.map[key] = child;
  }

  delete(key) {
    delete this.map[key];
  }

  get(key) {
    return this.map[key] || null;
  }

  keys() {
    return Object.keys(this.map);
  }

  values() {
    return Object.values(this.map);
  }

}

const $attributes = Symbol('attributes');
const $immutableKeys = Symbol('immutableKeys');
/**
 * Represents a node in a {@link Graph}.
 */

class GraphNode extends EventDispatcher {
  /**
   * Internal graph used to search and maintain references.
   * @hidden
   */

  /**
   * Attributes (literal values and GraphNode references) associated with this instance. For each
   * GraphNode reference, the attributes stores a {@link GraphEdge}. List and Map references are
   * stored as arrays and dictionaries of edges.
   * @internal
   */

  /**
   * Attributes included with `getDefaultAttributes` are considered immutable, and cannot be
   * modifed by `.setRef()`, `.copy()`, or other GraphNode methods. Both the edges and the
   * properties will be disposed with the parent GraphNode.
   *
   * Currently, only single-edge references (getRef/setRef) are supported as immutables.
   *
   * @internal
   */
  constructor(graph) {
    super();
    this._disposed = false;
    this.graph = void 0;
    this[$attributes] = void 0;
    this[$immutableKeys] = void 0;
    this.graph = graph;
    this[$immutableKeys] = new Set();
    this[$attributes] = this._createAttributes();
  }
  /**
   * Returns default attributes for the graph node. Subclasses having any attributes (either
   * literal values or references to other graph nodes) must override this method. Literal
   * attributes should be given their default values, if any. References should generally be
   * initialized as empty (Ref → null, RefList → [], RefMap → {}) and then modified by setters.
   *
   * Any single-edge references (setRef) returned by this method will be considered immutable,
   * to be owned by and disposed with the parent node. Multi-edge references (addRef, removeRef,
   * setRefMap) cannot be returned as default attributes.
   */


  getDefaults() {
    return {};
  }
  /**
   * Constructs and returns an object used to store a graph nodes attributes. Compared to the
   * default Attributes interface, this has two distinctions:
   *
   * 1. Slots for GraphNode<T> objects are replaced with slots for GraphEdge<this, GraphNode<T>>
   * 2. GraphNode<T> objects provided as defaults are considered immutable
   *
   * @internal
   */


  _createAttributes() {
    const defaultAttributes = this.getDefaults();
    const attributes = {};

    for (const key in defaultAttributes) {
      const value = defaultAttributes[key]; // TODO(design): With Ref, RefList, and RefMap types, should users
      // be able to pass them all here? Listeners must be added.

      if (value instanceof GraphNode) {
        const ref = this.graph._createEdge(key, this, value);

        this[$immutableKeys].add(key);
        attributes[key] = ref;
      } else {
        attributes[key] = value;
      }
    }

    return attributes;
  }
  /** @internal Returns true if two nodes are on the same {@link Graph}. */


  isOnGraph(other) {
    return this.graph === other.graph;
  }
  /** Returns true if the node has been permanently removed from the graph. */


  isDisposed() {
    return this._disposed;
  }
  /**
   * Removes both inbound references to and outbound references from this object. At the end
   * of the process the object holds no references, and nothing holds references to it. A
   * disposed object is not reusable.
   */


  dispose() {
    if (this._disposed) return;
    this.graph.listChildEdges(this).forEach(edge => edge.dispose());
    this.graph.disconnectParents(this);
    this._disposed = true;
    this.dispatchEvent({
      type: 'dispose'
    });
  }
  /**
   * Removes all inbound references to this object. At the end of the process the object is
   * considered 'detached': it may hold references to child resources, but nothing holds
   * references to it. A detached object may be re-attached.
   */


  detach() {
    this.graph.disconnectParents(this);
    return this;
  }
  /**
   * Transfers this object's references from the old node to the new one. The old node is fully
   * detached from this parent at the end of the process.
   *
   * @hidden
   */


  swap(prevValue, nextValue) {
    for (const attribute in this[$attributes]) {
      const value = this[$attributes][attribute];

      if (value instanceof GraphEdge) {
        const ref = value;

        if (ref.getChild() === prevValue) {
          this.setRef(attribute, nextValue, ref.getAttributes());
        }
      } else if (value instanceof RefList) {
        for (const ref of value.listRefsByChild(prevValue)) {
          const refAttributes = ref.getAttributes();
          this.removeRef(attribute, prevValue);
          this.addRef(attribute, nextValue, refAttributes);
        }
      } else if (value instanceof RefSet) {
        const ref = value.getRefByChild(prevValue);

        if (ref) {
          const refAttributes = ref.getAttributes();
          this.removeRef(attribute, prevValue);
          this.addRef(attribute, nextValue, refAttributes);
        }
      } else if (value instanceof RefMap) {
        for (const key of value.keys()) {
          const ref = value.get(key);

          if (ref.getChild() === prevValue) {
            this.setRefMap(attribute, key, nextValue, ref.getAttributes());
          }
        }
      }
    }

    return this;
  }
  /**********************************************************************************************
   * Literal attributes.
   */

  /** @hidden */


  get(attribute) {
    return this[$attributes][attribute];
  }
  /** @hidden */


  set(attribute, value) {
    this[$attributes][attribute] = value;
    return this.dispatchEvent({
      type: 'change',
      attribute
    });
  }
  /**********************************************************************************************
   * Ref: 1:1 graph node references.
   */

  /** @hidden */


  getRef(attribute) {
    const ref = this[$attributes][attribute];
    return ref ? ref.getChild() : null;
  }
  /** @hidden */


  setRef(attribute, value, attributes) {
    if (this[$immutableKeys].has(attribute)) {
      throw new Error(`Cannot overwrite immutable attribute, "${attribute}".`);
    }

    const prevRef = this[$attributes][attribute];
    if (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.

    if (!value) return this;

    const ref = this.graph._createEdge(attribute, this, value, attributes);

    this[$attributes][attribute] = ref;
    return this.dispatchEvent({
      type: 'change',
      attribute
    });
  }
  /**********************************************************************************************
   * RefList: 1:many graph node references.
   */

  /** @hidden */


  listRefs(attribute) {
    const refs = this.assertRefList(attribute);
    return refs.values().map(ref => ref.getChild());
  }
  /** @hidden */


  addRef(attribute, value, attributes) {
    const ref = this.graph._createEdge(attribute, this, value, attributes);

    const refs = this.assertRefList(attribute);
    refs.add(ref);
    return this.dispatchEvent({
      type: 'change',
      attribute
    });
  }
  /** @hidden */


  removeRef(attribute, value) {
    const refs = this.assertRefList(attribute);

    if (refs instanceof RefList) {
      for (const ref of refs.listRefsByChild(value)) {
        ref.dispose();
      }
    } else {
      const ref = refs.getRefByChild(value);
      if (ref) ref.dispose();
    }

    return this;
  }
  /** @hidden */


  assertRefList(attribute) {
    const refs = this[$attributes][attribute];

    if (refs instanceof RefList || refs instanceof RefSet) {
      return refs;
    } // TODO(v3) Remove warning.


    throw new Error(`Expected RefList or RefSet for attribute "${attribute}"`);
  }
  /**********************************************************************************************
   * RefMap: Named 1:many (map) graph node references.
   */

  /** @hidden */


  listRefMapKeys(attribute) {
    return this.assertRefMap(attribute).keys();
  }
  /** @hidden */


  listRefMapValues(attribute) {
    return this.assertRefMap(attribute).values().map(ref => ref.getChild());
  }
  /** @hidden */


  getRefMap(attribute, key) {
    const refMap = this.assertRefMap(attribute);
    const ref = refMap.get(key);
    return ref ? ref.getChild() : null;
  }
  /** @hidden */


  setRefMap(attribute, key, value, metadata) {
    const refMap = this.assertRefMap(attribute);
    const prevRef = refMap.get(key);
    if (prevRef) prevRef.dispose(); // TODO(cleanup): Possible duplicate event.

    if (!value) return this;
    metadata = Object.assign(metadata || {}, {
      key: key
    });

    const ref = this.graph._createEdge(attribute, this, value, _extends$2({}, metadata, {
      key
    }));

    refMap.set(key, ref);
    return this.dispatchEvent({
      type: 'change',
      attribute,
      key
    });
  }
  /** @hidden */


  assertRefMap(attribute) {
    const map = this[$attributes][attribute];

    if (map instanceof RefMap) {
      return map;
    } // TODO(v3) Remove warning.


    throw new Error(`Expected RefMap for attribute "${attribute}"`);
  }
  /**********************************************************************************************
   * Events.
   */

  /**
   * Dispatches an event on the GraphNode, and on the associated
   * Graph. Event types on the graph are prefixed, `"node:[type]"`.
   */


  dispatchEvent(event) {
    super.dispatchEvent(_extends$2({}, event, {
      target: this
    }));
    this.graph.dispatchEvent(_extends$2({}, event, {
      target: this,
      type: `node:${event.type}`
    }));
    return this;
  }
  /**********************************************************************************************
   * Internal.
   */

  /** @hidden */


  _destroyRef(ref) {
    const attribute = ref.getName();

    if (this[$attributes][attribute] === ref) {
      this[$attributes][attribute] = null; // TODO(design): See _createAttributes().

      if (this[$immutableKeys].has(attribute)) ref.getChild().dispose();
    } else if (this[$attributes][attribute] instanceof RefList) {
      this[$attributes][attribute].remove(ref);
    } else if (this[$attributes][attribute] instanceof RefSet) {
      this[$attributes][attribute].remove(ref);
    } else if (this[$attributes][attribute] instanceof RefMap) {
      const refMap = this[$attributes][attribute];

      for (const key of refMap.keys()) {
        if (refMap.get(key) === ref) {
          refMap.delete(key);
        }
      }
    } else {
      return;
    }

    this.graph._destroyEdge(ref);

    this.dispatchEvent({
      type: 'change',
      attribute
    });
  }

}

/**
 * Current version of the package.
 * @hidden
 */
const VERSION = `v${"4.1.0"}`;
/** @hidden */
const GLB_BUFFER = '@glb.bin';
/** String IDs for core {@link Property} types. */
var PropertyType;
(function (PropertyType) {
  PropertyType["ACCESSOR"] = "Accessor";
  PropertyType["ANIMATION"] = "Animation";
  PropertyType["ANIMATION_CHANNEL"] = "AnimationChannel";
  PropertyType["ANIMATION_SAMPLER"] = "AnimationSampler";
  PropertyType["BUFFER"] = "Buffer";
  PropertyType["CAMERA"] = "Camera";
  PropertyType["MATERIAL"] = "Material";
  PropertyType["MESH"] = "Mesh";
  PropertyType["PRIMITIVE"] = "Primitive";
  PropertyType["PRIMITIVE_TARGET"] = "PrimitiveTarget";
  PropertyType["NODE"] = "Node";
  PropertyType["ROOT"] = "Root";
  PropertyType["SCENE"] = "Scene";
  PropertyType["SKIN"] = "Skin";
  PropertyType["TEXTURE"] = "Texture";
  PropertyType["TEXTURE_INFO"] = "TextureInfo";
})(PropertyType || (PropertyType = {}));
/** Vertex layout method. */
var VertexLayout;
(function (VertexLayout) {
  /**
   * Stores vertex attributes in a single buffer view per mesh primitive. Interleaving vertex
   * data may improve performance by reducing page-thrashing in GPU memory.
   */
  VertexLayout["INTERLEAVED"] = "interleaved";
  /**
   * Stores each vertex attribute in a separate buffer view. May decrease performance by causing
   * page-thrashing in GPU memory. Some 3D engines may prefer this layout, e.g. for simplicity.
   */
  VertexLayout["SEPARATE"] = "separate";
})(VertexLayout || (VertexLayout = {}));
/** Accessor usage. */
var BufferViewUsage$1;
(function (BufferViewUsage) {
  BufferViewUsage["ARRAY_BUFFER"] = "ARRAY_BUFFER";
  BufferViewUsage["ELEMENT_ARRAY_BUFFER"] = "ELEMENT_ARRAY_BUFFER";
  BufferViewUsage["INVERSE_BIND_MATRICES"] = "INVERSE_BIND_MATRICES";
  BufferViewUsage["OTHER"] = "OTHER";
  BufferViewUsage["SPARSE"] = "SPARSE";
})(BufferViewUsage$1 || (BufferViewUsage$1 = {}));
/** Texture channels. */
var TextureChannel;
(function (TextureChannel) {
  TextureChannel[TextureChannel["R"] = 4096] = "R";
  TextureChannel[TextureChannel["G"] = 256] = "G";
  TextureChannel[TextureChannel["B"] = 16] = "B";
  TextureChannel[TextureChannel["A"] = 1] = "A";
})(TextureChannel || (TextureChannel = {}));
var Format;
(function (Format) {
  Format["GLTF"] = "GLTF";
  Format["GLB"] = "GLB";
})(Format || (Format = {}));
const ComponentTypeToTypedArray = {
  '5120': Int8Array,
  '5121': Uint8Array,
  '5122': Int16Array,
  '5123': Uint16Array,
  '5125': Uint32Array,
  '5126': Float32Array
};

/**
 * Common utilities
 * @module glMatrix
 */
var ARRAY_TYPE$1 = typeof Float32Array !== 'undefined' ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create$5() {
  var out = new ARRAY_TYPE$1(3);

  if (ARRAY_TYPE$1 != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length$1(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$5();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
})();

/** @hidden Implemented in /core for use by /extensions, publicly exported from /functions. */
function getBounds(node) {
  const resultBounds = createBounds();
  const parents = node.propertyType === PropertyType.NODE ? [node] : node.listChildren();
  for (const parent of parents) {
    parent.traverse(node => {
      const mesh = node.getMesh();
      if (!mesh) return;
      // Compute mesh bounds and update result.
      const meshBounds = getMeshBounds(mesh, node.getWorldMatrix());
      if (meshBounds.min.every(isFinite) && meshBounds.max.every(isFinite)) {
        expandBounds(meshBounds.min, resultBounds);
        expandBounds(meshBounds.max, resultBounds);
      }
    });
  }
  return resultBounds;
}
/** Computes mesh bounds in world space. */
function getMeshBounds(mesh, worldMatrix) {
  const meshBounds = createBounds();
  // We can't transform a local AABB into world space and still have a tight AABB in world space,
  // so we need to compute the world AABB vertex by vertex here.
  for (const prim of mesh.listPrimitives()) {
    const position = prim.getAttribute('POSITION');
    const indices = prim.getIndices();
    if (!position) continue;
    let localPos = [0, 0, 0];
    let worldPos = [0, 0, 0];
    for (let i = 0, il = indices ? indices.getCount() : position.getCount(); i < il; i++) {
      const index = indices ? indices.getScalar(i) : i;
      localPos = position.getElement(index, localPos);
      worldPos = transformMat4(worldPos, localPos, worldMatrix);
      expandBounds(worldPos, meshBounds);
    }
  }
  return meshBounds;
}
/** Expands bounds of target by given source. */
function expandBounds(point, target) {
  for (let i = 0; i < 3; i++) {
    target.min[i] = Math.min(point[i], target.min[i]);
    target.max[i] = Math.max(point[i], target.max[i]);
  }
}
/** Creates new bounds with min=Infinity, max=-Infinity. */
function createBounds() {
  return {
    min: [Infinity, Infinity, Infinity],
    max: [-Infinity, -Infinity, -Infinity]
  };
}

/**
 * *Common utilities for working with Uint8Array and Buffer objects.*
 *
 * @category Utilities
 */
class BufferUtils {
  /** Creates a byte array from a Data URI. */
  static createBufferFromDataURI(dataURI) {
    if (typeof Buffer === 'undefined') {
      // Browser.
      const byteString = atob(dataURI.split(',')[1]);
      const ia = new Uint8Array(byteString.length);
      for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
      }
      return ia;
    } else {
      // Node.js.
      const data = dataURI.split(',')[1];
      const isBase64 = dataURI.indexOf('base64') >= 0;
      return Buffer.from(data, isBase64 ? 'base64' : 'utf8');
    }
  }
  /** Encodes text to a byte array. */
  static encodeText(text) {
    return new TextEncoder().encode(text);
  }
  /** Decodes a byte array to text. */
  static decodeText(array) {
    return new TextDecoder().decode(array);
  }
  /**
   * Concatenates N byte arrays.
   */
  static concat(arrays) {
    let totalByteLength = 0;
    for (const array of arrays) {
      totalByteLength += array.byteLength;
    }
    const result = new Uint8Array(totalByteLength);
    let byteOffset = 0;
    for (const array of arrays) {
      result.set(array, byteOffset);
      byteOffset += array.byteLength;
    }
    return result;
  }
  /**
   * Pads a Uint8Array to the next 4-byte boundary.
   *
   * Reference: [glTF → Data Alignment](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment)
   */
  static pad(srcArray, paddingByte = 0) {
    const paddedLength = this.padNumber(srcArray.byteLength);
    if (paddedLength === srcArray.byteLength) return srcArray;
    const dstArray = new Uint8Array(paddedLength);
    dstArray.set(srcArray);
    if (paddingByte !== 0) {
      for (let i = srcArray.byteLength; i < paddedLength; i++) {
        dstArray[i] = paddingByte;
      }
    }
    return dstArray;
  }
  /** Pads a number to 4-byte boundaries. */
  static padNumber(v) {
    return Math.ceil(v / 4) * 4;
  }
  /** Returns true if given byte array instances are equal. */
  static equals(a, b) {
    if (a === b) return true;
    if (a.byteLength !== b.byteLength) return false;
    let i = a.byteLength;
    while (i--) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  /**
   * Returns a Uint8Array view of a typed array, with the same underlying ArrayBuffer.
   *
   * A shorthand for:
   *
   * ```js
   * const buffer = new Uint8Array(
   * 	array.buffer,
   * 	array.byteOffset + byteOffset,
   * 	Math.min(array.byteLength, byteLength)
   * );
   * ```
   *
   */
  static toView(a, byteOffset = 0, byteLength = Infinity) {
    return new Uint8Array(a.buffer, a.byteOffset + byteOffset, Math.min(a.byteLength, byteLength));
  }
  static assertView(view) {
    if (view && !ArrayBuffer.isView(view)) {
      throw new Error(`Method requires Uint8Array parameter; received "${typeof view}".`);
    }
    return view;
  }
}

/** JPEG image support. */
class JPEGImageUtils {
  match(array) {
    return array.length >= 3 && array[0] === 255 && array[1] === 216 && array[2] === 255;
  }
  getSize(array) {
    // Skip 4 chars, they are for signature
    let view = new DataView(array.buffer, array.byteOffset + 4);
    let i, next;
    while (view.byteLength) {
      // read length of the next block
      i = view.getUint16(0, false);
      // i = buffer.readUInt16BE(0);
      // ensure correct format
      validateJPEGBuffer(view, i);
      // 0xFFC0 is baseline standard(SOF)
      // 0xFFC1 is baseline optimized(SOF)
      // 0xFFC2 is progressive(SOF2)
      next = view.getUint8(i + 1);
      if (next === 0xc0 || next === 0xc1 || next === 0xc2) {
        return [view.getUint16(i + 7, false), view.getUint16(i + 5, false)];
      }
      // move to the next block
      view = new DataView(array.buffer, view.byteOffset + i + 2);
    }
    throw new TypeError('Invalid JPG, no size found');
  }
  getChannels(_buffer) {
    return 3;
  }
}
/**
 * PNG image support.
 *
 * PNG signature: 'PNG\r\n\x1a\n'
 * PNG image header chunk name: 'IHDR'
 */
class PNGImageUtils {
  match(array) {
    return array.length >= 8 && array[0] === 0x89 && array[1] === 0x50 && array[2] === 0x4e && array[3] === 0x47 && array[4] === 0x0d && array[5] === 0x0a && array[6] === 0x1a && array[7] === 0x0a;
  }
  getSize(array) {
    const view = new DataView(array.buffer, array.byteOffset);
    const magic = BufferUtils.decodeText(array.slice(12, 16));
    if (magic === PNGImageUtils.PNG_FRIED_CHUNK_NAME) {
      return [view.getUint32(32, false), view.getUint32(36, false)];
    }
    return [view.getUint32(16, false), view.getUint32(20, false)];
  }
  getChannels(_buffer) {
    return 4;
  }
}
/**
 * *Common utilities for working with image data.*
 *
 * @category Utilities
 */
// Used to detect "fried" png's: http://www.jongware.com/pngdefry.html
PNGImageUtils.PNG_FRIED_CHUNK_NAME = 'CgBI';
class ImageUtils {
  /** Registers support for a new image format; useful for certain extensions. */
  static registerFormat(mimeType, impl) {
    this.impls[mimeType] = impl;
  }
  /**
   * Returns detected MIME type of the given image buffer. Note that for image
   * formats with support provided by extensions, the extension must be
   * registered with an I/O class before it can be detected by ImageUtils.
   */
  static getMimeType(buffer) {
    for (const mimeType in this.impls) {
      if (this.impls[mimeType].match(buffer)) {
        return mimeType;
      }
    }
    return null;
  }
  /** Returns the dimensions of the image. */
  static getSize(buffer, mimeType) {
    if (!this.impls[mimeType]) return null;
    return this.impls[mimeType].getSize(buffer);
  }
  /**
   * Returns a conservative estimate of the number of channels in the image. For some image
   * formats, the method may return 4 indicating the possibility of an alpha channel, without
   * the ability to guarantee that an alpha channel is present.
   */
  static getChannels(buffer, mimeType) {
    if (!this.impls[mimeType]) return null;
    return this.impls[mimeType].getChannels(buffer);
  }
  /** Returns a conservative estimate of the GPU memory required by this image. */
  static getVRAMByteLength(buffer, mimeType) {
    if (!this.impls[mimeType]) return null;
    if (this.impls[mimeType].getVRAMByteLength) {
      return this.impls[mimeType].getVRAMByteLength(buffer);
    }
    let uncompressedBytes = 0;
    const channels = 4; // See https://github.com/donmccurdy/glTF-Transform/issues/151.
    const resolution = this.getSize(buffer, mimeType);
    if (!resolution) return null;
    while (resolution[0] > 1 || resolution[1] > 1) {
      uncompressedBytes += resolution[0] * resolution[1] * channels;
      resolution[0] = Math.max(Math.floor(resolution[0] / 2), 1);
      resolution[1] = Math.max(Math.floor(resolution[1] / 2), 1);
    }
    uncompressedBytes += 1 * 1 * channels;
    return uncompressedBytes;
  }
  /** Returns the preferred file extension for the given MIME type. */
  static mimeTypeToExtension(mimeType) {
    if (mimeType === 'image/jpeg') return 'jpg';
    return mimeType.split('/').pop();
  }
  /** Returns the MIME type for the given file extension. */
  static extensionToMimeType(extension) {
    if (extension === 'jpg') return 'image/jpeg';
    if (!extension) return '';
    return `image/${extension}`;
  }
}
ImageUtils.impls = {
  'image/jpeg': new JPEGImageUtils(),
  'image/png': new PNGImageUtils()
};
function validateJPEGBuffer(view, i) {
  // index should be within buffer limits
  if (i > view.byteLength) {
    throw new TypeError('Corrupt JPG, exceeded buffer limits');
  }
  // Every JPEG block must begin with a 0xFF
  if (view.getUint8(i) !== 0xff) {
    throw new TypeError('Invalid JPG, marker table corrupted');
  }
  return view;
}

/**
 * *Utility class for working with file systems and URI paths.*
 *
 * @category Utilities
 */
class FileUtils {
  /**
   * Extracts the basename from a file path, e.g. "folder/model.glb" -> "model".
   * See: {@link HTTPUtils.basename}
   */
  static basename(uri) {
    const fileName = uri.split(/[\\/]/).pop();
    return fileName.substring(0, fileName.lastIndexOf('.'));
  }
  /**
   * Extracts the extension from a file path, e.g. "folder/model.glb" -> "glb".
   * See: {@link HTTPUtils.extension}
   */
  static extension(uri) {
    if (uri.startsWith('data:image/')) {
      const mimeType = uri.match(/data:(image\/\w+)/)[1];
      return ImageUtils.mimeTypeToExtension(mimeType);
    } else if (uri.startsWith('data:model/gltf+json')) {
      return 'gltf';
    } else if (uri.startsWith('data:model/gltf-binary')) {
      return 'glb';
    } else if (uri.startsWith('data:application/')) {
      return 'bin';
    }
    return uri.split(/[\\/]/).pop().split(/[.]/).pop();
  }
}

/* eslint-disable @typescript-eslint/no-explicit-any */
// Reference: https://github.com/jonschlinkert/is-plain-object
function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}
function isPlainObject(o) {
  if (isObject(o) === false) return false;
  // If has modified constructor
  const ctor = o.constructor;
  if (ctor === undefined) return true;
  // If has modified prototype
  const prot = ctor.prototype;
  if (isObject(prot) === false) return false;
  // If constructor does not have an Object-specific method
  if (Object.prototype.hasOwnProperty.call(prot, 'isPrototypeOf') === false) {
    return false;
  }
  // Most likely a plain Object
  return true;
}

var _Logger;
/** Logger verbosity thresholds. */
var Verbosity;
(function (Verbosity) {
  /** No events are logged. */
  Verbosity[Verbosity["SILENT"] = 4] = "SILENT";
  /** Only error events are logged. */
  Verbosity[Verbosity["ERROR"] = 3] = "ERROR";
  /** Only error and warn events are logged. */
  Verbosity[Verbosity["WARN"] = 2] = "WARN";
  /** Only error, warn, and info events are logged. (DEFAULT) */
  Verbosity[Verbosity["INFO"] = 1] = "INFO";
  /** All events are logged. */
  Verbosity[Verbosity["DEBUG"] = 0] = "DEBUG";
})(Verbosity || (Verbosity = {}));
/**
 * *Logger utility class.*
 *
 * @category Utilities
 */
class Logger {
  /** Constructs a new Logger instance. */
  constructor(verbosity) {
    this.verbosity = void 0;
    this.verbosity = verbosity;
  }
  /** Logs an event at level {@link Logger.Verbosity.DEBUG}. */
  debug(text) {
    if (this.verbosity <= Logger.Verbosity.DEBUG) {
      console.debug(text);
    }
  }
  /** Logs an event at level {@link Logger.Verbosity.INFO}. */
  info(text) {
    if (this.verbosity <= Logger.Verbosity.INFO) {
      console.info(text);
    }
  }
  /** Logs an event at level {@link Logger.Verbosity.WARN}. */
  warn(text) {
    if (this.verbosity <= Logger.Verbosity.WARN) {
      console.warn(text);
    }
  }
  /** Logs an event at level {@link Logger.Verbosity.ERROR}. */
  error(text) {
    if (this.verbosity <= Logger.Verbosity.ERROR) {
      console.error(text);
    }
  }
}
_Logger = Logger;
/** Logger verbosity thresholds. */
Logger.Verbosity = Verbosity;
/** Default logger instance. */
Logger.DEFAULT_INSTANCE = new _Logger(_Logger.Verbosity.INFO);

/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply$1(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE$1(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/** @hidden */
class MathUtils {
  static identity(v) {
    return v;
  }
  static eq(a, b, tolerance = 10e-6) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (Math.abs(a[i] - b[i]) > tolerance) return false;
    }
    return true;
  }
  static clamp(value, min, max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
  }
  // TODO(perf): Compare performance if we replace the switch with individual functions.
  static decodeNormalizedInt(i, componentType) {
    // Hardcode enums from accessor.ts to avoid a circular dependency.
    switch (componentType) {
      case 5126:
        // FLOAT
        return i;
      case 5123:
        // UNSIGNED_SHORT
        return i / 65535.0;
      case 5121:
        // UNSIGNED_BYTE
        return i / 255.0;
      case 5122:
        // SHORT
        return Math.max(i / 32767.0, -1.0);
      case 5120:
        // BYTE
        return Math.max(i / 127.0, -1.0);
      default:
        throw new Error('Invalid component type.');
    }
  }
  // TODO(perf): Compare performance if we replace the switch with individual functions.
  static encodeNormalizedInt(f, componentType) {
    // Hardcode enums from accessor.ts to avoid a circular dependency.
    switch (componentType) {
      case 5126:
        // FLOAT
        return f;
      case 5123:
        // UNSIGNED_SHORT
        return Math.round(MathUtils.clamp(f, 0, 1) * 65535.0);
      case 5121:
        // UNSIGNED_BYTE
        return Math.round(MathUtils.clamp(f, 0, 1) * 255.0);
      case 5122:
        // SHORT
        return Math.round(MathUtils.clamp(f, -1, 1) * 32767.0);
      case 5120:
        // BYTE
        return Math.round(MathUtils.clamp(f, -1, 1) * 127.0);
      default:
        throw new Error('Invalid component type.');
    }
  }
  /**
   * Decompose a mat4 to TRS properties.
   *
   * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the
   * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408
   *
   * @param srcMat Matrix element, to be decomposed to TRS properties.
   * @param dstTranslation Translation element, to be overwritten.
   * @param dstRotation Rotation element, to be overwritten.
   * @param dstScale Scale element, to be overwritten.
   */
  static decompose(srcMat, dstTranslation, dstRotation, dstScale) {
    let sx = length$1([srcMat[0], srcMat[1], srcMat[2]]);
    const sy = length$1([srcMat[4], srcMat[5], srcMat[6]]);
    const sz = length$1([srcMat[8], srcMat[9], srcMat[10]]);
    // if determine is negative, we need to invert one scale
    const det = determinant(srcMat);
    if (det < 0) sx = -sx;
    dstTranslation[0] = srcMat[12];
    dstTranslation[1] = srcMat[13];
    dstTranslation[2] = srcMat[14];
    // scale the rotation part
    const _m1 = srcMat.slice();
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1[0] *= invSX;
    _m1[1] *= invSX;
    _m1[2] *= invSX;
    _m1[4] *= invSY;
    _m1[5] *= invSY;
    _m1[6] *= invSY;
    _m1[8] *= invSZ;
    _m1[9] *= invSZ;
    _m1[10] *= invSZ;
    getRotation(dstRotation, _m1);
    dstScale[0] = sx;
    dstScale[1] = sy;
    dstScale[2] = sz;
  }
  /**
   * Compose TRS properties to a mat4.
   *
   * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the
   * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408
   *
   * @param srcTranslation Translation element of matrix.
   * @param srcRotation Rotation element of matrix.
   * @param srcScale Scale element of matrix.
   * @param dstMat Matrix element, to be modified and returned.
   * @returns dstMat, overwritten to mat4 equivalent of given TRS properties.
   */
  static compose(srcTranslation, srcRotation, srcScale, dstMat) {
    const te = dstMat;
    const x = srcRotation[0],
      y = srcRotation[1],
      z = srcRotation[2],
      w = srcRotation[3];
    const x2 = x + x,
      y2 = y + y,
      z2 = z + z;
    const xx = x * x2,
      xy = x * y2,
      xz = x * z2;
    const yy = y * y2,
      yz = y * z2,
      zz = z * z2;
    const wx = w * x2,
      wy = w * y2,
      wz = w * z2;
    const sx = srcScale[0],
      sy = srcScale[1],
      sz = srcScale[2];
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = srcTranslation[0];
    te[13] = srcTranslation[1];
    te[14] = srcTranslation[2];
    te[15] = 1;
    return te;
  }
}

function equalsRef(refA, refB) {
  if (!!refA !== !!refB) return false;
  const a = refA.getChild();
  const b = refB.getChild();
  return a === b || a.equals(b);
}
function equalsRefSet(refSetA, refSetB) {
  if (!!refSetA !== !!refSetB) return false;
  const refValuesA = refSetA.values();
  const refValuesB = refSetB.values();
  if (refValuesA.length !== refValuesB.length) return false;
  for (let i = 0; i < refValuesA.length; i++) {
    const a = refValuesA[i];
    const b = refValuesB[i];
    if (a.getChild() === b.getChild()) continue;
    if (!a.getChild().equals(b.getChild())) return false;
  }
  return true;
}
function equalsRefMap(refMapA, refMapB) {
  if (!!refMapA !== !!refMapB) return false;
  const keysA = refMapA.keys();
  const keysB = refMapB.keys();
  if (keysA.length !== keysB.length) return false;
  for (const key of keysA) {
    const refA = refMapA.get(key);
    const refB = refMapB.get(key);
    if (!!refA !== !!refB) return false;
    const a = refA.getChild();
    const b = refB.getChild();
    if (a === b) continue;
    if (!a.equals(b)) return false;
  }
  return true;
}
function equalsArray(a, b) {
  if (a === b) return true;
  if (!!a !== !!b || !a || !b) return false;
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}
function equalsObject(_a, _b) {
  if (_a === _b) return true;
  if (!!_a !== !!_b) return false;
  if (!isPlainObject(_a) || !isPlainObject(_b)) {
    return _a === _b;
  }
  const a = _a;
  const b = _b;
  let numKeysA = 0;
  let numKeysB = 0;
  let key;
  for (key in a) numKeysA++;
  for (key in b) numKeysB++;
  if (numKeysA !== numKeysB) return false;
  for (key in a) {
    const valueA = a[key];
    const valueB = b[key];
    if (isArray(valueA) && isArray(valueB)) {
      if (!equalsArray(valueA, valueB)) return false;
    } else if (isPlainObject(valueA) && isPlainObject(valueB)) {
      if (!equalsObject(valueA, valueB)) return false;
    } else {
      if (valueA !== valueB) return false;
    }
  }
  return true;
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value);
}

const ALPHABET = '23456789abdegjkmnpqrvwxyzABDEGJKMNPQRVWXYZ';
const UNIQUE_RETRIES = 999;
const ID_LENGTH = 6;
const previousIDs = new Set();
const generateOne = function generateOne() {
  let rtn = '';
  for (let i = 0; i < ID_LENGTH; i++) {
    rtn += ALPHABET.charAt(Math.floor(Math.random() * ALPHABET.length));
  }
  return rtn;
};
/**
 * Short ID generator.
 *
 * Generated IDs are short, easy to type, and unique for the duration of the program's execution.
 * Uniqueness across multiple program executions, or on other devices, is not guaranteed. Based on
 * [Short ID Generation in JavaScript](https://tomspencer.dev/blog/2014/11/16/short-id-generation-in-javascript/),
 * with alterations.
 *
 * @category Utilities
 * @hidden
 */
const uuid = function uuid() {
  for (let retries = 0; retries < UNIQUE_RETRIES; retries++) {
    const id = generateOne();
    if (!previousIDs.has(id)) {
      previousIDs.add(id);
      return id;
    }
  }
  return '';
};

// Need a placeholder domain to construct a URL from a relative path. We only
// access `url.pathname`, so the domain doesn't matter.
const NULL_DOMAIN = 'https://null.example';
/**
 * *Utility class for working with URLs.*
 *
 * @category Utilities
 */
class HTTPUtils {
  static dirname(path) {
    const index = path.lastIndexOf('/');
    if (index === -1) return './';
    return path.substring(0, index + 1);
  }
  /**
   * Extracts the basename from a URL, e.g. "folder/model.glb" -> "model".
   * See: {@link FileUtils.basename}
   */
  static basename(uri) {
    return FileUtils.basename(new URL(uri, NULL_DOMAIN).pathname);
  }
  /**
   * Extracts the extension from a URL, e.g. "folder/model.glb" -> "glb".
   * See: {@link FileUtils.extension}
   */
  static extension(uri) {
    return FileUtils.extension(new URL(uri, NULL_DOMAIN).pathname);
  }
  static resolve(base, path) {
    if (!this.isRelativePath(path)) return path;
    const stack = base.split('/');
    const parts = path.split('/');
    stack.pop();
    for (let i = 0; i < parts.length; i++) {
      if (parts[i] === '.') continue;
      if (parts[i] === '..') {
        stack.pop();
      } else {
        stack.push(parts[i]);
      }
    }
    return stack.join('/');
  }
  /**
   * Returns true for URLs containing a protocol, and false for both
   * absolute and relative paths.
   */
  static isAbsoluteURL(path) {
    return this.PROTOCOL_REGEXP.test(path);
  }
  /**
   * Returns true for paths that are declared relative to some unknown base
   * path. For example, "foo/bar/" is relative both "/foo/bar/" is not.
   */
  static isRelativePath(path) {
    return !/^(?:[a-zA-Z]+:)?\//.test(path);
  }
}
HTTPUtils.DEFAULT_INIT = {};
HTTPUtils.PROTOCOL_REGEXP = /^[a-zA-Z]+:\/\//;

const COPY_IDENTITY = t => t;
const EMPTY_SET = new Set();
/**
 * *Properties represent distinct resources in a glTF asset, referenced by other properties.*
 *
 * For example, each material and texture is a property, with material properties holding
 * references to the textures. All properties are created with factory methods on the
 * {@link Document} in which they should be constructed. Properties are destroyed by calling
 * {@link Property.dispose}().
 *
 * Usage:
 *
 * ```ts
 * const texture = doc.createTexture('myTexture');
 * doc.listTextures(); // → [texture x 1]
 *
 * // Attach a texture to a material.
 * material.setBaseColorTexture(texture);
 * material.getBaseColortexture(); // → texture
 *
 * // Detaching a texture removes any references to it, except from the doc.
 * texture.detach();
 * material.getBaseColorTexture(); // → null
 * doc.listTextures(); // → [texture x 1]
 *
 * // Disposing a texture removes all references to it, and its own references.
 * texture.dispose();
 * doc.listTextures(); // → []
 * ```
 *
 * Reference:
 * - [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)
 *
 * @category Properties
 */
class Property extends GraphNode {
  /** @hidden */
  constructor(graph, name = '') {
    super(graph);
    this[$attributes]['name'] = name;
    this.init();
    this.dispatchEvent({
      type: 'create'
    });
  }
  /**
   * Returns the Graph associated with this Property. For internal use.
   * @hidden
   * @experimental
   */
  getGraph() {
    return this.graph;
  }
  /**
   * Returns default attributes for the property. Empty lists and maps should be initialized
   * to empty arrays and objects. Always invoke `super.getDefaults()` and extend the result.
   */
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      name: '',
      extras: {}
    });
  }
  /** @hidden */
  set(attribute, value) {
    if (Array.isArray(value)) value = value.slice(); // copy vector, quat, color …
    return super.set(attribute, value);
  }
  /**********************************************************************************************
   * Name.
   */
  /**
   * Returns the name of this property. While names are not required to be unique, this is
   * encouraged, and non-unique names will be overwritten in some tools. For custom data about
   * a property, prefer to use Extras.
   */
  getName() {
    return this.get('name');
  }
  /**
   * Sets the name of this property. While names are not required to be unique, this is
   * encouraged, and non-unique names will be overwritten in some tools. For custom data about
   * a property, prefer to use Extras.
   */
  setName(name) {
    return this.set('name', name);
  }
  /**********************************************************************************************
   * Extras.
   */
  /**
   * Returns a reference to the Extras object, containing application-specific data for this
   * Property. Extras should be an Object, not a primitive value, for best portability.
   */
  getExtras() {
    return this.get('extras');
  }
  /**
   * Updates the Extras object, containing application-specific data for this Property. Extras
   * should be an Object, not a primitive value, for best portability.
   */
  setExtras(extras) {
    return this.set('extras', extras);
  }
  /**********************************************************************************************
   * Graph state.
   */
  /**
   * Makes a copy of this property, with the same resources (by reference) as the original.
   */
  clone() {
    const PropertyClass = this.constructor;
    return new PropertyClass(this.graph).copy(this, COPY_IDENTITY);
  }
  /**
   * Copies all data from another property to this one. Child properties are copied by reference,
   * unless a 'resolve' function is given to override that.
   * @param other Property to copy references from.
   * @param resolve Function to resolve each Property being transferred. Default is identity.
   */
  copy(other, resolve = COPY_IDENTITY) {
    // Remove previous references.
    for (const key in this[$attributes]) {
      const value = this[$attributes][key];
      if (value instanceof GraphEdge) {
        if (!this[$immutableKeys].has(key)) {
          value.dispose();
        }
      } else if (value instanceof RefList || value instanceof RefSet) {
        for (const ref of value.values()) {
          ref.dispose();
        }
      } else if (value instanceof RefMap) {
        for (const ref of value.values()) {
          ref.dispose();
        }
      }
    }
    // Add new references.
    for (const key in other[$attributes]) {
      const thisValue = this[$attributes][key];
      const otherValue = other[$attributes][key];
      if (otherValue instanceof GraphEdge) {
        if (this[$immutableKeys].has(key)) {
          const ref = thisValue;
          ref.getChild().copy(resolve(otherValue.getChild()), resolve);
        } else {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          this.setRef(key, resolve(otherValue.getChild()), otherValue.getAttributes());
        }
      } else if (otherValue instanceof RefSet || otherValue instanceof RefList) {
        for (const ref of otherValue.values()) {
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          this.addRef(key, resolve(ref.getChild()), ref.getAttributes());
        }
      } else if (otherValue instanceof RefMap) {
        for (const subkey of otherValue.keys()) {
          const ref = otherValue.get(subkey);
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          this.setRefMap(key, subkey, resolve(ref.getChild()), ref.getAttributes());
        }
      } else if (isPlainObject(otherValue)) {
        this[$attributes][key] = JSON.parse(JSON.stringify(otherValue));
      } else if (Array.isArray(otherValue) || otherValue instanceof ArrayBuffer || ArrayBuffer.isView(otherValue)) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this[$attributes][key] = otherValue.slice();
      } else {
        this[$attributes][key] = otherValue;
      }
    }
    return this;
  }
  /**
   * Returns true if two properties are deeply equivalent, recursively comparing the attributes
   * of the properties. Optionally, a 'skip' set may be included, specifying attributes whose
   * values should not be considered in the comparison.
   *
   * Example: Two {@link Primitive Primitives} are equivalent if they have accessors and
   * materials with equivalent content — but not necessarily the same specific accessors
   * and materials.
   */
  equals(other, skip = EMPTY_SET) {
    if (this === other) return true;
    if (this.propertyType !== other.propertyType) return false;
    for (const key in this[$attributes]) {
      if (skip.has(key)) continue;
      const a = this[$attributes][key];
      const b = other[$attributes][key];
      if (a instanceof GraphEdge || b instanceof GraphEdge) {
        if (!equalsRef(a, b)) {
          return false;
        }
      } else if (a instanceof RefSet || b instanceof RefSet || a instanceof RefList || b instanceof RefList) {
        if (!equalsRefSet(a, b)) {
          return false;
        }
      } else if (a instanceof RefMap || b instanceof RefMap) {
        if (!equalsRefMap(a, b)) {
          return false;
        }
      } else if (isPlainObject(a) || isPlainObject(b)) {
        if (!equalsObject(a, b)) return false;
      } else if (isArray(a) || isArray(b)) {
        if (!equalsArray(a, b)) return false;
      } else {
        // Literal.
        if (a !== b) return false;
      }
    }
    return true;
  }
  detach() {
    // Detaching should keep properties in the same Document, and attached to its root.
    this.graph.disconnectParents(this, n => n.propertyType !== 'Root');
    return this;
  }
  /**
   * Returns a list of all properties that hold a reference to this property. For example, a
   * material may hold references to various textures, but a texture does not hold references
   * to the materials that use it.
   *
   * It is often necessary to filter the results for a particular type: some resources, like
   * {@link Accessor}s, may be referenced by different types of properties. Most properties
   * include the {@link Root} as a parent, which is usually not of interest.
   *
   * Usage:
   *
   * ```ts
   * const materials = texture
   * 	.listParents()
   * 	.filter((p) => p instanceof Material)
   * ```
   */
  listParents() {
    return this.graph.listParents(this);
  }
}

/**
 * *A {@link Property} that can have {@link ExtensionProperty} instances attached.*
 *
 * Most properties are extensible. See the {@link Extension} documentation for information about
 * how to use extensions.
 *
 * @category Properties
 */
class ExtensibleProperty extends Property {
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      extensions: new RefMap()
    });
  }
  /** Returns an {@link ExtensionProperty} attached to this Property, if any. */
  getExtension(name) {
    return this.getRefMap('extensions', name);
  }
  /**
   * Attaches the given {@link ExtensionProperty} to this Property. For a given extension, only
   * one ExtensionProperty may be attached to any one Property at a time.
   */
  setExtension(name, extensionProperty) {
    if (extensionProperty) extensionProperty._validateParent(this);
    return this.setRefMap('extensions', name, extensionProperty);
  }
  /** Lists all {@link ExtensionProperty} instances attached to this Property. */
  listExtensions() {
    return this.listRefMapValues('extensions');
  }
}

/**
 * *Accessors store lists of numeric, vector, or matrix elements in a typed array.*
 *
 * All large data for {@link Mesh}, {@link Skin}, and {@link Animation} properties is stored in
 * {@link Accessor}s, organized into one or more {@link Buffer}s. Each accessor provides data in
 * typed arrays, with two abstractions:
 *
 * *Elements* are the logical divisions of the data into useful types: `"SCALAR"`, `"VEC2"`,
 * `"VEC3"`, `"VEC4"`, `"MAT3"`, or `"MAT4"`. The element type can be determined with the
 * {@link Accessor.getType getType}() method, and the number of elements in the accessor determine its
 * {@link Accessor.getCount getCount}(). The number of components in an element — e.g. 9 for `"MAT3"` — are its
 * {@link Accessor.getElementSize getElementSize}(). See {@link Accessor.Type}.
 *
 * *Components* are the numeric values within an element — e.g. `.x` and `.y` for `"VEC2"`. Various
 * component types are available: `BYTE`, `UNSIGNED_BYTE`, `SHORT`, `UNSIGNED_SHORT`,
 * `UNSIGNED_INT`, and `FLOAT`. The component type can be determined with the
 * {@link Accessor.getComponentType getComponentType} method, and the number of bytes in each component determine its
 * {@link Accessor.getComponentSize getComponentSize}. See {@link Accessor.ComponentType}.
 *
 * Usage:
 *
 * ```typescript
 * const accessor = doc.createAccessor('myData')
 * 	.setArray(new Float32Array([1,2,3,4,5,6,7,8,9,10,11,12]))
 * 	.setType(Accessor.Type.VEC3)
 * 	.setBuffer(doc.getRoot().listBuffers()[0]);
 *
 * accessor.getCount();        // → 4
 * accessor.getElementSize();  // → 3
 * accessor.getByteLength();   // → 48
 * accessor.getElement(1, []); // → [4, 5, 6]
 *
 * accessor.setElement(0, [10, 20, 30]);
 * ```
 *
 * Data access through the {@link Accessor.getElement getElement} and {@link Accessor.setElement setElement}
 * methods reads or overwrites the content of the underlying typed array. These methods use
 * element arrays intended to be compatible with the [gl-matrix](https://github.com/toji/gl-matrix)
 * library, or with the `toArray`/`fromArray` methods of libraries like three.js and babylon.js.
 *
 * Each Accessor must be assigned to a {@link Buffer}, which determines where the accessor's data
 * is stored in the final file. Assigning Accessors to different Buffers allows the data to be
 * written to different `.bin` files.
 *
 * glTF Transform does not expose many details of sparse, normalized, or interleaved accessors
 * through its API. It reads files using those techniques, presents a simplified view of the data
 * for editing, and attempts to write data back out with optimizations. For example, vertex
 * attributes will typically be interleaved by default, regardless of the input file.
 *
 * References:
 * - [glTF → Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)
 *
 * @category Properties
 */
class Accessor extends ExtensibleProperty {
  /**********************************************************************************************
   * Instance.
   */
  init() {
    this.propertyType = PropertyType.ACCESSOR;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      array: null,
      type: Accessor.Type.SCALAR,
      componentType: Accessor.ComponentType.FLOAT,
      normalized: false,
      sparse: false,
      buffer: null
    });
  }
  /**********************************************************************************************
   * Static.
   */
  /** Returns size of a given element type, in components. */
  static getElementSize(type) {
    switch (type) {
      case Accessor.Type.SCALAR:
        return 1;
      case Accessor.Type.VEC2:
        return 2;
      case Accessor.Type.VEC3:
        return 3;
      case Accessor.Type.VEC4:
        return 4;
      case Accessor.Type.MAT2:
        return 4;
      case Accessor.Type.MAT3:
        return 9;
      case Accessor.Type.MAT4:
        return 16;
      default:
        throw new Error('Unexpected type: ' + type);
    }
  }
  /** Returns size of a given component type, in bytes. */
  static getComponentSize(componentType) {
    switch (componentType) {
      case Accessor.ComponentType.BYTE:
        return 1;
      case Accessor.ComponentType.UNSIGNED_BYTE:
        return 1;
      case Accessor.ComponentType.SHORT:
        return 2;
      case Accessor.ComponentType.UNSIGNED_SHORT:
        return 2;
      case Accessor.ComponentType.UNSIGNED_INT:
        return 4;
      case Accessor.ComponentType.FLOAT:
        return 4;
      default:
        throw new Error('Unexpected component type: ' + componentType);
    }
  }
  /**********************************************************************************************
   * Min/max bounds.
   */
  /**
   * Minimum value of each component in this attribute. Unlike in a final glTF file, values
   * returned by this method will reflect the minimum accounting for {@link .normalized}
   * state.
   */
  getMinNormalized(target) {
    const normalized = this.getNormalized();
    const elementSize = this.getElementSize();
    const componentType = this.getComponentType();
    this.getMin(target);
    if (normalized) {
      for (let j = 0; j < elementSize; j++) {
        target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);
      }
    }
    return target;
  }
  /**
   * Minimum value of each component in this attribute. Values returned by this method do not
   * reflect normalization: use {@link .getMinNormalized} in that case.
   */
  getMin(target) {
    const array = this.getArray();
    const count = this.getCount();
    const elementSize = this.getElementSize();
    for (let j = 0; j < elementSize; j++) target[j] = Infinity;
    for (let i = 0; i < count * elementSize; i += elementSize) {
      for (let j = 0; j < elementSize; j++) {
        const value = array[i + j];
        if (Number.isFinite(value)) {
          target[j] = Math.min(target[j], value);
        }
      }
    }
    return target;
  }
  /**
   * Maximum value of each component in this attribute. Unlike in a final glTF file, values
   * returned by this method will reflect the minimum accounting for {@link .normalized}
   * state.
   */
  getMaxNormalized(target) {
    const normalized = this.getNormalized();
    const elementSize = this.getElementSize();
    const componentType = this.getComponentType();
    this.getMax(target);
    if (normalized) {
      for (let j = 0; j < elementSize; j++) {
        target[j] = MathUtils.decodeNormalizedInt(target[j], componentType);
      }
    }
    return target;
  }
  /**
   * Maximum value of each component in this attribute. Values returned by this method do not
   * reflect normalization: use {@link .getMinNormalized} in that case.
   */
  getMax(target) {
    const array = this.get('array');
    const count = this.getCount();
    const elementSize = this.getElementSize();
    for (let j = 0; j < elementSize; j++) target[j] = -Infinity;
    for (let i = 0; i < count * elementSize; i += elementSize) {
      for (let j = 0; j < elementSize; j++) {
        const value = array[i + j];
        if (Number.isFinite(value)) {
          target[j] = Math.max(target[j], value);
        }
      }
    }
    return target;
  }
  /**********************************************************************************************
   * Layout.
   */
  /**
   * Number of elements in the accessor. An array of length 30, containing 10 `VEC3` elements,
   * will have a count of 10.
   */
  getCount() {
    const array = this.get('array');
    return array ? array.length / this.getElementSize() : 0;
  }
  /** Type of element stored in the accessor. `VEC2`, `VEC3`, etc. */
  getType() {
    return this.get('type');
  }
  /**
   * Sets type of element stored in the accessor. `VEC2`, `VEC3`, etc. Array length must be a
   * multiple of the component size (`VEC2` = 2, `VEC3` = 3, ...) for the selected type.
   */
  setType(type) {
    return this.set('type', type);
  }
  /**
   * Number of components in each element of the accessor. For example, the element size of a
   * `VEC2` accessor is 2. This value is determined automatically based on array length and
   * accessor type, specified with {@link Accessor.setType setType()}.
   */
  getElementSize() {
    return Accessor.getElementSize(this.get('type'));
  }
  /**
   * Size of each component (a value in the raw array), in bytes. For example, the
   * `componentSize` of data backed by a `float32` array is 4 bytes.
   */
  getComponentSize() {
    return this.get('array').BYTES_PER_ELEMENT;
  }
  /**
   * Component type (float32, uint16, etc.). This value is determined automatically, and can only
   * be modified by replacing the underlying array.
   */
  getComponentType() {
    return this.get('componentType');
  }
  /**********************************************************************************************
   * Normalization.
   */
  /**
   * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned
   * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.
   * This property is defined only for accessors that contain vertex attributes or animation
   * output data.
   */
  getNormalized() {
    return this.get('normalized');
  }
  /**
   * Specifies whether integer data values should be normalized (true) to [0, 1] (for unsigned
   * types) or [-1, 1] (for signed types), or converted directly (false) when they are accessed.
   * This property is defined only for accessors that contain vertex attributes or animation
   * output data.
   */
  setNormalized(normalized) {
    return this.set('normalized', normalized);
  }
  /**********************************************************************************************
   * Data access.
   */
  /**
   * Returns the scalar element value at the given index. For
   * {@link Accessor.getNormalized normalized} integer accessors, values are
   * decoded and returned in floating-point form.
   */
  getScalar(index) {
    const elementSize = this.getElementSize();
    const componentType = this.getComponentType();
    const array = this.getArray();
    if (this.getNormalized()) {
      return MathUtils.decodeNormalizedInt(array[index * elementSize], componentType);
    }
    return array[index * elementSize];
  }
  /**
   * Assigns the scalar element value at the given index. For
   * {@link Accessor.getNormalized normalized} integer accessors, "value" should be
   * given in floating-point form — it will be integer-encoded before writing
   * to the underlying array.
   */
  setScalar(index, x) {
    const elementSize = this.getElementSize();
    const componentType = this.getComponentType();
    const array = this.getArray();
    if (this.getNormalized()) {
      array[index * elementSize] = MathUtils.encodeNormalizedInt(x, componentType);
    } else {
      array[index * elementSize] = x;
    }
    return this;
  }
  /**
   * Returns the vector or matrix element value at the given index. For
   * {@link Accessor.getNormalized normalized} integer accessors, values are
   * decoded and returned in floating-point form.
   *
   * Example:
   *
   * ```javascript
   * import { add } from 'gl-matrix/add';
   *
   * const element = [];
   * const offset = [1, 1, 1];
   *
   * for (let i = 0; i < accessor.getCount(); i++) {
   * 	accessor.getElement(i, element);
   * 	add(element, element, offset);
   * 	accessor.setElement(i, element);
   * }
   * ```
   */
  getElement(index, target) {
    const normalized = this.getNormalized();
    const elementSize = this.getElementSize();
    const componentType = this.getComponentType();
    const array = this.getArray();
    for (let i = 0; i < elementSize; i++) {
      if (normalized) {
        target[i] = MathUtils.decodeNormalizedInt(array[index * elementSize + i], componentType);
      } else {
        target[i] = array[index * elementSize + i];
      }
    }
    return target;
  }
  /**
   * Assigns the vector or matrix element value at the given index. For
   * {@link Accessor.getNormalized normalized} integer accessors, "value" should be
   * given in floating-point form — it will be integer-encoded before writing
   * to the underlying array.
   *
   * Example:
   *
   * ```javascript
   * import { add } from 'gl-matrix/add';
   *
   * const element = [];
   * const offset = [1, 1, 1];
   *
   * for (let i = 0; i < accessor.getCount(); i++) {
   * 	accessor.getElement(i, element);
   * 	add(element, element, offset);
   * 	accessor.setElement(i, element);
   * }
   * ```
   */
  setElement(index, value) {
    const normalized = this.getNormalized();
    const elementSize = this.getElementSize();
    const componentType = this.getComponentType();
    const array = this.getArray();
    for (let i = 0; i < elementSize; i++) {
      if (normalized) {
        array[index * elementSize + i] = MathUtils.encodeNormalizedInt(value[i], componentType);
      } else {
        array[index * elementSize + i] = value[i];
      }
    }
    return this;
  }
  /**********************************************************************************************
   * Raw data storage.
   */
  /**
   * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse
   * accessors store only values that differ from base values. When loaded in glTF Transform (or most
   * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always
   * uses zeroes for the base values when writing files.
   * @experimental
   */
  getSparse() {
    return this.get('sparse');
  }
  /**
   * Specifies whether the accessor should be stored sparsely. When written to a glTF file, sparse
   * accessors store only values that differ from base values. When loaded in glTF Transform (or most
   * runtimes) a sparse accessor can be treated like any other accessor. Currently, glTF Transform always
   * uses zeroes for the base values when writing files.
   * @experimental
   */
  setSparse(sparse) {
    return this.set('sparse', sparse);
  }
  /** Returns the {@link Buffer} into which this accessor will be organized. */
  getBuffer() {
    return this.getRef('buffer');
  }
  /** Assigns the {@link Buffer} into which this accessor will be organized. */
  setBuffer(buffer) {
    return this.setRef('buffer', buffer);
  }
  /** Returns the raw typed array underlying this accessor. */
  getArray() {
    return this.get('array');
  }
  /** Assigns the raw typed array underlying this accessor. */
  setArray(array) {
    this.set('componentType', array ? arrayToComponentType(array) : Accessor.ComponentType.FLOAT);
    this.set('array', array);
    return this;
  }
  /** Returns the total bytelength of this accessor, exclusive of padding. */
  getByteLength() {
    const array = this.get('array');
    return array ? array.byteLength : 0;
  }
}
/**************************************************************************************************
 * Accessor utilities.
 */
/** @internal */
/**********************************************************************************************
 * Constants.
 */
/** Element type contained by the accessor (SCALAR, VEC2, ...). */
Accessor.Type = {
  /** Scalar, having 1 value per element. */
  SCALAR: 'SCALAR',
  /** 2-component vector, having 2 components per element. */
  VEC2: 'VEC2',
  /** 3-component vector, having 3 components per element. */
  VEC3: 'VEC3',
  /** 4-component vector, having 4 components per element. */
  VEC4: 'VEC4',
  /** 2x2 matrix, having 4 components per element. */
  MAT2: 'MAT2',
  /** 3x3 matrix, having 9 components per element. */
  MAT3: 'MAT3',
  /** 4x3 matrix, having 16 components per element. */
  MAT4: 'MAT4'
};
/** Data type of the values composing each element in the accessor. */
Accessor.ComponentType = {
  /**
   * 1-byte signed integer, stored as
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array Int8Array}.
   */
  BYTE: 5120,
  /**
   * 1-byte unsigned integer, stored as
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array Uint8Array}.
   */
  UNSIGNED_BYTE: 5121,
  /**
   * 2-byte signed integer, stored as
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array Int16Array}.
   */
  SHORT: 5122,
  /**
   * 2-byte unsigned integer, stored as
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array Uint16Array}.
   */
  UNSIGNED_SHORT: 5123,
  /**
   * 4-byte unsigned integer, stored as
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array Uint32Array}.
   */
  UNSIGNED_INT: 5125,
  /**
   * 4-byte floating point number, stored as
   * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array Float32Array}.
   */
  FLOAT: 5126
};
function arrayToComponentType(array) {
  switch (array.constructor) {
    case Float32Array:
      return Accessor.ComponentType.FLOAT;
    case Uint32Array:
      return Accessor.ComponentType.UNSIGNED_INT;
    case Uint16Array:
      return Accessor.ComponentType.UNSIGNED_SHORT;
    case Uint8Array:
      return Accessor.ComponentType.UNSIGNED_BYTE;
    case Int16Array:
      return Accessor.ComponentType.SHORT;
    case Int8Array:
      return Accessor.ComponentType.BYTE;
    default:
      throw new Error('Unknown accessor componentType.');
  }
}

/**
 * *Reusable collections of {@link AnimationChannel}s, together representing a discrete animation
 * clip.*
 *
 * One Animation represents one playable unit in an animation system. Each may contain channels
 * affecting multiple paths (`translation`, `rotation`, `scale`, or `weights`) on multiple
 * {@link Node}s. An Animation's channels must be played together, and do not have any meaning in
 * isolation.
 *
 * Multiple Animations _may_ be played together: for example, one character's _Walk_ animation
 * might play while another character's _Run_ animation plays. Or a single character might have
 * both an _Idle_ and a _Talk_ animation playing at the same time. However, glTF does not define
 * any particular relationship between top-level Animations, or any particular playback behavior
 * like looping or sequences of Animations. General-purpose viewers typically autoplay the first
 * animation and provide UI controls for choosing another. Game engines may have significantly
 * more advanced methods of playing and blending animations.
 *
 * For example, a very simple skinned {@link Mesh} might have two Animations, _Idle_ and _Walk_.
 * Each of those Animations might affect the rotations of two bones, _LegL_ and _LegR_, where the
 * keyframes for each target-path pair are stored in {@link AnimationChannel} instances. In  total,
 * this model would contain two Animations and Four {@link AnimationChannel}s.
 *
 * Usage:
 *
 * ```ts
 * const animation = doc.createAnimation('machineRun')
 * 	.addChannel(rotateCog1)
 * 	.addChannel(rotateCog2)
 * 	.addChannel(rotateCog3);
 * ```
 *
 * Reference
 * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)
 *
 * @category Properties
 */
class Animation extends ExtensibleProperty {
  init() {
    this.propertyType = PropertyType.ANIMATION;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      channels: new RefSet(),
      samplers: new RefSet()
    });
  }
  /** Adds an {@link AnimationChannel} to this Animation. */
  addChannel(channel) {
    return this.addRef('channels', channel);
  }
  /** Removes an {@link AnimationChannel} from this Animation. */
  removeChannel(channel) {
    return this.removeRef('channels', channel);
  }
  /** Lists {@link AnimationChannel}s in this Animation. */
  listChannels() {
    return this.listRefs('channels');
  }
  /** Adds an {@link AnimationSampler} to this Animation. */
  addSampler(sampler) {
    return this.addRef('samplers', sampler);
  }
  /** Removes an {@link AnimationSampler} from this Animation. */
  removeSampler(sampler) {
    return this.removeRef('samplers', sampler);
  }
  /** Lists {@link AnimationSampler}s in this Animation. */
  listSamplers() {
    return this.listRefs('samplers');
  }
}

/**
 * *A target-path pair within a larger {@link Animation}, which refers to an
 * {@link AnimationSampler} storing the keyframe data for that pair.*
 *
 * A _target_ is always a {@link Node}, in the core glTF spec. A _path_ is any property of that
 * Node that can be affected by animation: `translation`, `rotation`, `scale`, or `weights`. An
 * {@link Animation} affecting the positions and rotations of several {@link Node}s would contain
 * one channel for each Node-position or Node-rotation pair. The keyframe data for an
 * AnimationChannel is stored in an {@link AnimationSampler}, which must be attached to the same
 * {@link Animation}.
 *
 * Usage:
 *
 * ```ts
 * const node = doc.getRoot()
 * 	.listNodes()
 * 	.find((node) => node.getName() === 'Cog');
 *
 * const channel = doc.createAnimationChannel('cogRotation')
 * 	.setTargetPath('rotation')
 * 	.setTargetNode(node)
 * 	.setSampler(rotateSampler);
 * ```
 *
 * Reference
 * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)
 *
 * @category Properties
 */
class AnimationChannel extends ExtensibleProperty {
  /**********************************************************************************************
   * Instance.
   */
  init() {
    this.propertyType = PropertyType.ANIMATION_CHANNEL;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      targetPath: null,
      targetNode: null,
      sampler: null
    });
  }
  /**********************************************************************************************
   * Properties.
   */
  /**
   * Path (property) animated on the target {@link Node}. Supported values include:
   * `translation`, `rotation`, `scale`, or `weights`.
   */
  getTargetPath() {
    return this.get('targetPath');
  }
  /**
   * Path (property) animated on the target {@link Node}. Supported values include:
   * `translation`, `rotation`, `scale`, or `weights`.
   */
  setTargetPath(targetPath) {
    return this.set('targetPath', targetPath);
  }
  /** Target {@link Node} animated by the channel. */
  getTargetNode() {
    return this.getRef('targetNode');
  }
  /** Target {@link Node} animated by the channel. */
  setTargetNode(targetNode) {
    return this.setRef('targetNode', targetNode);
  }
  /**
   * Keyframe data input/output values for the channel. Must be attached to the same
   * {@link Animation}.
   */
  getSampler() {
    return this.getRef('sampler');
  }
  /**
   * Keyframe data input/output values for the channel. Must be attached to the same
   * {@link Animation}.
   */
  setSampler(sampler) {
    return this.setRef('sampler', sampler);
  }
}
/**********************************************************************************************
 * Constants.
 */
/** Name of the property to be modified by an animation channel. */
AnimationChannel.TargetPath = {
  /** Channel targets {@link Node.setTranslation}. */
  TRANSLATION: 'translation',
  /** Channel targets {@link Node.setRotation}. */
  ROTATION: 'rotation',
  /** Channel targets {@link Node.setScale}. */
  SCALE: 'scale',
  /** Channel targets {@link Node.setWeights}, affecting {@link PrimitiveTarget} weights. */
  WEIGHTS: 'weights'
};

/**
 * *Reusable collection of keyframes affecting particular property of an object.*
 *
 * Each AnimationSampler refers to an input and an output {@link Accessor}. Input contains times
 * (in seconds) for each keyframe. Output contains values (of any {@link Accessor.Type}) for the
 * animated property at each keyframe. Samplers using `CUBICSPLINE` interpolation will also contain
 * in/out tangents in the output, with the layout:
 *
 * in<sub>1</sub>, value<sub>1</sub>, out<sub>1</sub>,
 * in<sub>2</sub>, value<sub>2</sub>, out<sub>2</sub>,
 * in<sub>3</sub>, value<sub>3</sub>, out<sub>3</sub>, ...
 *
 * Usage:
 *
 * ```ts
 * // Create accessor containing input times, in seconds.
 * const input = doc.createAccessor('bounceTimes')
 * 	.setArray(new Float32Array([0, 1, 2]))
 * 	.setType(Accessor.Type.SCALAR);
 *
 * // Create accessor containing output values, in local units.
 * const output = doc.createAccessor('bounceValues')
 * 	.setArray(new Float32Array([
 * 		0, 0, 0, // y = 0
 * 		0, 1, 0, // y = 1
 * 		0, 0, 0, // y = 0
 * 	]))
 * 	.setType(Accessor.Type.VEC3);
 *
 * // Create sampler.
 * const sampler = doc.createAnimationSampler('bounce')
 * 	.setInput(input)
 * 	.setOutput(output)
 * 	.setInterpolation('LINEAR');
 * ```
 *
 * Reference
 * - [glTF → Animations](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#animations)
 *
 * @category Properties
 */
class AnimationSampler extends ExtensibleProperty {
  /**********************************************************************************************
   * Instance.
   */
  init() {
    this.propertyType = PropertyType.ANIMATION_SAMPLER;
  }
  getDefaultAttributes() {
    return Object.assign(super.getDefaults(), {
      interpolation: AnimationSampler.Interpolation.LINEAR,
      input: null,
      output: null
    });
  }
  /**********************************************************************************************
   * Static.
   */
  /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */
  getInterpolation() {
    return this.get('interpolation');
  }
  /** Interpolation mode: `STEP`, `LINEAR`, or `CUBICSPLINE`. */
  setInterpolation(interpolation) {
    return this.set('interpolation', interpolation);
  }
  /** Times for each keyframe, in seconds. */
  getInput() {
    return this.getRef('input');
  }
  /** Times for each keyframe, in seconds. */
  setInput(input) {
    return this.setRef('input', input, {
      usage: BufferViewUsage$1.OTHER
    });
  }
  /**
   * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out
   * tangents.
   */
  getOutput() {
    return this.getRef('output');
  }
  /**
   * Values for each keyframe. For `CUBICSPLINE` interpolation, output also contains in/out
   * tangents.
   */
  setOutput(output) {
    return this.setRef('output', output, {
      usage: BufferViewUsage$1.OTHER
    });
  }
}
/**********************************************************************************************
 * Constants.
 */
/** Interpolation method. */
AnimationSampler.Interpolation = {
  /** Animated values are linearly interpolated between keyframes. */
  LINEAR: 'LINEAR',
  /** Animated values remain constant from one keyframe until the next keyframe. */
  STEP: 'STEP',
  /** Animated values are interpolated according to given cubic spline tangents. */
  CUBICSPLINE: 'CUBICSPLINE'
};

/**
 * *Buffers are low-level storage units for binary data.*
 *
 * glTF 2.0 has three concepts relevant to binary storage: accessors, buffer views, and buffers.
 * In glTF Transform, an {@link Accessor} is referenced by any property that requires numeric typed
 * array data. Meshes, Primitives, and Animations all reference Accessors. Buffers define how that
 * data is organized into transmitted file(s). A `.glb` file has only a single Buffer, and when
 * exporting to `.glb` your resources should be grouped accordingly. A `.gltf` file may reference
 * one or more `.bin` files — each `.bin` is a Buffer — and grouping Accessors under different
 * Buffers allow you to specify that structure.
 *
 * For engines that can dynamically load portions of a glTF file, splitting data into separate
 * buffers can allow you to avoid loading data until it is needed. For example, you might put
 * binary data for specific meshes into a different `.bin` buffer, or put each animation's binary
 * payload into its own `.bin`.
 *
 * Buffer Views define how Accessors are organized within a given Buffer. glTF Transform creates an
 * efficient Buffer View layout automatically at export: there is no Buffer View property exposed
 * by the glTF Transform API, simplifying data management.
 *
 * Usage:
 *
 * ```ts
 * // Create two buffers with custom filenames.
 * const buffer1 = doc.createBuffer('buffer1')
 * 	.setURI('part1.bin');
 * const buffer2 = doc.createBuffer('buffer2')
 * 	.setURI('part2.bin');
 *
 * // Assign the attributes of two meshes to different buffers. If the meshes
 * // had indices or morph target attributes, you would also want to relocate
 * // those accessors.
 * mesh1
 * 	.listPrimitives()
 * 	.forEach((primitive) => primitive.listAttributes()
 * 		.forEach((attribute) => attribute.setBuffer(buffer1)));
 * mesh2
 * 	.listPrimitives()
 * 	.forEach((primitive) => primitive.listAttributes()
 * 		.forEach((attribute) => attribute.setBuffer(buffer2)));
 *
 * // Write to disk. Each mesh's binary data will be in a separate binary file;
 * // any remaining accessors will be in a third (default) buffer.
 * await new NodeIO().write('scene.gltf', doc);
 * // → scene.gltf, part1.bin, part2.bin
 * ```
 *
 * References:
 * - [glTF → Buffers and Buffer Views](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#buffers-and-buffer-views)
 * - [glTF → Accessors](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#accessors)
 *
 * @category Properties
 */
class Buffer$1 extends ExtensibleProperty {
  init() {
    this.propertyType = PropertyType.BUFFER;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      uri: ''
    });
  }
  /**
   * Returns the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly
   * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)
   * is possible for custom applications, but will limit the compatibility of the asset with most
   * tools.
   *
   * Buffers commonly use the extension `.bin`, though this is not required.
   */
  getURI() {
    return this.get('uri');
  }
  /**
   * Sets the URI (or filename) of this buffer (e.g. 'myBuffer.bin'). URIs are strongly
   * encouraged to be relative paths, rather than absolute. Use of a protocol (like `file://`)
   * is possible for custom applications, but will limit the compatibility of the asset with most
   * tools.
   *
   * Buffers commonly use the extension `.bin`, though this is not required.
   */
  setURI(uri) {
    return this.set('uri', uri);
  }
}

/**
 * *Cameras are perspectives through which the {@link Scene} may be viewed.*
 *
 * Projection can be perspective or orthographic. Cameras are contained in nodes and thus can be
 * transformed. The camera is defined such that the local +X axis is to the right, the lens looks
 * towards the local -Z axis, and the top of the camera is aligned with the local +Y axis. If no
 * transformation is specified, the location of the camera is at the origin.
 *
 * Usage:
 *
 * ```typescript
 * const camera = doc.createCamera('myCamera')
 * 	.setType(GLTF.CameraType.PERSPECTIVE)
 * 	.setZNear(0.1)
 * 	.setZFar(100)
 * 	.setYFov(Math.PI / 4)
 * 	.setAspectRatio(1.5);
 *
 * node.setCamera(camera);
 * ```
 *
 * References:
 * - [glTF → Cameras](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#cameras)
 *
 * @category Properties
 */
class Camera extends ExtensibleProperty {
  /**********************************************************************************************
   * Instance.
   */
  init() {
    this.propertyType = PropertyType.CAMERA;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      // Common.
      type: Camera.Type.PERSPECTIVE,
      znear: 0.1,
      zfar: 100,
      // Perspective.
      aspectRatio: null,
      yfov: Math.PI * 2 * 50 / 360,
      // 50º
      // Orthographic.
      xmag: 1,
      ymag: 1
    });
  }
  /**********************************************************************************************
   * Common.
   */
  /** Specifies if the camera uses a perspective or orthographic projection. */
  getType() {
    return this.get('type');
  }
  /** Specifies if the camera uses a perspective or orthographic projection. */
  setType(type) {
    return this.set('type', type);
  }
  /** Floating-point distance to the near clipping plane. */
  getZNear() {
    return this.get('znear');
  }
  /** Floating-point distance to the near clipping plane. */
  setZNear(znear) {
    return this.set('znear', znear);
  }
  /**
   * Floating-point distance to the far clipping plane. When defined, zfar must be greater than
   * znear. If zfar is undefined, runtime must use infinite projection matrix.
   */
  getZFar() {
    return this.get('zfar');
  }
  /**
   * Floating-point distance to the far clipping plane. When defined, zfar must be greater than
   * znear. If zfar is undefined, runtime must use infinite projection matrix.
   */
  setZFar(zfar) {
    return this.set('zfar', zfar);
  }
  /**********************************************************************************************
   * Perspective.
   */
  /**
   * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the
   * canvas is used.
   */
  getAspectRatio() {
    return this.get('aspectRatio');
  }
  /**
   * Floating-point aspect ratio of the field of view. When undefined, the aspect ratio of the
   * canvas is used.
   */
  setAspectRatio(aspectRatio) {
    return this.set('aspectRatio', aspectRatio);
  }
  /** Floating-point vertical field of view in radians. */
  getYFov() {
    return this.get('yfov');
  }
  /** Floating-point vertical field of view in radians. */
  setYFov(yfov) {
    return this.set('yfov', yfov);
  }
  /**********************************************************************************************
   * Orthographic.
   */
  /**
   * Floating-point horizontal magnification of the view, and half the view's width
   * in world units.
   */
  getXMag() {
    return this.get('xmag');
  }
  /**
   * Floating-point horizontal magnification of the view, and half the view's width
   * in world units.
   */
  setXMag(xmag) {
    return this.set('xmag', xmag);
  }
  /**
   * Floating-point vertical magnification of the view, and half the view's height
   * in world units.
   */
  getYMag() {
    return this.get('ymag');
  }
  /**
   * Floating-point vertical magnification of the view, and half the view's height
   * in world units.
   */
  setYMag(ymag) {
    return this.set('ymag', ymag);
  }
}
/**********************************************************************************************
 * Constants.
 */
Camera.Type = {
  /** A perspective camera representing a perspective projection matrix. */
  PERSPECTIVE: 'perspective',
  /** An orthographic camera representing an orthographic projection matrix. */
  ORTHOGRAPHIC: 'orthographic'
};

/**
 * *Base class for all {@link Property} types that can be attached by an {@link Extension}.*
 *
 * After an {@link Extension} is attached to a glTF {@link Document}, the Extension may be used to
 * construct ExtensionProperty instances, to be referenced throughout the document as prescribed by
 * the Extension. For example, the `KHR_materials_clearcoat` Extension defines a `Clearcoat`
 * ExtensionProperty, which is referenced by {@link Material} Properties in the Document, and may
 * contain references to {@link Texture} properties of its own.
 *
 * For more information on available extensions and their usage, see [Extensions](/extensions).
 *
 * Reference:
 * - [glTF → Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)
 *
 * @category Properties
 */
class ExtensionProperty extends Property {
  /** @hidden */
  _validateParent(parent) {
    if (!this.parentTypes.includes(parent.propertyType)) {
      throw new Error(`Parent "${parent.propertyType}" invalid for child "${this.propertyType}".`);
    }
  }
}
ExtensionProperty.EXTENSION_NAME = void 0;

/**
 * *Settings associated with a particular use of a {@link Texture}.*
 *
 * Different materials may reuse the same texture but with different texture coordinates,
 * minFilter/magFilter, or wrapS/wrapT settings. The TextureInfo class contains settings
 * derived from both the "TextureInfo" and "Sampler" properties in the glTF specification,
 * consolidated here for simplicity.
 *
 * TextureInfo properties cannot be directly created. For any material texture slot, such as
 * baseColorTexture, there will be a corresponding method to obtain the TextureInfo for that slot.
 * For example, see {@link Material.getBaseColorTextureInfo}.
 *
 * References:
 * - [glTF → Texture Info](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#reference-textureinfo)
 *
 * @category Properties
 */
class TextureInfo extends ExtensibleProperty {
  /**********************************************************************************************
   * Instance.
   */
  init() {
    this.propertyType = PropertyType.TEXTURE_INFO;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      texCoord: 0,
      magFilter: null,
      minFilter: null,
      wrapS: TextureInfo.WrapMode.REPEAT,
      wrapT: TextureInfo.WrapMode.REPEAT
    });
  }
  /**********************************************************************************************
   * Texture coordinates.
   */
  /** Returns the texture coordinate (UV set) index for the texture. */
  getTexCoord() {
    return this.get('texCoord');
  }
  /** Sets the texture coordinate (UV set) index for the texture. */
  setTexCoord(texCoord) {
    return this.set('texCoord', texCoord);
  }
  /**********************************************************************************************
   * Min/mag filter.
   */
  /** Returns the magnification filter applied to the texture. */
  getMagFilter() {
    return this.get('magFilter');
  }
  /** Sets the magnification filter applied to the texture. */
  setMagFilter(magFilter) {
    return this.set('magFilter', magFilter);
  }
  /** Sets the minification filter applied to the texture. */
  getMinFilter() {
    return this.get('minFilter');
  }
  /** Returns the minification filter applied to the texture. */
  setMinFilter(minFilter) {
    return this.set('minFilter', minFilter);
  }
  /**********************************************************************************************
   * UV wrapping.
   */
  /** Returns the S (U) wrapping mode for UVs used by the texture. */
  getWrapS() {
    return this.get('wrapS');
  }
  /** Sets the S (U) wrapping mode for UVs used by the texture. */
  setWrapS(wrapS) {
    return this.set('wrapS', wrapS);
  }
  /** Returns the T (V) wrapping mode for UVs used by the texture. */
  getWrapT() {
    return this.get('wrapT');
  }
  /** Sets the T (V) wrapping mode for UVs used by the texture. */
  setWrapT(wrapT) {
    return this.set('wrapT', wrapT);
  }
}
/**********************************************************************************************
 * Constants.
 */
/** UV wrapping mode. Values correspond to WebGL enums. */
TextureInfo.WrapMode = {
  /** */
  CLAMP_TO_EDGE: 33071,
  /** */
  MIRRORED_REPEAT: 33648,
  /** */
  REPEAT: 10497
};
/** Magnification filter. Values correspond to WebGL enums. */
TextureInfo.MagFilter = {
  /** */
  NEAREST: 9728,
  /** */
  LINEAR: 9729
};
/** Minification filter. Values correspond to WebGL enums. */
TextureInfo.MinFilter = {
  /** */
  NEAREST: 9728,
  /** */
  LINEAR: 9729,
  /** */
  NEAREST_MIPMAP_NEAREST: 9984,
  /** */
  LINEAR_MIPMAP_NEAREST: 9985,
  /** */
  NEAREST_MIPMAP_LINEAR: 9986,
  /** */
  LINEAR_MIPMAP_LINEAR: 9987
};

const {
  R: R$8,
  G: G$8,
  B: B$6,
  A: A$4
} = TextureChannel;
/**
 * *Materials describe a surface's appearance and response to light.*
 *
 * Each {@link Primitive} within a {@link Mesh} may be assigned a single Material. The number of
 * GPU draw calls typically increases with both the numbers of Primitives and of Materials in an
 * asset; Materials should be reused wherever possible. Techniques like texture atlasing and vertex
 * colors allow objects to have varied appearances while technically sharing a single Material.
 *
 * Material properties are modified by both scalars (like `baseColorFactor`) and textures (like
 * `baseColorTexture`). When both are available, factors are considered linear multipliers against
 * textures of the same name. In the case of base color, vertex colors (`COLOR_0` attributes) are
 * also multiplied.
 *
 * Textures containing color data (`baseColorTexture`, `emissiveTexture`) are sRGB. All other
 * textures are linear. Like other resources, textures should be reused when possible.
 *
 * Usage:
 *
 * ```typescript
 * const material = doc.createMaterial('myMaterial')
 * 	.setBaseColorFactor([1, 0.5, 0.5, 1]) // RGBA
 * 	.setOcclusionTexture(aoTexture)
 * 	.setOcclusionStrength(0.5);
 *
 * mesh.listPrimitives()
 * 	.forEach((prim) => prim.setMaterial(material));
 * ```
 *
 * @category Properties
 */
class Material extends ExtensibleProperty {
  /**********************************************************************************************
   * Instance.
   */
  init() {
    this.propertyType = PropertyType.MATERIAL;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      alphaMode: Material.AlphaMode.OPAQUE,
      alphaCutoff: 0.5,
      doubleSided: false,
      baseColorFactor: [1, 1, 1, 1],
      baseColorTexture: null,
      baseColorTextureInfo: new TextureInfo(this.graph, 'baseColorTextureInfo'),
      emissiveFactor: [0, 0, 0],
      emissiveTexture: null,
      emissiveTextureInfo: new TextureInfo(this.graph, 'emissiveTextureInfo'),
      normalScale: 1,
      normalTexture: null,
      normalTextureInfo: new TextureInfo(this.graph, 'normalTextureInfo'),
      occlusionStrength: 1,
      occlusionTexture: null,
      occlusionTextureInfo: new TextureInfo(this.graph, 'occlusionTextureInfo'),
      roughnessFactor: 1,
      metallicFactor: 1,
      metallicRoughnessTexture: null,
      metallicRoughnessTextureInfo: new TextureInfo(this.graph, 'metallicRoughnessTextureInfo')
    });
  }
  /**********************************************************************************************
   * Double-sided / culling.
   */
  /** Returns true when both sides of triangles should be rendered. May impact performance. */
  getDoubleSided() {
    return this.get('doubleSided');
  }
  /** Sets whether to render both sides of triangles. May impact performance. */
  setDoubleSided(doubleSided) {
    return this.set('doubleSided', doubleSided);
  }
  /**********************************************************************************************
   * Alpha.
   */
  /** Returns material alpha, equivalent to baseColorFactor[3]. */
  getAlpha() {
    return this.get('baseColorFactor')[3];
  }
  /** Sets material alpha, equivalent to baseColorFactor[3]. */
  setAlpha(alpha) {
    const baseColorFactor = this.get('baseColorFactor').slice();
    baseColorFactor[3] = alpha;
    return this.set('baseColorFactor', baseColorFactor);
  }
  /**
   * Returns the mode of the material's alpha channels, which are provided by `baseColorFactor`
   * and `baseColorTexture`.
   *
   * - `OPAQUE`: Alpha value is ignored and the rendered output is fully opaque.
   * - `BLEND`: Alpha value is used to determine the transparency each pixel on a surface, and
   * 	the fraction of surface vs. background color in the final result. Alpha blending creates
   *	significant edge cases in realtime renderers, and some care when structuring the model is
   * 	necessary for good results. In particular, transparent geometry should be kept in separate
   * 	meshes or primitives from opaque geometry. The `depthWrite` or `zWrite` settings in engines
   * 	should usually be disabled on transparent materials.
   * - `MASK`: Alpha value is compared against `alphaCutoff` threshold for each pixel on a
   * 	surface, and the pixel is either fully visible or fully discarded based on that cutoff.
   * 	This technique is useful for things like leafs/foliage, grass, fabric meshes, and other
   * 	surfaces where no semitransparency is needed. With a good choice of `alphaCutoff`, surfaces
   * 	that don't require semitransparency can avoid the performance penalties and visual issues
   * 	involved with `BLEND` transparency.
   *
   * Reference:
   * - [glTF → material.alphaMode](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialalphamode)
   */
  getAlphaMode() {
    return this.get('alphaMode');
  }
  /** Sets the mode of the material's alpha channels. See {@link Material.getAlphaMode getAlphaMode} for details. */
  setAlphaMode(alphaMode) {
    return this.set('alphaMode', alphaMode);
  }
  /** Returns the visibility threshold; applied only when `.alphaMode='MASK'`. */
  getAlphaCutoff() {
    return this.get('alphaCutoff');
  }
  /** Sets the visibility threshold; applied only when `.alphaMode='MASK'`. */
  setAlphaCutoff(alphaCutoff) {
    return this.set('alphaCutoff', alphaCutoff);
  }
  /**********************************************************************************************
   * Base color.
   */
  /**
   * Base color / albedo factor; Linear-sRGB components.
   * See {@link Material.getBaseColorTexture getBaseColorTexture}.
   */
  getBaseColorFactor() {
    return this.get('baseColorFactor');
  }
  /**
   * Base color / albedo factor; Linear-sRGB components.
   * See {@link Material.getBaseColorTexture getBaseColorTexture}.
   */
  setBaseColorFactor(baseColorFactor) {
    return this.set('baseColorFactor', baseColorFactor);
  }
  /**
   * Base color / albedo. The visible color of a non-metallic surface under constant ambient
   * light would be a linear combination (multiplication) of its vertex colors, base color
   * factor, and base color texture. Lighting, and reflections in metallic or smooth surfaces,
   * also effect the final color. The alpha (`.a`) channel of base color factors and textures
   * will have varying effects, based on the setting of {@link Material.getAlphaMode getAlphaMode}.
   *
   * Reference:
   * - [glTF → material.pbrMetallicRoughness.baseColorFactor](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessbasecolorfactor)
   */
  getBaseColorTexture() {
    return this.getRef('baseColorTexture');
  }
  /**
   * Settings affecting the material's use of its base color texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getBaseColorTextureInfo() {
    return this.getRef('baseColorTexture') ? this.getRef('baseColorTextureInfo') : null;
  }
  /** Sets base color / albedo texture. See {@link Material.getBaseColorTexture getBaseColorTexture}. */
  setBaseColorTexture(texture) {
    return this.setRef('baseColorTexture', texture, {
      channels: R$8 | G$8 | B$6 | A$4,
      isColor: true
    });
  }
  /**********************************************************************************************
   * Emissive.
   */
  /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */
  getEmissiveFactor() {
    return this.get('emissiveFactor');
  }
  /** Emissive color; Linear-sRGB components. See {@link Material.getEmissiveTexture getEmissiveTexture}. */
  setEmissiveFactor(emissiveFactor) {
    return this.set('emissiveFactor', emissiveFactor);
  }
  /**
   * Emissive texture. Emissive color is added to any base color of the material, after any
   * lighting/shadowing are applied. An emissive color does not inherently "glow", or affect
   * objects around it at all. To create that effect, most viewers must also enable a
   * post-processing effect called "bloom".
   *
   * Reference:
   * - [glTF → material.emissiveTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialemissivetexture)
   */
  getEmissiveTexture() {
    return this.getRef('emissiveTexture');
  }
  /**
   * Settings affecting the material's use of its emissive texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getEmissiveTextureInfo() {
    return this.getRef('emissiveTexture') ? this.getRef('emissiveTextureInfo') : null;
  }
  /** Sets emissive texture. See {@link Material.getEmissiveTexture getEmissiveTexture}. */
  setEmissiveTexture(texture) {
    return this.setRef('emissiveTexture', texture, {
      channels: R$8 | G$8 | B$6,
      isColor: true
    });
  }
  /**********************************************************************************************
   * Normal.
   */
  /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */
  getNormalScale() {
    return this.get('normalScale');
  }
  /** Normal (surface detail) factor; linear multiplier. Affects `.normalTexture`. */
  setNormalScale(scale) {
    return this.set('normalScale', scale);
  }
  /**
   * Normal (surface detail) texture.
   *
   * A tangent space normal map. The texture contains RGB components. Each texel represents the
   * XYZ components of a normal vector in tangent space. Red [0 to 255] maps to X [-1 to 1].
   * Green [0 to 255] maps to Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal
   * vectors use OpenGL conventions where +X is right and +Y is up. +Z points toward the viewer.
   *
   * Reference:
   * - [glTF → material.normalTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialnormaltexture)
   */
  getNormalTexture() {
    return this.getRef('normalTexture');
  }
  /**
   * Settings affecting the material's use of its normal texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getNormalTextureInfo() {
    return this.getRef('normalTexture') ? this.getRef('normalTextureInfo') : null;
  }
  /** Sets normal (surface detail) texture. See {@link Material.getNormalTexture getNormalTexture}. */
  setNormalTexture(texture) {
    return this.setRef('normalTexture', texture, {
      channels: R$8 | G$8 | B$6
    });
  }
  /**********************************************************************************************
   * Occlusion.
   */
  /** (Ambient) Occlusion factor; linear multiplier. Affects `.occlusionTexture`. */
  getOcclusionStrength() {
    return this.get('occlusionStrength');
  }
  /** Sets (ambient) occlusion factor; linear multiplier. Affects `.occlusionTexture`. */
  setOcclusionStrength(strength) {
    return this.set('occlusionStrength', strength);
  }
  /**
   * (Ambient) Occlusion texture, generally used for subtle 'baked' shadowing effects that are
   * independent of an object's position, such as shading in inset areas and corners. Direct
   * lighting is not affected by occlusion, so at least one indirect light source must be present
   * in the scene for occlusion effects to be visible.
   *
   * The occlusion values are sampled from the R channel. Higher values indicate areas that
   * should receive full indirect lighting and lower values indicate no indirect lighting.
   *
   * Reference:
   * - [glTF → material.occlusionTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#materialocclusiontexture)
   */
  getOcclusionTexture() {
    return this.getRef('occlusionTexture');
  }
  /**
   * Settings affecting the material's use of its occlusion texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getOcclusionTextureInfo() {
    return this.getRef('occlusionTexture') ? this.getRef('occlusionTextureInfo') : null;
  }
  /** Sets (ambient) occlusion texture. See {@link Material.getOcclusionTexture getOcclusionTexture}. */
  setOcclusionTexture(texture) {
    return this.setRef('occlusionTexture', texture, {
      channels: R$8
    });
  }
  /**********************************************************************************************
   * Metallic / roughness.
   */
  /**
   * Roughness factor; linear multiplier. Affects roughness channel of
   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
   */
  getRoughnessFactor() {
    return this.get('roughnessFactor');
  }
  /**
   * Sets roughness factor; linear multiplier. Affects roughness channel of
   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
   */
  setRoughnessFactor(factor) {
    return this.set('roughnessFactor', factor);
  }
  /**
   * Metallic factor; linear multiplier. Affects roughness channel of
   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
   */
  getMetallicFactor() {
    return this.get('metallicFactor');
  }
  /**
   * Sets metallic factor; linear multiplier. Affects roughness channel of
   * `metallicRoughnessTexture`. See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
   */
  setMetallicFactor(factor) {
    return this.set('metallicFactor', factor);
  }
  /**
   * Metallic roughness texture. The metalness values are sampled from the B channel. The
   * roughness values are sampled from the G channel. When a material is fully metallic,
   * or nearly so, it may require image-based lighting (i.e. an environment map) or global
   * illumination to appear well-lit.
   *
   * Reference:
   * - [glTF → material.pbrMetallicRoughness.metallicRoughnessTexture](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#pbrmetallicroughnessmetallicroughnesstexture)
   */
  getMetallicRoughnessTexture() {
    return this.getRef('metallicRoughnessTexture');
  }
  /**
   * Settings affecting the material's use of its metallic/roughness texture. If no texture is
   * attached, {@link TextureInfo} is `null`.
   */
  getMetallicRoughnessTextureInfo() {
    return this.getRef('metallicRoughnessTexture') ? this.getRef('metallicRoughnessTextureInfo') : null;
  }
  /**
   * Sets metallic/roughness texture.
   * See {@link Material.getMetallicRoughnessTexture getMetallicRoughnessTexture}.
   */
  setMetallicRoughnessTexture(texture) {
    return this.setRef('metallicRoughnessTexture', texture, {
      channels: G$8 | B$6
    });
  }
}
/**********************************************************************************************
 * Constants.
 */
Material.AlphaMode = {
  /**
   * The alpha value is ignored and the rendered output is fully opaque
   */
  OPAQUE: 'OPAQUE',
  /**
   * The rendered output is either fully opaque or fully transparent depending on the alpha
   * value and the specified alpha cutoff value
   */
  MASK: 'MASK',
  /**
   * The alpha value is used to composite the source and destination areas. The rendered
   * output is combined with the background using the normal painting operation (i.e. the
   * Porter and Duff over operator)
   */
  BLEND: 'BLEND'
};

/**
 * *Meshes define reusable geometry (triangles, lines, or points) and are instantiated by
 * {@link Node}s.*
 *
 * Each draw call required to render a mesh is represented as a {@link Primitive}. Meshes typically
 * have only a single {@link Primitive}, but may have more for various reasons. A mesh manages only
 * a list of primitives — materials, morph targets, and other properties are managed on a per-
 * primitive basis.
 *
 * When the same geometry and material should be rendered at multiple places in the scene, reuse
 * the same Mesh instance and attach it to multiple nodes for better efficiency. Where the geometry
 * is shared but the material is not, reusing {@link Accessor}s under different meshes and
 * primitives can similarly improve transmission efficiency, although some rendering efficiency is
 * lost as the number of materials in a scene increases.
 *
 * Usage:
 *
 * ```ts
 * const primitive = doc.createPrimitive()
 * 	.setAttribute('POSITION', positionAccessor)
 * 	.setAttribute('TEXCOORD_0', uvAccessor);
 * const mesh = doc.createMesh('myMesh')
 * 	.addPrimitive(primitive);
 * node.setMesh(mesh);
 * ```
 *
 * References:
 * - [glTF → Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)
 *
 * @category Properties
 */
class Mesh extends ExtensibleProperty {
  init() {
    this.propertyType = PropertyType.MESH;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      weights: [],
      primitives: new RefSet()
    });
  }
  /** Adds a {@link Primitive} to the mesh's draw call list. */
  addPrimitive(primitive) {
    return this.addRef('primitives', primitive);
  }
  /** Removes a {@link Primitive} from the mesh's draw call list. */
  removePrimitive(primitive) {
    return this.removeRef('primitives', primitive);
  }
  /** Lists {@link Primitive} draw calls of the mesh. */
  listPrimitives() {
    return this.listRefs('primitives');
  }
  /**
   * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must
   * have the same number of targets. Most engines only support 4-8 active morph targets at a
   * time.
   */
  getWeights() {
    return this.get('weights');
  }
  /**
   * Initial weights of each {@link PrimitiveTarget} on this mesh. Each {@link Primitive} must
   * have the same number of targets. Most engines only support 4-8 active morph targets at a
   * time.
   */
  setWeights(weights) {
    return this.set('weights', weights);
  }
}

/**
 * *Nodes are the objects that comprise a {@link Scene}.*
 *
 * Each Node may have one or more children, and a transform (position, rotation, and scale) that
 * applies to all of its descendants. A Node may also reference (or "instantiate") other resources
 * at its location, including {@link Mesh}, Camera, Light, and Skin properties. A Node cannot be
 * part of more than one {@link Scene}.
 *
 * A Node's local transform is represented with array-like objects, intended to be compatible with
 * [gl-matrix](https://github.com/toji/gl-matrix), or with the `toArray`/`fromArray` methods of
 * libraries like three.js and babylon.js.
 *
 * Usage:
 *
 * ```ts
 * const node = doc.createNode('myNode')
 * 	.setMesh(mesh)
 * 	.setTranslation([0, 0, 0])
 * 	.addChild(otherNode);
 * ```
 *
 * References:
 * - [glTF → Nodes and Hierarchy](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#nodes-and-hierarchy)
 *
 * @category Properties
 */
class Node extends ExtensibleProperty {
  init() {
    this.propertyType = PropertyType.NODE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      translation: [0, 0, 0],
      rotation: [0, 0, 0, 1],
      scale: [1, 1, 1],
      weights: [],
      camera: null,
      mesh: null,
      skin: null,
      children: new RefSet()
    });
  }
  copy(other, resolve = COPY_IDENTITY) {
    // Node cannot be copied, only cloned. Copying is shallow, but Nodes cannot have more than
    // one parent. Rather than leaving one of the two Nodes without children, throw an error here.
    if (resolve === COPY_IDENTITY) throw new Error('Node cannot be copied.');
    return super.copy(other, resolve);
  }
  /**********************************************************************************************
   * Local transform.
   */
  /** Returns the translation (position) of this Node in local space. */
  getTranslation() {
    return this.get('translation');
  }
  /** Returns the rotation (quaternion) of this Node in local space. */
  getRotation() {
    return this.get('rotation');
  }
  /** Returns the scale of this Node in local space. */
  getScale() {
    return this.get('scale');
  }
  /** Sets the translation (position) of this Node in local space. */
  setTranslation(translation) {
    return this.set('translation', translation);
  }
  /** Sets the rotation (quaternion) of this Node in local space. */
  setRotation(rotation) {
    return this.set('rotation', rotation);
  }
  /** Sets the scale of this Node in local space. */
  setScale(scale) {
    return this.set('scale', scale);
  }
  /** Returns the local matrix of this Node. */
  getMatrix() {
    return MathUtils.compose(this.get('translation'), this.get('rotation'), this.get('scale'), []);
  }
  /** Sets the local matrix of this Node. Matrix will be decomposed to TRS properties. */
  setMatrix(matrix) {
    const translation = this.get('translation').slice();
    const rotation = this.get('rotation').slice();
    const scale = this.get('scale').slice();
    MathUtils.decompose(matrix, translation, rotation, scale);
    return this.set('translation', translation).set('rotation', rotation).set('scale', scale);
  }
  /**********************************************************************************************
   * World transform.
   */
  /** Returns the translation (position) of this Node in world space. */
  getWorldTranslation() {
    const t = [0, 0, 0];
    MathUtils.decompose(this.getWorldMatrix(), t, [0, 0, 0, 1], [1, 1, 1]);
    return t;
  }
  /** Returns the rotation (quaternion) of this Node in world space. */
  getWorldRotation() {
    const r = [0, 0, 0, 1];
    MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], r, [1, 1, 1]);
    return r;
  }
  /** Returns the scale of this Node in world space. */
  getWorldScale() {
    const s = [1, 1, 1];
    MathUtils.decompose(this.getWorldMatrix(), [0, 0, 0], [0, 0, 0, 1], s);
    return s;
  }
  /** Returns the world matrix of this Node. */
  getWorldMatrix() {
    // Build ancestor chain.
    const ancestors = [];
    for (let node = this; node != null; node = node.getParentNode()) {
      ancestors.push(node);
    }
    // Compute world matrix.
    let ancestor;
    const worldMatrix = ancestors.pop().getMatrix();
    while (ancestor = ancestors.pop()) {
      multiply$1(worldMatrix, worldMatrix, ancestor.getMatrix());
    }
    return worldMatrix;
  }
  /**********************************************************************************************
   * Scene hierarchy.
   */
  /**
   * Adds the given Node as a child of this Node.
   *
   * Requirements:
   *
   * 1. Nodes MAY be root children of multiple {@link Scene Scenes}
   * 2. Nodes MUST NOT be children of >1 Node
   * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}
   *
   * The `addChild` method enforces these restrictions automatically, and will
   * remove the new child from previous parents where needed. This behavior
   * may change in future major releases of the library.
   */
  addChild(child) {
    // Remove existing parents.
    const parentNode = child.getParentNode();
    if (parentNode) parentNode.removeChild(child);
    for (const parent of child.listParents()) {
      if (parent.propertyType === PropertyType.SCENE) {
        parent.removeChild(child);
      }
    }
    return this.addRef('children', child);
  }
  /** Removes a Node from this Node's child Node list. */
  removeChild(child) {
    return this.removeRef('children', child);
  }
  /** Lists all child Nodes of this Node. */
  listChildren() {
    return this.listRefs('children');
  }
  /**
   * Returns the Node's unique parent Node within the scene graph. If the
   * Node has no parents, or is a direct child of the {@link Scene}
   * ("root node"), this method returns null.
   *
   * Unrelated to {@link Property.listParents}, which lists all resource
   * references from properties of any type ({@link Skin}, {@link Root}, ...).
   */
  getParentNode() {
    for (const parent of this.listParents()) {
      if (parent.propertyType === PropertyType.NODE) {
        return parent;
      }
    }
    return null;
  }
  /**********************************************************************************************
   * Attachments.
   */
  /** Returns the {@link Mesh}, if any, instantiated at this Node. */
  getMesh() {
    return this.getRef('mesh');
  }
  /**
   * Sets a {@link Mesh} to be instantiated at this Node. A single mesh may be instatiated by
   * multiple Nodes; reuse of this sort is strongly encouraged.
   */
  setMesh(mesh) {
    return this.setRef('mesh', mesh);
  }
  /** Returns the {@link Camera}, if any, instantiated at this Node. */
  getCamera() {
    return this.getRef('camera');
  }
  /** Sets a {@link Camera} to be instantiated at this Node. */
  setCamera(camera) {
    return this.setRef('camera', camera);
  }
  /** Returns the {@link Skin}, if any, instantiated at this Node. */
  getSkin() {
    return this.getRef('skin');
  }
  /** Sets a {@link Skin} to be instantiated at this Node. */
  setSkin(skin) {
    return this.setRef('skin', skin);
  }
  /**
   * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.
   * Most engines only support 4-8 active morph targets at a time.
   */
  getWeights() {
    return this.get('weights');
  }
  /**
   * Initial weights of each {@link PrimitiveTarget} for the mesh instance at this Node.
   * Most engines only support 4-8 active morph targets at a time.
   */
  setWeights(weights) {
    return this.set('weights', weights);
  }
  /**********************************************************************************************
   * Helpers.
   */
  /** Visits this {@link Node} and its descendants, top-down. */
  traverse(fn) {
    fn(this);
    for (const child of this.listChildren()) child.traverse(fn);
    return this;
  }
}

/**
 * *Primitives are individual GPU draw calls comprising a {@link Mesh}.*
 *
 * Meshes typically have only a single Primitive, although various cases may require more. Each
 * primitive may be assigned vertex attributes, morph target attributes, and a material. Any of
 * these properties should be reused among multiple primitives where feasible.
 *
 * Primitives cannot be moved independently of other primitives within the same mesh, except
 * through the use of morph targets and skinning. If independent movement or other runtime
 * behavior is necessary (like raycasting or collisions) prefer to assign each primitive to a
 * different mesh. The number of GPU draw calls is typically not affected by grouping or
 * ungrouping primitives to a mesh.
 *
 * Each primitive may optionally be deformed by one or more morph targets, stored in a
 * {@link PrimitiveTarget}.
 *
 * Usage:
 *
 * ```ts
 * const primitive = doc.createPrimitive()
 * 	.setAttribute('POSITION', positionAccessor)
 * 	.setAttribute('TEXCOORD_0', uvAccessor)
 * 	.setMaterial(material);
 * mesh.addPrimitive(primitive);
 * node.setMesh(mesh);
 * ```
 *
 * References:
 * - [glTF → Geometry](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#geometry)
 *
 * @category Properties
 */
class Primitive extends ExtensibleProperty {
  /**********************************************************************************************
   * Instance.
   */
  init() {
    this.propertyType = PropertyType.PRIMITIVE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      mode: Primitive.Mode.TRIANGLES,
      material: null,
      indices: null,
      attributes: new RefMap(),
      targets: new RefSet()
    });
  }
  /**********************************************************************************************
   * Primitive data.
   */
  /** Returns an {@link Accessor} with indices of vertices to be drawn. */
  getIndices() {
    return this.getRef('indices');
  }
  /**
   * Sets an {@link Accessor} with indices of vertices to be drawn. In `TRIANGLES` draw mode,
   * each set of three indices define a triangle. The front face has a counter-clockwise (CCW)
   * winding order.
   */
  setIndices(indices) {
    return this.setRef('indices', indices, {
      usage: BufferViewUsage$1.ELEMENT_ARRAY_BUFFER
    });
  }
  /** Returns a vertex attribute as an {@link Accessor}. */
  getAttribute(semantic) {
    return this.getRefMap('attributes', semantic);
  }
  /**
   * Sets a vertex attribute to an {@link Accessor}. All attributes must have the same vertex
   * count.
   */
  setAttribute(semantic, accessor) {
    return this.setRefMap('attributes', semantic, accessor, {
      usage: BufferViewUsage$1.ARRAY_BUFFER
    });
  }
  /**
   * Lists all vertex attribute {@link Accessor}s associated with the primitive, excluding any
   * attributes used for morph targets. For example, `[positionAccessor, normalAccessor,
   * uvAccessor]`. Order will be consistent with the order returned by {@link .listSemantics}().
   */
  listAttributes() {
    return this.listRefMapValues('attributes');
  }
  /**
   * Lists all vertex attribute semantics associated with the primitive, excluding any semantics
   * used for morph targets. For example, `['POSITION', 'NORMAL', 'TEXCOORD_0']`. Order will be
   * consistent with the order returned by {@link .listAttributes}().
   */
  listSemantics() {
    return this.listRefMapKeys('attributes');
  }
  /** Returns the material used to render the primitive. */
  getMaterial() {
    return this.getRef('material');
  }
  /** Sets the material used to render the primitive. */
  setMaterial(material) {
    return this.setRef('material', material);
  }
  /**********************************************************************************************
   * Mode.
   */
  /**
   * Returns the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.
   *
   * Reference:
   * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)
   */
  getMode() {
    return this.get('mode');
  }
  /**
   * Sets the GPU draw mode (`TRIANGLES`, `LINES`, `POINTS`...) as a WebGL enum value.
   *
   * Reference:
   * - [glTF → `primitive.mode`](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#primitivemode)
   */
  setMode(mode) {
    return this.set('mode', mode);
  }
  /**********************************************************************************************
   * Morph targets.
   */
  /** Lists all morph targets associated with the primitive. */
  listTargets() {
    return this.listRefs('targets');
  }
  /**
   * Adds a morph target to the primitive. All primitives in the same mesh must have the same
   * number of targets.
   */
  addTarget(target) {
    return this.addRef('targets', target);
  }
  /**
   * Removes a morph target from the primitive. All primitives in the same mesh must have the same
   * number of targets.
   */
  removeTarget(target) {
    return this.removeRef('targets', target);
  }
}
/**********************************************************************************************
 * Constants.
 */
/** Type of primitives to render. All valid values correspond to WebGL enums. */
Primitive.Mode = {
  /** Draw single points. */
  POINTS: 0,
  /** Draw lines. Each vertex connects to the one after it. */
  LINES: 1,
  /**
   * Draw lines. Each set of two vertices is treated as a separate line segment.
   * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.
   */
  LINE_LOOP: 2,
  /** Draw a connected group of line segments from the first vertex to the last,  */
  LINE_STRIP: 3,
  /** Draw triangles. Each set of three vertices creates a separate triangle. */
  TRIANGLES: 4,
  /** Draw a connected strip of triangles. */
  TRIANGLE_STRIP: 5,
  /**
   * Draw a connected group of triangles. Each vertex connects to the previous and the first
   * vertex in the fan.
   * @deprecated See {@link https://github.com/KhronosGroup/glTF/issues/1883 KhronosGroup/glTF#1883}.
   */
  TRIANGLE_FAN: 6
};

/**
 * *Morph target or shape key used to deform one {@link Primitive} in a {@link Mesh}.*
 *
 * A PrimitiveTarget contains a `POSITION` attribute (and optionally `NORMAL` and `TANGENT`) that
 * can additively deform the base attributes on a {@link Mesh} {@link Primitive}. Vertex values
 * of `0, 0, 0` in the target will have no effect, whereas a value of `0, 1, 0` would offset that
 * vertex in the base geometry by y+=1. Morph targets can be fully or partially applied: their
 * default state is controlled by {@link Mesh.getWeights}, which can also be overridden for a
 * particular instantiation of a {@link Mesh}, using {@link Node.getWeights}.
 *
 * Reference:
 * - [glTF → Morph Targets](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#morph-targets)
 *
 * @category Properties
 */
class PrimitiveTarget extends Property {
  init() {
    this.propertyType = PropertyType.PRIMITIVE_TARGET;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      attributes: new RefMap()
    });
  }
  /** Returns a morph target vertex attribute as an {@link Accessor}. */
  getAttribute(semantic) {
    return this.getRefMap('attributes', semantic);
  }
  /**
   * Sets a morph target vertex attribute to an {@link Accessor}.
   */
  setAttribute(semantic, accessor) {
    return this.setRefMap('attributes', semantic, accessor, {
      usage: BufferViewUsage$1.ARRAY_BUFFER
    });
  }
  /**
   * Lists all morph target vertex attribute {@link Accessor}s associated. Order will be
   * consistent with the order returned by {@link .listSemantics}().
   */
  listAttributes() {
    return this.listRefMapValues('attributes');
  }
  /**
   * Lists all morph target vertex attribute semantics associated. Order will be
   * consistent with the order returned by {@link .listAttributes}().
   */
  listSemantics() {
    return this.listRefMapKeys('attributes');
  }
}

function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$1.apply(null, arguments);
}

/**
 * *Scenes represent a set of visual objects to render.*
 *
 * Typically a glTF file contains only a single Scene, although more are allowed and useful in some
 * cases. No particular meaning is associated with additional Scenes, except as defined by the
 * application. Scenes reference {@link Node}s, and a single Node cannot be a member of more than
 * one Scene.
 *
 * References:
 * - [glTF → Scenes](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#scenes)
 * - [glTF → Coordinate System and Units](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#coordinate-system-and-units)
 *
 * @category Properties
 */
class Scene extends ExtensibleProperty {
  init() {
    this.propertyType = PropertyType.SCENE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      children: new RefSet()
    });
  }
  copy(other, resolve = COPY_IDENTITY) {
    // Scene cannot be copied, only cloned. Copying is shallow, but nodes cannot have more than
    // one parent. Rather than leaving one of the two Scenes without children, throw an error here.
    if (resolve === COPY_IDENTITY) throw new Error('Scene cannot be copied.');
    return super.copy(other, resolve);
  }
  /**
   * Adds a {@link Node} to the Scene.
   *
   * Requirements:
   *
   * 1. Nodes MAY be root children of multiple {@link Scene Scenes}
   * 2. Nodes MUST NOT be children of >1 Node
   * 3. Nodes MUST NOT be children of both Nodes and {@link Scene Scenes}
   *
   * The `addChild` method enforces these restrictions automatically, and will
   * remove the new child from previous parents where needed. This behavior
   * may change in future major releases of the library.
   */
  addChild(node) {
    // Remove existing parent.
    const parentNode = node.getParentNode();
    if (parentNode) parentNode.removeChild(node);
    return this.addRef('children', node);
  }
  /** Removes a {@link Node} from the Scene. */
  removeChild(node) {
    return this.removeRef('children', node);
  }
  /**
   * Lists all direct child {@link Node Nodes} in the Scene. Indirect
   * descendants (children of children) are not returned, but may be
   * reached recursively or with {@link Scene.traverse} instead.
   */
  listChildren() {
    return this.listRefs('children');
  }
  /** Visits each {@link Node} in the Scene, including descendants, top-down. */
  traverse(fn) {
    for (const node of this.listChildren()) node.traverse(fn);
    return this;
  }
}

/**
 * *Collection of {@link Node} joints and inverse bind matrices used with skinned {@link Mesh}
 * instances.*
 *
 * Reference
 * - [glTF → Skins](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#skins)
 *
 * @category Properties
 */
class Skin extends ExtensibleProperty {
  init() {
    this.propertyType = PropertyType.SKIN;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      skeleton: null,
      inverseBindMatrices: null,
      joints: new RefSet()
    });
  }
  /**
   * {@link Node} used as a skeleton root. The node must be the closest common root of the joints
   * hierarchy or a direct or indirect parent node of the closest common root.
   */
  getSkeleton() {
    return this.getRef('skeleton');
  }
  /**
   * {@link Node} used as a skeleton root. The node must be the closest common root of the joints
   * hierarchy or a direct or indirect parent node of the closest common root.
   */
  setSkeleton(skeleton) {
    return this.setRef('skeleton', skeleton);
  }
  /**
   * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is
   * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were
   * pre-applied.
   */
  getInverseBindMatrices() {
    return this.getRef('inverseBindMatrices');
  }
  /**
   * {@link Accessor} containing the floating-point 4x4 inverse-bind matrices. The default is
   * that each matrix is a 4x4 identity matrix, which implies that inverse-bind matrices were
   * pre-applied.
   */
  setInverseBindMatrices(inverseBindMatrices) {
    return this.setRef('inverseBindMatrices', inverseBindMatrices, {
      usage: BufferViewUsage$1.INVERSE_BIND_MATRICES
    });
  }
  /** Adds a joint {@link Node} to this {@link Skin}. */
  addJoint(joint) {
    return this.addRef('joints', joint);
  }
  /** Removes a joint {@link Node} from this {@link Skin}. */
  removeJoint(joint) {
    return this.removeRef('joints', joint);
  }
  /** Lists joints ({@link Node}s used as joints or bones) in this {@link Skin}. */
  listJoints() {
    return this.listRefs('joints');
  }
}

/**
 * *Texture, or images, referenced by {@link Material} properties.*
 *
 * Textures in glTF Transform are a combination of glTF's `texture` and `image` properties, and
 * should be unique within a document, such that no other texture contains the same
 * {@link Texture.getImage getImage()} data. Where duplicates may already exist, the `dedup({textures: true})`
 * transform can remove them. A {@link Document} with N texture properties will be exported to a
 * glTF file with N `image` properties, and the minimum number of `texture` properties necessary
 * for the materials that use it.
 *
 * For properties associated with a particular _use_ of a texture, see {@link TextureInfo}.
 *
 * Reference:
 * - [glTF → Textures](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#textures)
 * - [glTF → Images](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#images)
 *
 * @category Properties
 */
class Texture extends ExtensibleProperty {
  init() {
    this.propertyType = PropertyType.TEXTURE;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      image: null,
      mimeType: '',
      uri: ''
    });
  }
  /**********************************************************************************************
   * MIME type / format.
   */
  /** Returns the MIME type for this texture ('image/jpeg' or 'image/png'). */
  getMimeType() {
    return this.get('mimeType') || ImageUtils.extensionToMimeType(FileUtils.extension(this.get('uri')));
  }
  /**
   * Sets the MIME type for this texture ('image/jpeg' or 'image/png'). If the texture does not
   * have a URI, a MIME type is required for correct export.
   */
  setMimeType(mimeType) {
    return this.set('mimeType', mimeType);
  }
  /**********************************************************************************************
   * URI / filename.
   */
  /** Returns the URI (e.g. 'path/to/file.png') for this texture. */
  getURI() {
    return this.get('uri');
  }
  /**
   * Sets the URI (e.g. 'path/to/file.png') for this texture. If the texture does not have a MIME
   * type, a URI is required for correct export.
   */
  setURI(uri) {
    this.set('uri', uri);
    const mimeType = ImageUtils.extensionToMimeType(FileUtils.extension(uri));
    if (mimeType) this.set('mimeType', mimeType);
    return this;
  }
  /**********************************************************************************************
   * Image data.
   */
  /** Returns the raw image data for this texture. */
  getImage() {
    return this.get('image');
  }
  /** Sets the raw image data for this texture. */
  setImage(image) {
    return this.set('image', BufferUtils.assertView(image));
  }
  /** Returns the size, in pixels, of this texture. */
  getSize() {
    const image = this.get('image');
    if (!image) return null;
    return ImageUtils.getSize(image, this.getMimeType());
  }
}

/**
 * *Root property of a glTF asset.*
 *
 * Any properties to be exported with a particular asset must be referenced (directly or
 * indirectly) by the root. Metadata about the asset's license, generator, and glTF specification
 * version are stored in the asset, accessible with {@link Root.getAsset}.
 *
 * Properties are added to the root with factory methods on its {@link Document}, and removed by
 * calling {@link Property.dispose}() on the resource. Any properties that have been created but
 * not disposed will be included when calling the various `root.list*()` methods.
 *
 * A document's root cannot be removed, and no other root may be created. Unlike other
 * {@link Property} types, the `.dispose()`, `.detach()` methods have no useful function on a
 * Root property.
 *
 * Usage:
 *
 * ```ts
 * const root = document.getRoot();
 * const scene = document.createScene('myScene');
 * const node = document.createNode('myNode');
 * scene.addChild(node);
 *
 * console.log(root.listScenes()); // → [scene x 1]
 * ```
 *
 * Reference: [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)
 *
 * @category Properties
 */
class Root extends ExtensibleProperty {
  init() {
    this.propertyType = PropertyType.ROOT;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      asset: {
        generator: `glTF-Transform ${VERSION}`,
        version: '2.0'
      },
      defaultScene: null,
      accessors: new RefSet(),
      animations: new RefSet(),
      buffers: new RefSet(),
      cameras: new RefSet(),
      materials: new RefSet(),
      meshes: new RefSet(),
      nodes: new RefSet(),
      scenes: new RefSet(),
      skins: new RefSet(),
      textures: new RefSet()
    });
  }
  /** @internal */
  constructor(graph) {
    super(graph);
    this._extensions = new Set();
    graph.addEventListener('node:create', event => {
      this._addChildOfRoot(event.target);
    });
  }
  clone() {
    throw new Error('Root cannot be cloned.');
  }
  copy(other, resolve = COPY_IDENTITY) {
    // Root cannot be cloned in isolation: only with its Document. Extensions are managed by
    // the Document during cloning. The Root, and only the Root, should keep existing
    // references while copying to avoid overwriting during a merge.
    if (resolve === COPY_IDENTITY) throw new Error('Root cannot be copied.');
    // IMPORTANT: Root cannot call super.copy(), which removes existing references.
    this.set('asset', _extends$1({}, other.get('asset')));
    this.setName(other.getName());
    this.setExtras(_extends$1({}, other.getExtras()));
    this.setDefaultScene(other.getDefaultScene() ? resolve(other.getDefaultScene()) : null);
    for (const extensionName of other.listRefMapKeys('extensions')) {
      const otherExtension = other.getExtension(extensionName);
      this.setExtension(extensionName, resolve(otherExtension));
    }
    return this;
  }
  _addChildOfRoot(child) {
    if (child instanceof Scene) {
      this.addRef('scenes', child);
    } else if (child instanceof Node) {
      this.addRef('nodes', child);
    } else if (child instanceof Camera) {
      this.addRef('cameras', child);
    } else if (child instanceof Skin) {
      this.addRef('skins', child);
    } else if (child instanceof Mesh) {
      this.addRef('meshes', child);
    } else if (child instanceof Material) {
      this.addRef('materials', child);
    } else if (child instanceof Texture) {
      this.addRef('textures', child);
    } else if (child instanceof Animation) {
      this.addRef('animations', child);
    } else if (child instanceof Accessor) {
      this.addRef('accessors', child);
    } else if (child instanceof Buffer$1) {
      this.addRef('buffers', child);
    }
    // No error for untracked property types.
    return this;
  }
  /**
   * Returns the `asset` object, which specifies the target glTF version of the asset. Additional
   * metadata can be stored in optional properties such as `generator` or `copyright`.
   *
   * Reference: [glTF → Asset](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#asset)
   */
  getAsset() {
    return this.get('asset');
  }
  /**********************************************************************************************
   * Extensions.
   */
  /** Lists all {@link Extension Extensions} enabled for this root. */
  listExtensionsUsed() {
    return Array.from(this._extensions);
  }
  /** Lists all {@link Extension Extensions} enabled and required for this root. */
  listExtensionsRequired() {
    return this.listExtensionsUsed().filter(extension => extension.isRequired());
  }
  /** @internal */
  _enableExtension(extension) {
    this._extensions.add(extension);
    return this;
  }
  /** @internal */
  _disableExtension(extension) {
    this._extensions.delete(extension);
    return this;
  }
  /**********************************************************************************************
   * Properties.
   */
  /** Lists all {@link Scene} properties associated with this root. */
  listScenes() {
    return this.listRefs('scenes');
  }
  /** Default {@link Scene} associated with this root. */
  setDefaultScene(defaultScene) {
    return this.setRef('defaultScene', defaultScene);
  }
  /** Default {@link Scene} associated with this root. */
  getDefaultScene() {
    return this.getRef('defaultScene');
  }
  /** Lists all {@link Node} properties associated with this root. */
  listNodes() {
    return this.listRefs('nodes');
  }
  /** Lists all {@link Camera} properties associated with this root. */
  listCameras() {
    return this.listRefs('cameras');
  }
  /** Lists all {@link Skin} properties associated with this root. */
  listSkins() {
    return this.listRefs('skins');
  }
  /** Lists all {@link Mesh} properties associated with this root. */
  listMeshes() {
    return this.listRefs('meshes');
  }
  /** Lists all {@link Material} properties associated with this root. */
  listMaterials() {
    return this.listRefs('materials');
  }
  /** Lists all {@link Texture} properties associated with this root. */
  listTextures() {
    return this.listRefs('textures');
  }
  /** Lists all {@link Animation} properties associated with this root. */
  listAnimations() {
    return this.listRefs('animations');
  }
  /** Lists all {@link Accessor} properties associated with this root. */
  listAccessors() {
    return this.listRefs('accessors');
  }
  /** Lists all {@link Buffer} properties associated with this root. */
  listBuffers() {
    return this.listRefs('buffers');
  }
}

/**
 * *Wraps a glTF asset and its resources for easier modification.*
 *
 * Documents manage glTF assets and the relationships among dependencies. The document wrapper
 * allow tools to read and write changes without dealing with array indices or byte offsets, which
 * would otherwise require careful management over the course of a file modification. An internal
 * graph structure allows any property in the glTF file to maintain references to its dependencies,
 * and makes it easy to determine where a particular property dependency is being used. For
 * example, finding a list of materials that use a particular texture is as simple as calling
 * {@link Texture.listParents}().
 *
 * A new resource {@link Property} (e.g. a {@link Mesh} or {@link Material}) is created by calling
 * 'create' methods on the document. Resources are destroyed by calling {@link Property.dispose}().
 *
 * ```ts
 * import fs from 'fs/promises';
 * import { Document } from '@gltf-transform/core';
 * import { dedup } from '@gltf-transform/functions';
 *
 * const document = new Document();
 *
 * const texture1 = document.createTexture('myTexture')
 * 	.setImage(await fs.readFile('path/to/image.png'))
 * 	.setMimeType('image/png');
 * const texture2 = document.createTexture('myTexture2')
 * 	.setImage(await fs.readFile('path/to/image2.png'))
 * 	.setMimeType('image/png');
 *
 * // Document containing duplicate copies of the same texture.
 * document.getRoot().listTextures(); // → [texture x 2]
 *
 * await document.transform(
 * 	dedup({textures: true}),
 * 	// ...
 * );
 *
 * // Document with duplicate textures removed.
 * document.getRoot().listTextures(); // → [texture x 1]
 * ```
 *
 * Reference:
 * - [glTF → Basics](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#gltf-basics)
 * - [glTF → Concepts](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#concepts)
 *
 * @category Documents
 */
class Document {
  /**
   * Returns the Document associated with a given Graph, if any.
   * @hidden
   * @experimental
   */
  static fromGraph(graph) {
    return Document._GRAPH_DOCUMENTS.get(graph) || null;
  }
  /** Creates a new Document, representing an empty glTF asset. */
  constructor() {
    this._graph = new Graph();
    this._root = new Root(this._graph);
    this._logger = Logger.DEFAULT_INSTANCE;
    Document._GRAPH_DOCUMENTS.set(this._graph, this);
  }
  /** Returns the glTF {@link Root} property. */
  getRoot() {
    return this._root;
  }
  /**
   * Returns the {@link Graph} representing connectivity of resources within this document.
   * @hidden
   */
  getGraph() {
    return this._graph;
  }
  /** Returns the {@link Logger} instance used for any operations performed on this document. */
  getLogger() {
    return this._logger;
  }
  /**
   * Overrides the {@link Logger} instance used for any operations performed on this document.
   *
   * Usage:
   *
   * ```ts
   * doc
   * 	.setLogger(new Logger(Logger.Verbosity.SILENT))
   * 	.transform(dedup(), weld());
   * ```
   */
  setLogger(logger) {
    this._logger = logger;
    return this;
  }
  /**
   * Clones this Document, copying all resources within it.
   * @deprecated Use 'cloneDocument(document)' from '@gltf-transform/functions'.
   * @hidden
   * @internal
   */
  clone() {
    throw new Error(`Use 'cloneDocument(source)' from '@gltf-transform/functions'.`);
  }
  /**
   * Merges the content of another Document into this one, without affecting the original.
   * @deprecated Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.
   * @hidden
   * @internal
   */
  merge(_other) {
    throw new Error(`Use 'mergeDocuments(target, source)' from '@gltf-transform/functions'.`);
  }
  /**
   * Applies a series of modifications to this document. Each transformation is asynchronous,
   * takes the {@link Document} as input, and returns nothing. Transforms are applied in the
   * order given, which may affect the final result.
   *
   * Usage:
   *
   * ```ts
   * await doc.transform(
   * 	dedup(),
   * 	prune()
   * );
   * ```
   *
   * @param transforms List of synchronous transformation functions to apply.
   */
  async transform(...transforms) {
    const stack = transforms.map(fn => fn.name);
    for (const transform of transforms) {
      await transform(this, {
        stack
      });
    }
    return this;
  }
  /**********************************************************************************************
   * Extension factory method.
   */
  /**
   * Creates a new {@link Extension}, for the extension type of the given constructor. If the
   * extension is already enabled for this Document, the previous Extension reference is reused.
   */
  createExtension(ctor) {
    const extensionName = ctor.EXTENSION_NAME;
    const prevExtension = this.getRoot().listExtensionsUsed().find(ext => ext.extensionName === extensionName);
    return prevExtension || new ctor(this);
  }
  /**********************************************************************************************
   * Property factory methods.
   */
  /** Creates a new {@link Scene} attached to this document's {@link Root}. */
  createScene(name = '') {
    return new Scene(this._graph, name);
  }
  /** Creates a new {@link Node} attached to this document's {@link Root}. */
  createNode(name = '') {
    return new Node(this._graph, name);
  }
  /** Creates a new {@link Camera} attached to this document's {@link Root}. */
  createCamera(name = '') {
    return new Camera(this._graph, name);
  }
  /** Creates a new {@link Skin} attached to this document's {@link Root}. */
  createSkin(name = '') {
    return new Skin(this._graph, name);
  }
  /** Creates a new {@link Mesh} attached to this document's {@link Root}. */
  createMesh(name = '') {
    return new Mesh(this._graph, name);
  }
  /**
   * Creates a new {@link Primitive}. Primitives must be attached to a {@link Mesh}
   * for use and export; they are not otherwise associated with a {@link Root}.
   */
  createPrimitive() {
    return new Primitive(this._graph);
  }
  /**
   * Creates a new {@link PrimitiveTarget}, or morph target. Targets must be attached to a
   * {@link Primitive} for use and export; they are not otherwise associated with a {@link Root}.
   */
  createPrimitiveTarget(name = '') {
    return new PrimitiveTarget(this._graph, name);
  }
  /** Creates a new {@link Material} attached to this document's {@link Root}. */
  createMaterial(name = '') {
    return new Material(this._graph, name);
  }
  /** Creates a new {@link Texture} attached to this document's {@link Root}. */
  createTexture(name = '') {
    return new Texture(this._graph, name);
  }
  /** Creates a new {@link Animation} attached to this document's {@link Root}. */
  createAnimation(name = '') {
    return new Animation(this._graph, name);
  }
  /**
   * Creates a new {@link AnimationChannel}. Channels must be attached to an {@link Animation}
   * for use and export; they are not otherwise associated with a {@link Root}.
   */
  createAnimationChannel(name = '') {
    return new AnimationChannel(this._graph, name);
  }
  /**
   * Creates a new {@link AnimationSampler}. Samplers must be attached to an {@link Animation}
   * for use and export; they are not otherwise associated with a {@link Root}.
   */
  createAnimationSampler(name = '') {
    return new AnimationSampler(this._graph, name);
  }
  /** Creates a new {@link Accessor} attached to this document's {@link Root}. */
  createAccessor(name = '', buffer = null) {
    if (!buffer) {
      buffer = this.getRoot().listBuffers()[0];
    }
    return new Accessor(this._graph, name).setBuffer(buffer);
  }
  /** Creates a new {@link Buffer} attached to this document's {@link Root}. */
  createBuffer(name = '') {
    return new Buffer$1(this._graph, name);
  }
}
/**
 * Enables lookup of a Document from its Graph. For internal use, only.
 * @internal
 * @experimental
 */
Document._GRAPH_DOCUMENTS = new WeakMap();

/**
 * *Base class for all Extensions.*
 *
 * Extensions enhance a glTF {@link Document} with additional features and schema, beyond the core
 * glTF specification. Common extensions may be imported from the `@gltf-transform/extensions`
 * package, or custom extensions may be created by extending this base class.
 *
 * An extension is added to a Document by calling {@link Document.createExtension} with the
 * extension constructor. The extension object may then be used to construct
 * {@link ExtensionProperty} instances, which are attached to properties throughout the Document
 * as prescribed by the extension itself.
 *
 * For more information on available extensions and their usage, see [Extensions](/extensions).
 *
 * Reference:
 * - [glTF → Extensions](https://github.com/KhronosGroup/gltf/blob/main/specification/2.0/README.md#specifying-extensions)
 * - [glTF Extension Registry](https://github.com/KhronosGroup/gltf/blob/main/extensions)
 *
 * @category Extensions
 */
class Extension {
  /** @hidden */
  constructor(document) {
    /** Official name of the extension. */
    this.extensionName = '';
    /**
     * Before reading, extension should be called for these {@link Property} types. *Most
     * extensions don't need to implement this.*
     * @hidden
     */
    this.prereadTypes = [];
    /**
     * Before writing, extension should be called for these {@link Property} types. *Most
     * extensions don't need to implement this.*
     * @hidden
     */
    this.prewriteTypes = [];
    /** @hidden Dependency IDs needed to read this extension, to be installed before I/O. */
    this.readDependencies = [];
    /** @hidden Dependency IDs needed to write this extension, to be installed before I/O. */
    this.writeDependencies = [];
    /** @hidden */
    this.document = void 0;
    /** @hidden */
    this.required = false;
    /** @hidden */
    this.properties = new Set();
    /** @hidden */
    this._listener = void 0;
    this.document = document;
    document.getRoot()._enableExtension(this);
    this._listener = _event => {
      const event = _event;
      const target = event.target;
      if (target instanceof ExtensionProperty && target.extensionName === this.extensionName) {
        if (event.type === 'node:create') this._addExtensionProperty(target);
        if (event.type === 'node:dispose') this._removeExtensionProperty(target);
      }
    };
    const graph = document.getGraph();
    graph.addEventListener('node:create', this._listener);
    graph.addEventListener('node:dispose', this._listener);
  }
  /** Disables and removes the extension from the Document. */
  dispose() {
    this.document.getRoot()._disableExtension(this);
    const graph = this.document.getGraph();
    graph.removeEventListener('node:create', this._listener);
    graph.removeEventListener('node:dispose', this._listener);
    for (const property of this.properties) {
      property.dispose();
    }
  }
  /** @hidden Performs first-time setup for the extension. Must be idempotent. */
  static register() {}
  /**
   * Indicates to the client whether it is OK to load the asset when this extension is not
   * recognized. Optional extensions are generally preferred, if there is not a good reason
   * to require a client to completely fail when an extension isn't known.
   */
  isRequired() {
    return this.required;
  }
  /**
   * Indicates to the client whether it is OK to load the asset when this extension is not
   * recognized. Optional extensions are generally preferred, if there is not a good reason
   * to require a client to completely fail when an extension isn't known.
   */
  setRequired(required) {
    this.required = required;
    return this;
  }
  /**
   * Lists all {@link ExtensionProperty} instances associated with, or created by, this
   * extension. Includes only instances that are attached to the Document's graph; detached
   * instances will be excluded.
   */
  listProperties() {
    return Array.from(this.properties);
  }
  /**********************************************************************************************
   * ExtensionProperty management.
   */
  /** @internal */
  _addExtensionProperty(property) {
    this.properties.add(property);
    return this;
  }
  /** @internal */
  _removeExtensionProperty(property) {
    this.properties.delete(property);
    return this;
  }
  /**********************************************************************************************
   * I/O implementation.
   */
  /** @hidden Installs dependencies required by the extension. */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  install(key, dependency) {
    return this;
  }
  /**
   * Used by the {@link PlatformIO} utilities when reading a glTF asset. This method may
   * optionally be implemented by an extension, and should then support any property type
   * declared by the Extension's {@link Extension.prereadTypes} list. The Extension will
   * be given a ReaderContext instance, and is expected to update either the context or its
   * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to
   * implement this.*
   * @hidden
   */
  preread(_readerContext, _propertyType) {
    return this;
  }
  /**
   * Used by the {@link PlatformIO} utilities when writing a glTF asset. This method may
   * optionally be implemented by an extension, and should then support any property type
   * declared by the Extension's {@link Extension.prewriteTypes} list. The Extension will
   * be given a WriterContext instance, and is expected to update either the context or its
   * {@link JSONDocument} with resources known to the Extension. *Most extensions don't need to
   * implement this.*
   * @hidden
   */
  prewrite(_writerContext, _propertyType) {
    return this;
  }
}
/** Official name of the extension. */
Extension.EXTENSION_NAME = void 0;

/**
 * Model class providing glTF Transform objects representing each definition in the glTF file, used
 * by a {@link GLTFReader} and its {@link Extension} implementations. Indices of all properties will be
 * consistent with the glTF file.
 *
 * @hidden
 */
class ReaderContext {
  constructor(jsonDoc) {
    this.jsonDoc = void 0;
    this.buffers = [];
    this.bufferViews = [];
    this.bufferViewBuffers = [];
    this.accessors = [];
    this.textures = [];
    this.textureInfos = new Map();
    this.materials = [];
    this.meshes = [];
    this.cameras = [];
    this.nodes = [];
    this.skins = [];
    this.animations = [];
    this.scenes = [];
    this.jsonDoc = jsonDoc;
  }
  setTextureInfo(textureInfo, textureInfoDef) {
    this.textureInfos.set(textureInfo, textureInfoDef);
    if (textureInfoDef.texCoord !== undefined) {
      textureInfo.setTexCoord(textureInfoDef.texCoord);
    }
    if (textureInfoDef.extras !== undefined) {
      textureInfo.setExtras(textureInfoDef.extras);
    }
    const textureDef = this.jsonDoc.json.textures[textureInfoDef.index];
    if (textureDef.sampler === undefined) return;
    const samplerDef = this.jsonDoc.json.samplers[textureDef.sampler];
    if (samplerDef.magFilter !== undefined) {
      textureInfo.setMagFilter(samplerDef.magFilter);
    }
    if (samplerDef.minFilter !== undefined) {
      textureInfo.setMinFilter(samplerDef.minFilter);
    }
    if (samplerDef.wrapS !== undefined) {
      textureInfo.setWrapS(samplerDef.wrapS);
    }
    if (samplerDef.wrapT !== undefined) {
      textureInfo.setWrapT(samplerDef.wrapT);
    }
  }
}

const DEFAULT_OPTIONS = {
  logger: Logger.DEFAULT_INSTANCE,
  extensions: [],
  dependencies: {}
};
const SUPPORTED_PREREAD_TYPES = new Set([PropertyType.BUFFER, PropertyType.TEXTURE, PropertyType.MATERIAL, PropertyType.MESH, PropertyType.PRIMITIVE, PropertyType.NODE, PropertyType.SCENE]);
/** @internal */
class GLTFReader {
  static read(jsonDoc, _options = DEFAULT_OPTIONS) {
    const options = _extends$1({}, DEFAULT_OPTIONS, _options);
    const {
      json
    } = jsonDoc;
    const document = new Document().setLogger(options.logger);
    this.validate(jsonDoc, options);
    /* Reader context. */
    const context = new ReaderContext(jsonDoc);
    /** Asset. */
    const assetDef = json.asset;
    const asset = document.getRoot().getAsset();
    if (assetDef.copyright) asset.copyright = assetDef.copyright;
    if (assetDef.extras) asset.extras = assetDef.extras;
    if (json.extras !== undefined) {
      document.getRoot().setExtras(_extends$1({}, json.extras));
    }
    /** Extensions (1/2). */
    const extensionsUsed = json.extensionsUsed || [];
    const extensionsRequired = json.extensionsRequired || [];
    options.extensions.sort((a, b) => a.EXTENSION_NAME > b.EXTENSION_NAME ? 1 : -1);
    for (const Extension of options.extensions) {
      if (extensionsUsed.includes(Extension.EXTENSION_NAME)) {
        // Create extension.
        const extension = document.createExtension(Extension).setRequired(extensionsRequired.includes(Extension.EXTENSION_NAME));
        // Warn on unsupported preread hooks.
        const unsupportedHooks = extension.prereadTypes.filter(type => !SUPPORTED_PREREAD_TYPES.has(type));
        if (unsupportedHooks.length) {
          options.logger.warn(`Preread hooks for some types (${unsupportedHooks.join()}), requested by extension ` + `${extension.extensionName}, are unsupported. Please file an issue or a PR.`);
        }
        // Install dependencies.
        for (const key of extension.readDependencies) {
          extension.install(key, options.dependencies[key]);
        }
      }
    }
    /** Buffers. */
    const bufferDefs = json.buffers || [];
    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.BUFFER)).forEach(extension => extension.preread(context, PropertyType.BUFFER));
    context.buffers = bufferDefs.map(bufferDef => {
      const buffer = document.createBuffer(bufferDef.name);
      if (bufferDef.extras) buffer.setExtras(bufferDef.extras);
      if (bufferDef.uri && bufferDef.uri.indexOf('__') !== 0) {
        buffer.setURI(bufferDef.uri);
      }
      return buffer;
    });
    /** Buffer views. */
    const bufferViewDefs = json.bufferViews || [];
    context.bufferViewBuffers = bufferViewDefs.map((bufferViewDef, index) => {
      if (!context.bufferViews[index]) {
        const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];
        const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];
        const byteOffset = bufferViewDef.byteOffset || 0;
        context.bufferViews[index] = BufferUtils.toView(resource, byteOffset, bufferViewDef.byteLength);
      }
      return context.buffers[bufferViewDef.buffer];
    });
    /** Accessors. */
    // Accessor .count and .componentType properties are inferred dynamically.
    const accessorDefs = json.accessors || [];
    context.accessors = accessorDefs.map(accessorDef => {
      const buffer = context.bufferViewBuffers[accessorDef.bufferView];
      const accessor = document.createAccessor(accessorDef.name, buffer).setType(accessorDef.type);
      if (accessorDef.extras) accessor.setExtras(accessorDef.extras);
      if (accessorDef.normalized !== undefined) {
        accessor.setNormalized(accessorDef.normalized);
      }
      // Sparse accessors, KHR_draco_mesh_compression, and EXT_meshopt_compression.
      if (accessorDef.bufferView === undefined) return accessor;
      // NOTICE: We mark sparse accessors at the end of the I/O reading process. Consider an
      // accessor to be 'sparse' if it (A) includes sparse value overrides, or (B) does not
      // define .bufferView _and_ no extension provides that data.
      accessor.setArray(getAccessorArray(accessorDef, context));
      return accessor;
    });
    /** Textures. */
    // glTF Transform's "Texture" properties correspond 1:1 with glTF "Image" properties, and
    // with image files. The glTF file may contain more one texture per image, where images
    // are reused with different sampler properties.
    const imageDefs = json.images || [];
    const textureDefs = json.textures || [];
    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.TEXTURE)).forEach(extension => extension.preread(context, PropertyType.TEXTURE));
    context.textures = imageDefs.map(imageDef => {
      const texture = document.createTexture(imageDef.name);
      // glTF Image corresponds 1:1 with glTF Transform Texture. See `writer.ts`.
      if (imageDef.extras) texture.setExtras(imageDef.extras);
      if (imageDef.bufferView !== undefined) {
        const bufferViewDef = json.bufferViews[imageDef.bufferView];
        const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];
        const bufferData = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];
        const byteOffset = bufferViewDef.byteOffset || 0;
        const byteLength = bufferViewDef.byteLength;
        const imageData = bufferData.slice(byteOffset, byteOffset + byteLength);
        texture.setImage(imageData);
      } else if (imageDef.uri !== undefined) {
        texture.setImage(jsonDoc.resources[imageDef.uri]);
        if (imageDef.uri.indexOf('__') !== 0) {
          texture.setURI(imageDef.uri);
        }
      }
      if (imageDef.mimeType !== undefined) {
        texture.setMimeType(imageDef.mimeType);
      } else if (imageDef.uri) {
        const extension = FileUtils.extension(imageDef.uri);
        texture.setMimeType(ImageUtils.extensionToMimeType(extension));
      }
      return texture;
    });
    /** Materials. */
    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.MATERIAL)).forEach(extension => extension.preread(context, PropertyType.MATERIAL));
    const materialDefs = json.materials || [];
    context.materials = materialDefs.map(materialDef => {
      const material = document.createMaterial(materialDef.name);
      if (materialDef.extras) material.setExtras(materialDef.extras);
      // Program state & blending.
      if (materialDef.alphaMode !== undefined) {
        material.setAlphaMode(materialDef.alphaMode);
      }
      if (materialDef.alphaCutoff !== undefined) {
        material.setAlphaCutoff(materialDef.alphaCutoff);
      }
      if (materialDef.doubleSided !== undefined) {
        material.setDoubleSided(materialDef.doubleSided);
      }
      // Factors.
      const pbrDef = materialDef.pbrMetallicRoughness || {};
      if (pbrDef.baseColorFactor !== undefined) {
        material.setBaseColorFactor(pbrDef.baseColorFactor);
      }
      if (materialDef.emissiveFactor !== undefined) {
        material.setEmissiveFactor(materialDef.emissiveFactor);
      }
      if (pbrDef.metallicFactor !== undefined) {
        material.setMetallicFactor(pbrDef.metallicFactor);
      }
      if (pbrDef.roughnessFactor !== undefined) {
        material.setRoughnessFactor(pbrDef.roughnessFactor);
      }
      // Textures.
      if (pbrDef.baseColorTexture !== undefined) {
        const textureInfoDef = pbrDef.baseColorTexture;
        const texture = context.textures[textureDefs[textureInfoDef.index].source];
        material.setBaseColorTexture(texture);
        context.setTextureInfo(material.getBaseColorTextureInfo(), textureInfoDef);
      }
      if (materialDef.emissiveTexture !== undefined) {
        const textureInfoDef = materialDef.emissiveTexture;
        const texture = context.textures[textureDefs[textureInfoDef.index].source];
        material.setEmissiveTexture(texture);
        context.setTextureInfo(material.getEmissiveTextureInfo(), textureInfoDef);
      }
      if (materialDef.normalTexture !== undefined) {
        const textureInfoDef = materialDef.normalTexture;
        const texture = context.textures[textureDefs[textureInfoDef.index].source];
        material.setNormalTexture(texture);
        context.setTextureInfo(material.getNormalTextureInfo(), textureInfoDef);
        if (materialDef.normalTexture.scale !== undefined) {
          material.setNormalScale(materialDef.normalTexture.scale);
        }
      }
      if (materialDef.occlusionTexture !== undefined) {
        const textureInfoDef = materialDef.occlusionTexture;
        const texture = context.textures[textureDefs[textureInfoDef.index].source];
        material.setOcclusionTexture(texture);
        context.setTextureInfo(material.getOcclusionTextureInfo(), textureInfoDef);
        if (materialDef.occlusionTexture.strength !== undefined) {
          material.setOcclusionStrength(materialDef.occlusionTexture.strength);
        }
      }
      if (pbrDef.metallicRoughnessTexture !== undefined) {
        const textureInfoDef = pbrDef.metallicRoughnessTexture;
        const texture = context.textures[textureDefs[textureInfoDef.index].source];
        material.setMetallicRoughnessTexture(texture);
        context.setTextureInfo(material.getMetallicRoughnessTextureInfo(), textureInfoDef);
      }
      return material;
    });
    /** Meshes. */
    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.MESH)).forEach(extension => extension.preread(context, PropertyType.MESH));
    const meshDefs = json.meshes || [];
    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.PRIMITIVE)).forEach(extension => extension.preread(context, PropertyType.PRIMITIVE));
    context.meshes = meshDefs.map(meshDef => {
      const mesh = document.createMesh(meshDef.name);
      if (meshDef.extras) mesh.setExtras(meshDef.extras);
      if (meshDef.weights !== undefined) {
        mesh.setWeights(meshDef.weights);
      }
      const primitiveDefs = meshDef.primitives || [];
      primitiveDefs.forEach(primitiveDef => {
        const primitive = document.createPrimitive();
        if (primitiveDef.extras) primitive.setExtras(primitiveDef.extras);
        if (primitiveDef.material !== undefined) {
          primitive.setMaterial(context.materials[primitiveDef.material]);
        }
        if (primitiveDef.mode !== undefined) {
          primitive.setMode(primitiveDef.mode);
        }
        for (const [semantic, index] of Object.entries(primitiveDef.attributes || {})) {
          primitive.setAttribute(semantic, context.accessors[index]);
        }
        if (primitiveDef.indices !== undefined) {
          primitive.setIndices(context.accessors[primitiveDef.indices]);
        }
        const targetNames = meshDef.extras && meshDef.extras.targetNames || [];
        const targetDefs = primitiveDef.targets || [];
        targetDefs.forEach((targetDef, targetIndex) => {
          const targetName = targetNames[targetIndex] || targetIndex.toString();
          const target = document.createPrimitiveTarget(targetName);
          for (const [semantic, accessorIndex] of Object.entries(targetDef)) {
            target.setAttribute(semantic, context.accessors[accessorIndex]);
          }
          primitive.addTarget(target);
        });
        mesh.addPrimitive(primitive);
      });
      return mesh;
    });
    /** Cameras. */
    const cameraDefs = json.cameras || [];
    context.cameras = cameraDefs.map(cameraDef => {
      const camera = document.createCamera(cameraDef.name).setType(cameraDef.type);
      if (cameraDef.extras) camera.setExtras(cameraDef.extras);
      if (cameraDef.type === Camera.Type.PERSPECTIVE) {
        const perspectiveDef = cameraDef.perspective;
        camera.setYFov(perspectiveDef.yfov);
        camera.setZNear(perspectiveDef.znear);
        if (perspectiveDef.zfar !== undefined) {
          camera.setZFar(perspectiveDef.zfar);
        }
        if (perspectiveDef.aspectRatio !== undefined) {
          camera.setAspectRatio(perspectiveDef.aspectRatio);
        }
      } else {
        const orthoDef = cameraDef.orthographic;
        camera.setZNear(orthoDef.znear).setZFar(orthoDef.zfar).setXMag(orthoDef.xmag).setYMag(orthoDef.ymag);
      }
      return camera;
    });
    /** Nodes. */
    const nodeDefs = json.nodes || [];
    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.NODE)).forEach(extension => extension.preread(context, PropertyType.NODE));
    context.nodes = nodeDefs.map(nodeDef => {
      const node = document.createNode(nodeDef.name);
      if (nodeDef.extras) node.setExtras(nodeDef.extras);
      if (nodeDef.translation !== undefined) {
        node.setTranslation(nodeDef.translation);
      }
      if (nodeDef.rotation !== undefined) {
        node.setRotation(nodeDef.rotation);
      }
      if (nodeDef.scale !== undefined) {
        node.setScale(nodeDef.scale);
      }
      if (nodeDef.matrix !== undefined) {
        const translation = [0, 0, 0];
        const rotation = [0, 0, 0, 1];
        const scale = [1, 1, 1];
        MathUtils.decompose(nodeDef.matrix, translation, rotation, scale);
        node.setTranslation(translation);
        node.setRotation(rotation);
        node.setScale(scale);
      }
      if (nodeDef.weights !== undefined) {
        node.setWeights(nodeDef.weights);
      }
      // Attachments (mesh, camera, skin) defined later in reading process.
      return node;
    });
    /** Skins. */
    const skinDefs = json.skins || [];
    context.skins = skinDefs.map(skinDef => {
      const skin = document.createSkin(skinDef.name);
      if (skinDef.extras) skin.setExtras(skinDef.extras);
      if (skinDef.inverseBindMatrices !== undefined) {
        skin.setInverseBindMatrices(context.accessors[skinDef.inverseBindMatrices]);
      }
      if (skinDef.skeleton !== undefined) {
        skin.setSkeleton(context.nodes[skinDef.skeleton]);
      }
      for (const nodeIndex of skinDef.joints) {
        skin.addJoint(context.nodes[nodeIndex]);
      }
      return skin;
    });
    /** Node attachments. */
    nodeDefs.map((nodeDef, nodeIndex) => {
      const node = context.nodes[nodeIndex];
      const children = nodeDef.children || [];
      children.forEach(childIndex => node.addChild(context.nodes[childIndex]));
      if (nodeDef.mesh !== undefined) node.setMesh(context.meshes[nodeDef.mesh]);
      if (nodeDef.camera !== undefined) node.setCamera(context.cameras[nodeDef.camera]);
      if (nodeDef.skin !== undefined) node.setSkin(context.skins[nodeDef.skin]);
    });
    /** Animations. */
    const animationDefs = json.animations || [];
    context.animations = animationDefs.map(animationDef => {
      const animation = document.createAnimation(animationDef.name);
      if (animationDef.extras) animation.setExtras(animationDef.extras);
      const samplerDefs = animationDef.samplers || [];
      const samplers = samplerDefs.map(samplerDef => {
        const sampler = document.createAnimationSampler().setInput(context.accessors[samplerDef.input]).setOutput(context.accessors[samplerDef.output]).setInterpolation(samplerDef.interpolation || AnimationSampler.Interpolation.LINEAR);
        if (samplerDef.extras) sampler.setExtras(samplerDef.extras);
        animation.addSampler(sampler);
        return sampler;
      });
      const channels = animationDef.channels || [];
      channels.forEach(channelDef => {
        const channel = document.createAnimationChannel().setSampler(samplers[channelDef.sampler]).setTargetPath(channelDef.target.path);
        if (channelDef.target.node !== undefined) channel.setTargetNode(context.nodes[channelDef.target.node]);
        if (channelDef.extras) channel.setExtras(channelDef.extras);
        animation.addChannel(channel);
      });
      return animation;
    });
    /** Scenes. */
    const sceneDefs = json.scenes || [];
    document.getRoot().listExtensionsUsed().filter(extension => extension.prereadTypes.includes(PropertyType.SCENE)).forEach(extension => extension.preread(context, PropertyType.SCENE));
    context.scenes = sceneDefs.map(sceneDef => {
      const scene = document.createScene(sceneDef.name);
      if (sceneDef.extras) scene.setExtras(sceneDef.extras);
      const children = sceneDef.nodes || [];
      children.map(nodeIndex => context.nodes[nodeIndex]).forEach(node => scene.addChild(node));
      return scene;
    });
    if (json.scene !== undefined) {
      document.getRoot().setDefaultScene(context.scenes[json.scene]);
    }
    /** Extensions (2/2). */
    document.getRoot().listExtensionsUsed().forEach(extension => extension.read(context));
    /** Post-processing. */
    // Consider an accessor to be 'sparse' if it (A) includes sparse value overrides,
    // or (B) does not define .bufferView _and_ no extension provides that data. Case
    // (B) represents a zero-filled accessor.
    accessorDefs.forEach((accessorDef, index) => {
      const accessor = context.accessors[index];
      const hasSparseValues = !!accessorDef.sparse;
      const isZeroFilled = !accessorDef.bufferView && !accessor.getArray();
      if (hasSparseValues || isZeroFilled) {
        accessor.setSparse(true).setArray(getSparseArray(accessorDef, context));
      }
    });
    return document;
  }
  static validate(jsonDoc, options) {
    const json = jsonDoc.json;
    if (json.asset.version !== '2.0') {
      throw new Error(`Unsupported glTF version, "${json.asset.version}".`);
    }
    if (json.extensionsRequired) {
      for (const extensionName of json.extensionsRequired) {
        if (!options.extensions.find(extension => extension.EXTENSION_NAME === extensionName)) {
          throw new Error(`Missing required extension, "${extensionName}".`);
        }
      }
    }
    if (json.extensionsUsed) {
      for (const extensionName of json.extensionsUsed) {
        if (!options.extensions.find(extension => extension.EXTENSION_NAME === extensionName)) {
          options.logger.warn(`Missing optional extension, "${extensionName}".`);
        }
      }
    }
  }
}
/**
 * Returns the contents of an interleaved accessor, as a typed array.
 * @internal
 */
function getInterleavedArray(accessorDef, context) {
  const jsonDoc = context.jsonDoc;
  const bufferView = context.bufferViews[accessorDef.bufferView];
  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];
  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];
  const elementSize = Accessor.getElementSize(accessorDef.type);
  const componentSize = TypedArray.BYTES_PER_ELEMENT;
  const accessorByteOffset = accessorDef.byteOffset || 0;
  const array = new TypedArray(accessorDef.count * elementSize);
  const view = new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
  const byteStride = bufferViewDef.byteStride;
  for (let i = 0; i < accessorDef.count; i++) {
    for (let j = 0; j < elementSize; j++) {
      const byteOffset = accessorByteOffset + i * byteStride + j * componentSize;
      let value;
      switch (accessorDef.componentType) {
        case Accessor.ComponentType.FLOAT:
          value = view.getFloat32(byteOffset, true);
          break;
        case Accessor.ComponentType.UNSIGNED_INT:
          value = view.getUint32(byteOffset, true);
          break;
        case Accessor.ComponentType.UNSIGNED_SHORT:
          value = view.getUint16(byteOffset, true);
          break;
        case Accessor.ComponentType.UNSIGNED_BYTE:
          value = view.getUint8(byteOffset);
          break;
        case Accessor.ComponentType.SHORT:
          value = view.getInt16(byteOffset, true);
          break;
        case Accessor.ComponentType.BYTE:
          value = view.getInt8(byteOffset);
          break;
        default:
          throw new Error(`Unexpected componentType "${accessorDef.componentType}".`);
      }
      array[i * elementSize + j] = value;
    }
  }
  return array;
}
/**
 * Returns the contents of an accessor, as a typed array.
 * @internal
 */
function getAccessorArray(accessorDef, context) {
  const jsonDoc = context.jsonDoc;
  const bufferView = context.bufferViews[accessorDef.bufferView];
  const bufferViewDef = jsonDoc.json.bufferViews[accessorDef.bufferView];
  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];
  const elementSize = Accessor.getElementSize(accessorDef.type);
  const componentSize = TypedArray.BYTES_PER_ELEMENT;
  const elementStride = elementSize * componentSize;
  // Interleaved buffer view.
  if (bufferViewDef.byteStride !== undefined && bufferViewDef.byteStride !== elementStride) {
    return getInterleavedArray(accessorDef, context);
  }
  const byteOffset = bufferView.byteOffset + (accessorDef.byteOffset || 0);
  const byteLength = accessorDef.count * elementSize * componentSize;
  // Might optimize this to avoid deep copy later, but it's useful for now and not a known
  // bottleneck. See https://github.com/donmccurdy/glTF-Transform/issues/256.
  return new TypedArray(bufferView.buffer.slice(byteOffset, byteOffset + byteLength));
}
/**
 * Returns the contents of a sparse accessor, as a typed array.
 * @internal
 */
function getSparseArray(accessorDef, context) {
  const TypedArray = ComponentTypeToTypedArray[accessorDef.componentType];
  const elementSize = Accessor.getElementSize(accessorDef.type);
  let array;
  if (accessorDef.bufferView !== undefined) {
    array = getAccessorArray(accessorDef, context);
  } else {
    array = new TypedArray(accessorDef.count * elementSize);
  }
  const sparseDef = accessorDef.sparse;
  if (!sparseDef) return array; // Zero-filled accessor.
  const count = sparseDef.count;
  const indicesDef = _extends$1({}, accessorDef, sparseDef.indices, {
    count,
    type: 'SCALAR'
  });
  const valuesDef = _extends$1({}, accessorDef, sparseDef.values, {
    count
  });
  const indices = getAccessorArray(indicesDef, context);
  const values = getAccessorArray(valuesDef, context);
  // Override indices given in the sparse data.
  for (let i = 0; i < indicesDef.count; i++) {
    for (let j = 0; j < elementSize; j++) {
      array[indices[i] * elementSize + j] = values[i * elementSize + j];
    }
  }
  return array;
}

var BufferViewTarget;
(function (BufferViewTarget) {
  BufferViewTarget[BufferViewTarget["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
  BufferViewTarget[BufferViewTarget["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
})(BufferViewTarget || (BufferViewTarget = {}));
/**
 * Model class providing writing state to a {@link GLTFWriter} and its {@link Extension}
 * implementations.
 *
 * @hidden
 */
class WriterContext {
  constructor(_doc, jsonDoc, options) {
    this._doc = void 0;
    this.jsonDoc = void 0;
    this.options = void 0;
    this.accessorIndexMap = new Map();
    this.animationIndexMap = new Map();
    this.bufferIndexMap = new Map();
    this.cameraIndexMap = new Map();
    this.skinIndexMap = new Map();
    this.materialIndexMap = new Map();
    this.meshIndexMap = new Map();
    this.nodeIndexMap = new Map();
    this.imageIndexMap = new Map();
    this.textureDefIndexMap = new Map();
    // textureDef JSON -> index
    this.textureInfoDefMap = new Map();
    this.samplerDefIndexMap = new Map();
    // samplerDef JSON -> index
    this.sceneIndexMap = new Map();
    this.imageBufferViews = [];
    this.otherBufferViews = new Map();
    this.otherBufferViewsIndexMap = new Map();
    this.extensionData = {};
    this.bufferURIGenerator = void 0;
    this.imageURIGenerator = void 0;
    this.logger = void 0;
    this._accessorUsageMap = new Map();
    this.accessorUsageGroupedByParent = new Set(['ARRAY_BUFFER']);
    this.accessorParents = new Map();
    this._doc = _doc;
    this.jsonDoc = jsonDoc;
    this.options = options;
    const root = _doc.getRoot();
    const numBuffers = root.listBuffers().length;
    const numImages = root.listTextures().length;
    this.bufferURIGenerator = new UniqueURIGenerator(numBuffers > 1, () => options.basename || 'buffer');
    this.imageURIGenerator = new UniqueURIGenerator(numImages > 1, texture => getSlot(_doc, texture) || options.basename || 'texture');
    this.logger = _doc.getLogger();
  }
  /**
   * Creates a TextureInfo definition, and any Texture or Sampler definitions it requires. If
   * possible, Texture and Sampler definitions are shared.
   */
  createTextureInfoDef(texture, textureInfo) {
    const samplerDef = {
      magFilter: textureInfo.getMagFilter() || undefined,
      minFilter: textureInfo.getMinFilter() || undefined,
      wrapS: textureInfo.getWrapS(),
      wrapT: textureInfo.getWrapT()
    };
    const samplerKey = JSON.stringify(samplerDef);
    if (!this.samplerDefIndexMap.has(samplerKey)) {
      this.samplerDefIndexMap.set(samplerKey, this.jsonDoc.json.samplers.length);
      this.jsonDoc.json.samplers.push(samplerDef);
    }
    const textureDef = {
      source: this.imageIndexMap.get(texture),
      sampler: this.samplerDefIndexMap.get(samplerKey)
    };
    const textureKey = JSON.stringify(textureDef);
    if (!this.textureDefIndexMap.has(textureKey)) {
      this.textureDefIndexMap.set(textureKey, this.jsonDoc.json.textures.length);
      this.jsonDoc.json.textures.push(textureDef);
    }
    const textureInfoDef = {
      index: this.textureDefIndexMap.get(textureKey)
    };
    if (textureInfo.getTexCoord() !== 0) {
      textureInfoDef.texCoord = textureInfo.getTexCoord();
    }
    if (Object.keys(textureInfo.getExtras()).length > 0) {
      textureInfoDef.extras = textureInfo.getExtras();
    }
    this.textureInfoDefMap.set(textureInfo, textureInfoDef);
    return textureInfoDef;
  }
  createPropertyDef(property) {
    const def = {};
    if (property.getName()) {
      def.name = property.getName();
    }
    if (Object.keys(property.getExtras()).length > 0) {
      def.extras = property.getExtras();
    }
    return def;
  }
  createAccessorDef(accessor) {
    const accessorDef = this.createPropertyDef(accessor);
    accessorDef.type = accessor.getType();
    accessorDef.componentType = accessor.getComponentType();
    accessorDef.count = accessor.getCount();
    const needsBounds = this._doc.getGraph().listParentEdges(accessor).some(edge => edge.getName() === 'attributes' && edge.getAttributes().key === 'POSITION' || edge.getName() === 'input');
    if (needsBounds) {
      accessorDef.max = accessor.getMax([]).map(Math.fround);
      accessorDef.min = accessor.getMin([]).map(Math.fround);
    }
    if (accessor.getNormalized()) {
      accessorDef.normalized = accessor.getNormalized();
    }
    return accessorDef;
  }
  createImageData(imageDef, data, texture) {
    if (this.options.format === Format.GLB) {
      this.imageBufferViews.push(data);
      imageDef.bufferView = this.jsonDoc.json.bufferViews.length;
      this.jsonDoc.json.bufferViews.push({
        buffer: 0,
        byteOffset: -1,
        // determined while iterating buffers, in Writer.ts.
        byteLength: data.byteLength
      });
    } else {
      const extension = ImageUtils.mimeTypeToExtension(texture.getMimeType());
      imageDef.uri = this.imageURIGenerator.createURI(texture, extension);
      this.assignResourceURI(imageDef.uri, data, false);
    }
  }
  assignResourceURI(uri, data, throwOnConflict) {
    const resources = this.jsonDoc.resources;
    // https://github.com/KhronosGroup/glTF/issues/2446
    if (!(uri in resources)) {
      resources[uri] = data;
      return;
    }
    if (data === resources[uri]) {
      this.logger.warn(`Duplicate resource URI, "${uri}".`);
      return;
    }
    const conflictMessage = `Resource URI "${uri}" already assigned to different data.`;
    if (!throwOnConflict) {
      this.logger.warn(conflictMessage);
      return;
    }
    throw new Error(conflictMessage);
  }
  /**
   * Returns implicit usage type of the given accessor, related to grouping accessors into
   * buffer views. Usage is a superset of buffer view target, including ARRAY_BUFFER and
   * ELEMENT_ARRAY_BUFFER, but also usages that do not match GPU buffer view targets such as
   * IBMs. Additional usages are defined by extensions, like `EXT_mesh_gpu_instancing`.
   */
  getAccessorUsage(accessor) {
    const cachedUsage = this._accessorUsageMap.get(accessor);
    if (cachedUsage) return cachedUsage;
    if (accessor.getSparse()) return BufferViewUsage$1.SPARSE;
    for (const edge of this._doc.getGraph().listParentEdges(accessor)) {
      const {
        usage
      } = edge.getAttributes();
      if (usage) return usage;
      if (edge.getParent().propertyType !== PropertyType.ROOT) {
        this.logger.warn(`Missing attribute ".usage" on edge, "${edge.getName()}".`);
      }
    }
    // Group accessors with no specified usage into a miscellaneous buffer view.
    return BufferViewUsage$1.OTHER;
  }
  /**
   * Sets usage for the given accessor. Some accessor types must be grouped into
   * buffer views with like accessors. This includes the specified buffer view "targets", but
   * also implicit usage like IBMs or instanced mesh attributes. If unspecified, an accessor
   * will be grouped with other accessors of unspecified usage.
   */
  addAccessorToUsageGroup(accessor, usage) {
    const prevUsage = this._accessorUsageMap.get(accessor);
    if (prevUsage && prevUsage !== usage) {
      throw new Error(`Accessor with usage "${prevUsage}" cannot be reused as "${usage}".`);
    }
    this._accessorUsageMap.set(accessor, usage);
    return this;
  }
}
/** Explicit buffer view targets defined by glTF specification. */
WriterContext.BufferViewTarget = BufferViewTarget;
/**
 * Implicit buffer view usage, not required by glTF specification, but nonetheless useful for
 * proper grouping of accessors into buffer views. Additional usages are defined by extensions,
 * like `EXT_mesh_gpu_instancing`.
 */
WriterContext.BufferViewUsage = BufferViewUsage$1;
/** Maps usage type to buffer view target. Usages not mapped have undefined targets. */
WriterContext.USAGE_TO_TARGET = {
  [BufferViewUsage$1.ARRAY_BUFFER]: BufferViewTarget.ARRAY_BUFFER,
  [BufferViewUsage$1.ELEMENT_ARRAY_BUFFER]: BufferViewTarget.ELEMENT_ARRAY_BUFFER
};
class UniqueURIGenerator {
  constructor(multiple, basename) {
    this.multiple = void 0;
    this.basename = void 0;
    this.counter = {};
    this.multiple = multiple;
    this.basename = basename;
  }
  createURI(object, extension) {
    if (object.getURI()) {
      return object.getURI();
    } else if (!this.multiple) {
      return `${this.basename(object)}.${extension}`;
    } else {
      const basename = this.basename(object);
      this.counter[basename] = this.counter[basename] || 1;
      return `${basename}_${this.counter[basename]++}.${extension}`;
    }
  }
}
/** Returns the first slot (by name) to which the texture is assigned. */
function getSlot(document, texture) {
  const edge = document.getGraph().listParentEdges(texture).find(edge => edge.getParent() !== document.getRoot());
  return edge ? edge.getName().replace(/texture$/i, '') : '';
}

const {
  BufferViewUsage
} = WriterContext;
const {
  UNSIGNED_INT,
  UNSIGNED_SHORT,
  UNSIGNED_BYTE
} = Accessor.ComponentType;
const SUPPORTED_PREWRITE_TYPES = new Set([PropertyType.ACCESSOR, PropertyType.BUFFER, PropertyType.MATERIAL, PropertyType.MESH]);
/**
 * @internal
 * @hidden
 */
class GLTFWriter {
  static write(doc, options) {
    const graph = doc.getGraph();
    const root = doc.getRoot();
    const json = {
      asset: _extends$1({
        generator: `glTF-Transform ${VERSION}`
      }, root.getAsset()),
      extras: _extends$1({}, root.getExtras())
    };
    const jsonDoc = {
      json,
      resources: {}
    };
    const context = new WriterContext(doc, jsonDoc, options);
    const logger = options.logger || Logger.DEFAULT_INSTANCE;
    /* Extensions (1/2). */
    // Extensions present on the Document are not written unless they are also registered with
    // the I/O class. This ensures that setup in `extension.register()` is completed, and
    // allows a Document to be written with specific extensions disabled.
    const extensionsRegistered = new Set(options.extensions.map(ext => ext.EXTENSION_NAME));
    const extensionsUsed = doc.getRoot().listExtensionsUsed().filter(ext => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);
    const extensionsRequired = doc.getRoot().listExtensionsRequired().filter(ext => extensionsRegistered.has(ext.extensionName)).sort((a, b) => a.extensionName > b.extensionName ? 1 : -1);
    if (extensionsUsed.length < doc.getRoot().listExtensionsUsed().length) {
      logger.warn('Some extensions were not registered for I/O, and will not be written.');
    }
    for (const extension of extensionsUsed) {
      // Warn on unsupported prewrite hooks.
      const unsupportedHooks = extension.prewriteTypes.filter(type => !SUPPORTED_PREWRITE_TYPES.has(type));
      if (unsupportedHooks.length) {
        logger.warn(`Prewrite hooks for some types (${unsupportedHooks.join()}), requested by extension ` + `${extension.extensionName}, are unsupported. Please file an issue or a PR.`);
      }
      // Install dependencies.
      for (const key of extension.writeDependencies) {
        extension.install(key, options.dependencies[key]);
      }
    }
    /**
     * Pack a group of accessors into a sequential buffer view. Appends accessor and buffer view
     * definitions to the root JSON lists.
     *
     * @param accessors Accessors to be included.
     * @param bufferIndex Buffer to write to.
     * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.
     * @param bufferViewTarget (Optional) target use of the buffer view.
     */
    function concatAccessors(accessors, bufferIndex, bufferByteOffset, bufferViewTarget) {
      const buffers = [];
      let byteLength = 0;
      // Create accessor definitions, determining size of final buffer view.
      for (const accessor of accessors) {
        const accessorDef = context.createAccessorDef(accessor);
        accessorDef.bufferView = json.bufferViews.length;
        const accessorArray = accessor.getArray();
        const data = BufferUtils.pad(BufferUtils.toView(accessorArray));
        accessorDef.byteOffset = byteLength;
        byteLength += data.byteLength;
        buffers.push(data);
        context.accessorIndexMap.set(accessor, json.accessors.length);
        json.accessors.push(accessorDef);
      }
      // Create buffer view definition.
      const bufferViewData = BufferUtils.concat(buffers);
      const bufferViewDef = {
        buffer: bufferIndex,
        byteOffset: bufferByteOffset,
        byteLength: bufferViewData.byteLength
      };
      if (bufferViewTarget) bufferViewDef.target = bufferViewTarget;
      json.bufferViews.push(bufferViewDef);
      return {
        buffers,
        byteLength
      };
    }
    /**
     * Pack a group of accessors into an interleaved buffer view. Appends accessor and buffer
     * view definitions to the root JSON lists. Buffer view target is implicitly attribute data.
     *
     * References:
     * - [Apple • Best Practices for Working with Vertex Data](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/TechniquesforWorkingwithVertexData/TechniquesforWorkingwithVertexData.html)
     * - [Khronos • Vertex Specification Best Practices](https://www.khronos.org/opengl/wiki/Vertex_Specification_Best_Practices)
     *
     * @param accessors Accessors to be included.
     * @param bufferIndex Buffer to write to.
     * @param bufferByteOffset Offset into the buffer, accounting for other buffer views.
     */
    function interleaveAccessors(accessors, bufferIndex, bufferByteOffset) {
      const vertexCount = accessors[0].getCount();
      let byteStride = 0;
      // Create accessor definitions, determining size and stride of final buffer view.
      for (const accessor of accessors) {
        const accessorDef = context.createAccessorDef(accessor);
        accessorDef.bufferView = json.bufferViews.length;
        accessorDef.byteOffset = byteStride;
        const elementSize = accessor.getElementSize();
        const componentSize = accessor.getComponentSize();
        byteStride += BufferUtils.padNumber(elementSize * componentSize);
        context.accessorIndexMap.set(accessor, json.accessors.length);
        json.accessors.push(accessorDef);
      }
      // Allocate interleaved buffer view.
      const byteLength = vertexCount * byteStride;
      const buffer = new ArrayBuffer(byteLength);
      const view = new DataView(buffer);
      // Write interleaved accessor data to the buffer view.
      for (let i = 0; i < vertexCount; i++) {
        let vertexByteOffset = 0;
        for (const accessor of accessors) {
          const elementSize = accessor.getElementSize();
          const componentSize = accessor.getComponentSize();
          const componentType = accessor.getComponentType();
          const array = accessor.getArray();
          for (let j = 0; j < elementSize; j++) {
            const viewByteOffset = i * byteStride + vertexByteOffset + j * componentSize;
            const value = array[i * elementSize + j];
            switch (componentType) {
              case Accessor.ComponentType.FLOAT:
                view.setFloat32(viewByteOffset, value, true);
                break;
              case Accessor.ComponentType.BYTE:
                view.setInt8(viewByteOffset, value);
                break;
              case Accessor.ComponentType.SHORT:
                view.setInt16(viewByteOffset, value, true);
                break;
              case Accessor.ComponentType.UNSIGNED_BYTE:
                view.setUint8(viewByteOffset, value);
                break;
              case Accessor.ComponentType.UNSIGNED_SHORT:
                view.setUint16(viewByteOffset, value, true);
                break;
              case Accessor.ComponentType.UNSIGNED_INT:
                view.setUint32(viewByteOffset, value, true);
                break;
              default:
                throw new Error('Unexpected component type: ' + componentType);
            }
          }
          vertexByteOffset += BufferUtils.padNumber(elementSize * componentSize);
        }
      }
      // Create buffer view definition.
      const bufferViewDef = {
        buffer: bufferIndex,
        byteOffset: bufferByteOffset,
        byteLength: byteLength,
        byteStride: byteStride,
        target: WriterContext.BufferViewTarget.ARRAY_BUFFER
      };
      json.bufferViews.push(bufferViewDef);
      return {
        byteLength,
        buffers: [new Uint8Array(buffer)]
      };
    }
    /**
     * Pack a group of sparse accessors. Appends accessor and buffer view
     * definitions to the root JSON lists.
     *
     * @param accessors Accessors to be included.
     * @param bufferIndex Buffer to write to.
     * @param bufferByteOffset Current offset into the buffer, accounting for other buffer views.
     */
    function concatSparseAccessors(accessors, bufferIndex, bufferByteOffset) {
      const buffers = [];
      let byteLength = 0;
      const sparseData = new Map();
      let maxIndex = -Infinity;
      let needSparseWarning = false;
      // (1) Write accessor definitions, gathering indices and values.
      for (const accessor of accessors) {
        const accessorDef = context.createAccessorDef(accessor);
        json.accessors.push(accessorDef);
        context.accessorIndexMap.set(accessor, json.accessors.length - 1);
        const indices = [];
        const values = [];
        const el = [];
        const base = new Array(accessor.getElementSize()).fill(0);
        for (let i = 0, il = accessor.getCount(); i < il; i++) {
          accessor.getElement(i, el);
          if (MathUtils.eq(el, base, 0)) continue;
          maxIndex = Math.max(i, maxIndex);
          indices.push(i);
          for (let j = 0; j < el.length; j++) values.push(el[j]);
        }
        const count = indices.length;
        const data = {
          accessorDef,
          count
        };
        sparseData.set(accessor, data);
        if (count === 0) continue;
        if (count > accessor.getCount() / 2) {
          needSparseWarning = true;
        }
        const ValueArray = ComponentTypeToTypedArray[accessor.getComponentType()];
        data.indices = indices;
        data.values = new ValueArray(values);
      }
      // (2) Early exit if all sparse accessors are just zero-filled arrays.
      if (!Number.isFinite(maxIndex)) {
        return {
          buffers,
          byteLength
        };
      }
      if (needSparseWarning) {
        logger.warn(`Some sparse accessors have >50% non-zero elements, which may increase file size.`);
      }
      // (3) Write index buffer view.
      const IndexArray = maxIndex < 255 ? Uint8Array : maxIndex < 65535 ? Uint16Array : Uint32Array;
      const IndexComponentType = maxIndex < 255 ? UNSIGNED_BYTE : maxIndex < 65535 ? UNSIGNED_SHORT : UNSIGNED_INT;
      const indicesBufferViewDef = {
        buffer: bufferIndex,
        byteOffset: bufferByteOffset + byteLength,
        byteLength: 0
      };
      for (const accessor of accessors) {
        const data = sparseData.get(accessor);
        if (data.count === 0) continue;
        data.indicesByteOffset = indicesBufferViewDef.byteLength;
        const buffer = BufferUtils.pad(BufferUtils.toView(new IndexArray(data.indices)));
        buffers.push(buffer);
        byteLength += buffer.byteLength;
        indicesBufferViewDef.byteLength += buffer.byteLength;
      }
      json.bufferViews.push(indicesBufferViewDef);
      const indicesBufferViewIndex = json.bufferViews.length - 1;
      // (4) Write value buffer view.
      const valuesBufferViewDef = {
        buffer: bufferIndex,
        byteOffset: bufferByteOffset + byteLength,
        byteLength: 0
      };
      for (const accessor of accessors) {
        const data = sparseData.get(accessor);
        if (data.count === 0) continue;
        data.valuesByteOffset = valuesBufferViewDef.byteLength;
        const buffer = BufferUtils.pad(BufferUtils.toView(data.values));
        buffers.push(buffer);
        byteLength += buffer.byteLength;
        valuesBufferViewDef.byteLength += buffer.byteLength;
      }
      json.bufferViews.push(valuesBufferViewDef);
      const valuesBufferViewIndex = json.bufferViews.length - 1;
      // (5) Write accessor sparse entries.
      for (const accessor of accessors) {
        const data = sparseData.get(accessor);
        if (data.count === 0) continue;
        data.accessorDef.sparse = {
          count: data.count,
          indices: {
            bufferView: indicesBufferViewIndex,
            byteOffset: data.indicesByteOffset,
            componentType: IndexComponentType
          },
          values: {
            bufferView: valuesBufferViewIndex,
            byteOffset: data.valuesByteOffset
          }
        };
      }
      return {
        buffers,
        byteLength
      };
    }
    json.accessors = [];
    json.bufferViews = [];
    /* Textures. */
    // glTF Transform's "Texture" properties correspond 1:1 with glTF "Image" properties, and
    // with image files. The glTF file may contain more one texture per image, where images
    // are reused with different sampler properties.
    json.samplers = [];
    json.textures = [];
    json.images = root.listTextures().map((texture, textureIndex) => {
      const imageDef = context.createPropertyDef(texture);
      if (texture.getMimeType()) {
        imageDef.mimeType = texture.getMimeType();
      }
      const image = texture.getImage();
      if (image) {
        context.createImageData(imageDef, image, texture);
      }
      context.imageIndexMap.set(texture, textureIndex);
      return imageDef;
    });
    /* Accessors. */
    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.ACCESSOR)).forEach(extension => extension.prewrite(context, PropertyType.ACCESSOR));
    root.listAccessors().forEach(accessor => {
      // Attributes are grouped and interleaved in one buffer view per mesh primitive.
      // Indices for all primitives are grouped into a single buffer view. IBMs are grouped
      // into a single buffer view. Other usage (if specified by extensions) also goes into
      // a dedicated buffer view. Everything else goes into a miscellaneous buffer view.
      // Certain accessor usage should group data into buffer views by the accessor parent.
      // The `accessorParents` map uses the first parent of each accessor for this purpose.
      const groupByParent = context.accessorUsageGroupedByParent;
      const accessorParents = context.accessorParents;
      // Skip if already written by an extension.
      if (context.accessorIndexMap.has(accessor)) return;
      // Assign usage for core accessor usage types (explicit targets and implicit usage).
      const usage = context.getAccessorUsage(accessor);
      context.addAccessorToUsageGroup(accessor, usage);
      // For accessor usage that requires grouping by parent (vertex and instance
      // attributes) organize buffer views accordingly.
      if (groupByParent.has(usage)) {
        const parent = graph.listParents(accessor).find(parent => parent.propertyType !== PropertyType.ROOT);
        accessorParents.set(accessor, parent);
      }
    });
    /* Buffers, buffer views. */
    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.BUFFER)).forEach(extension => extension.prewrite(context, PropertyType.BUFFER));
    const needsBuffer = root.listAccessors().length > 0 || context.otherBufferViews.size > 0 || root.listTextures().length > 0 && options.format === Format.GLB;
    if (needsBuffer && root.listBuffers().length === 0) {
      throw new Error('Buffer required for Document resources, but none was found.');
    }
    json.buffers = [];
    root.listBuffers().forEach((buffer, index) => {
      const bufferDef = context.createPropertyDef(buffer);
      const groupByParent = context.accessorUsageGroupedByParent;
      const accessors = buffer.listParents().filter(property => property instanceof Accessor);
      const uniqueParents = new Set(accessors.map(accessor => context.accessorParents.get(accessor)));
      const parentToIndex = new Map(Array.from(uniqueParents).map((parent, index) => [parent, index]));
      const accessorGroups = {};
      for (const accessor of accessors) {
        var _key;
        // Skip if already written by an extension.
        if (context.accessorIndexMap.has(accessor)) continue;
        const usage = context.getAccessorUsage(accessor);
        let key = usage;
        if (groupByParent.has(usage)) {
          const parent = context.accessorParents.get(accessor);
          key += `:${parentToIndex.get(parent)}`;
        }
        accessorGroups[_key = key] || (accessorGroups[_key] = {
          usage,
          accessors: []
        });
        accessorGroups[key].accessors.push(accessor);
      }
      // Write accessor groups to buffer views.
      const buffers = [];
      const bufferIndex = json.buffers.length;
      let bufferByteLength = 0;
      for (const {
        usage,
        accessors: groupAccessors
      } of Object.values(accessorGroups)) {
        if (usage === BufferViewUsage.ARRAY_BUFFER && options.vertexLayout === VertexLayout.INTERLEAVED) {
          // (1) Interleaved vertex attributes.
          const result = interleaveAccessors(groupAccessors, bufferIndex, bufferByteLength);
          bufferByteLength += result.byteLength;
          buffers.push(...result.buffers);
        } else if (usage === BufferViewUsage.ARRAY_BUFFER) {
          // (2) Non-interleaved vertex attributes.
          for (const accessor of groupAccessors) {
            // We 'interleave' a single accessor because the method pads to
            // 4-byte boundaries, which concatAccessors() does not.
            const result = interleaveAccessors([accessor], bufferIndex, bufferByteLength);
            bufferByteLength += result.byteLength;
            buffers.push(...result.buffers);
          }
        } else if (usage === BufferViewUsage.SPARSE) {
          // (3) Sparse accessors.
          const result = concatSparseAccessors(groupAccessors, bufferIndex, bufferByteLength);
          bufferByteLength += result.byteLength;
          buffers.push(...result.buffers);
        } else if (usage === BufferViewUsage.ELEMENT_ARRAY_BUFFER) {
          // (4) Indices.
          const target = WriterContext.BufferViewTarget.ELEMENT_ARRAY_BUFFER;
          const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength, target);
          bufferByteLength += result.byteLength;
          buffers.push(...result.buffers);
        } else {
          // (5) Other.
          const result = concatAccessors(groupAccessors, bufferIndex, bufferByteLength);
          bufferByteLength += result.byteLength;
          buffers.push(...result.buffers);
        }
      }
      // We only support embedded images in GLB, where the embedded buffer must be the first.
      // Additional buffers are currently left empty (see EXT_meshopt_compression fallback).
      if (context.imageBufferViews.length && index === 0) {
        for (let i = 0; i < context.imageBufferViews.length; i++) {
          json.bufferViews[json.images[i].bufferView].byteOffset = bufferByteLength;
          bufferByteLength += context.imageBufferViews[i].byteLength;
          buffers.push(context.imageBufferViews[i]);
          if (bufferByteLength % 8) {
            // See: https://github.com/KhronosGroup/glTF/issues/1935
            const imagePadding = 8 - bufferByteLength % 8;
            bufferByteLength += imagePadding;
            buffers.push(new Uint8Array(imagePadding));
          }
        }
      }
      if (context.otherBufferViews.has(buffer)) {
        for (const data of context.otherBufferViews.get(buffer)) {
          json.bufferViews.push({
            buffer: bufferIndex,
            byteOffset: bufferByteLength,
            byteLength: data.byteLength
          });
          context.otherBufferViewsIndexMap.set(data, json.bufferViews.length - 1);
          bufferByteLength += data.byteLength;
          buffers.push(data);
        }
      }
      if (bufferByteLength) {
        // Assign buffer URI.
        let uri;
        if (options.format === Format.GLB) {
          uri = GLB_BUFFER;
        } else {
          uri = context.bufferURIGenerator.createURI(buffer, 'bin');
          bufferDef.uri = uri;
        }
        // Write buffer views to buffer.
        bufferDef.byteLength = bufferByteLength;
        context.assignResourceURI(uri, BufferUtils.concat(buffers), true);
      }
      json.buffers.push(bufferDef);
      context.bufferIndexMap.set(buffer, index);
    });
    if (root.listAccessors().find(a => !a.getBuffer())) {
      logger.warn('Skipped writing one or more Accessors: no Buffer assigned.');
    }
    /* Materials. */
    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.MATERIAL)).forEach(extension => extension.prewrite(context, PropertyType.MATERIAL));
    json.materials = root.listMaterials().map((material, index) => {
      const materialDef = context.createPropertyDef(material);
      // Program state & blending.
      if (material.getAlphaMode() !== Material.AlphaMode.OPAQUE) {
        materialDef.alphaMode = material.getAlphaMode();
      }
      if (material.getAlphaMode() === Material.AlphaMode.MASK) {
        materialDef.alphaCutoff = material.getAlphaCutoff();
      }
      if (material.getDoubleSided()) materialDef.doubleSided = true;
      // Factors.
      materialDef.pbrMetallicRoughness = {};
      if (!MathUtils.eq(material.getBaseColorFactor(), [1, 1, 1, 1])) {
        materialDef.pbrMetallicRoughness.baseColorFactor = material.getBaseColorFactor();
      }
      if (!MathUtils.eq(material.getEmissiveFactor(), [0, 0, 0])) {
        materialDef.emissiveFactor = material.getEmissiveFactor();
      }
      if (material.getRoughnessFactor() !== 1) {
        materialDef.pbrMetallicRoughness.roughnessFactor = material.getRoughnessFactor();
      }
      if (material.getMetallicFactor() !== 1) {
        materialDef.pbrMetallicRoughness.metallicFactor = material.getMetallicFactor();
      }
      // Textures.
      if (material.getBaseColorTexture()) {
        const texture = material.getBaseColorTexture();
        const textureInfo = material.getBaseColorTextureInfo();
        materialDef.pbrMetallicRoughness.baseColorTexture = context.createTextureInfoDef(texture, textureInfo);
      }
      if (material.getEmissiveTexture()) {
        const texture = material.getEmissiveTexture();
        const textureInfo = material.getEmissiveTextureInfo();
        materialDef.emissiveTexture = context.createTextureInfoDef(texture, textureInfo);
      }
      if (material.getNormalTexture()) {
        const texture = material.getNormalTexture();
        const textureInfo = material.getNormalTextureInfo();
        const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);
        if (material.getNormalScale() !== 1) {
          textureInfoDef.scale = material.getNormalScale();
        }
        materialDef.normalTexture = textureInfoDef;
      }
      if (material.getOcclusionTexture()) {
        const texture = material.getOcclusionTexture();
        const textureInfo = material.getOcclusionTextureInfo();
        const textureInfoDef = context.createTextureInfoDef(texture, textureInfo);
        if (material.getOcclusionStrength() !== 1) {
          textureInfoDef.strength = material.getOcclusionStrength();
        }
        materialDef.occlusionTexture = textureInfoDef;
      }
      if (material.getMetallicRoughnessTexture()) {
        const texture = material.getMetallicRoughnessTexture();
        const textureInfo = material.getMetallicRoughnessTextureInfo();
        materialDef.pbrMetallicRoughness.metallicRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);
      }
      context.materialIndexMap.set(material, index);
      return materialDef;
    });
    /* Meshes. */
    extensionsUsed.filter(extension => extension.prewriteTypes.includes(PropertyType.MESH)).forEach(extension => extension.prewrite(context, PropertyType.MESH));
    json.meshes = root.listMeshes().map((mesh, index) => {
      const meshDef = context.createPropertyDef(mesh);
      let targetNames = null;
      meshDef.primitives = mesh.listPrimitives().map(primitive => {
        const primitiveDef = {
          attributes: {}
        };
        primitiveDef.mode = primitive.getMode();
        const material = primitive.getMaterial();
        if (material) {
          primitiveDef.material = context.materialIndexMap.get(material);
        }
        if (Object.keys(primitive.getExtras()).length) {
          primitiveDef.extras = primitive.getExtras();
        }
        const indices = primitive.getIndices();
        if (indices) {
          primitiveDef.indices = context.accessorIndexMap.get(indices);
        }
        for (const semantic of primitive.listSemantics()) {
          primitiveDef.attributes[semantic] = context.accessorIndexMap.get(primitive.getAttribute(semantic));
        }
        for (const target of primitive.listTargets()) {
          const targetDef = {};
          for (const semantic of target.listSemantics()) {
            targetDef[semantic] = context.accessorIndexMap.get(target.getAttribute(semantic));
          }
          primitiveDef.targets = primitiveDef.targets || [];
          primitiveDef.targets.push(targetDef);
        }
        if (primitive.listTargets().length && !targetNames) {
          targetNames = primitive.listTargets().map(target => target.getName());
        }
        return primitiveDef;
      });
      if (mesh.getWeights().length) {
        meshDef.weights = mesh.getWeights();
      }
      if (targetNames) {
        meshDef.extras = meshDef.extras || {};
        meshDef.extras['targetNames'] = targetNames;
      }
      context.meshIndexMap.set(mesh, index);
      return meshDef;
    });
    /** Cameras. */
    json.cameras = root.listCameras().map((camera, index) => {
      const cameraDef = context.createPropertyDef(camera);
      cameraDef.type = camera.getType();
      if (cameraDef.type === Camera.Type.PERSPECTIVE) {
        cameraDef.perspective = {
          znear: camera.getZNear(),
          zfar: camera.getZFar(),
          yfov: camera.getYFov()
        };
        const aspectRatio = camera.getAspectRatio();
        if (aspectRatio !== null) {
          cameraDef.perspective.aspectRatio = aspectRatio;
        }
      } else {
        cameraDef.orthographic = {
          znear: camera.getZNear(),
          zfar: camera.getZFar(),
          xmag: camera.getXMag(),
          ymag: camera.getYMag()
        };
      }
      context.cameraIndexMap.set(camera, index);
      return cameraDef;
    });
    /* Nodes. */
    json.nodes = root.listNodes().map((node, index) => {
      const nodeDef = context.createPropertyDef(node);
      if (!MathUtils.eq(node.getTranslation(), [0, 0, 0])) {
        nodeDef.translation = node.getTranslation();
      }
      if (!MathUtils.eq(node.getRotation(), [0, 0, 0, 1])) {
        nodeDef.rotation = node.getRotation();
      }
      if (!MathUtils.eq(node.getScale(), [1, 1, 1])) {
        nodeDef.scale = node.getScale();
      }
      if (node.getWeights().length) {
        nodeDef.weights = node.getWeights();
      }
      // Attachments (mesh, camera, skin) defined later in writing process.
      context.nodeIndexMap.set(node, index);
      return nodeDef;
    });
    /** Skins. */
    json.skins = root.listSkins().map((skin, index) => {
      const skinDef = context.createPropertyDef(skin);
      const inverseBindMatrices = skin.getInverseBindMatrices();
      if (inverseBindMatrices) {
        skinDef.inverseBindMatrices = context.accessorIndexMap.get(inverseBindMatrices);
      }
      const skeleton = skin.getSkeleton();
      if (skeleton) {
        skinDef.skeleton = context.nodeIndexMap.get(skeleton);
      }
      skinDef.joints = skin.listJoints().map(joint => context.nodeIndexMap.get(joint));
      context.skinIndexMap.set(skin, index);
      return skinDef;
    });
    /** Node attachments. */
    root.listNodes().forEach((node, index) => {
      const nodeDef = json.nodes[index];
      const mesh = node.getMesh();
      if (mesh) {
        nodeDef.mesh = context.meshIndexMap.get(mesh);
      }
      const camera = node.getCamera();
      if (camera) {
        nodeDef.camera = context.cameraIndexMap.get(camera);
      }
      const skin = node.getSkin();
      if (skin) {
        nodeDef.skin = context.skinIndexMap.get(skin);
      }
      if (node.listChildren().length > 0) {
        nodeDef.children = node.listChildren().map(node => context.nodeIndexMap.get(node));
      }
    });
    /** Animations. */
    json.animations = root.listAnimations().map((animation, index) => {
      const animationDef = context.createPropertyDef(animation);
      const samplerIndexMap = new Map();
      animationDef.samplers = animation.listSamplers().map((sampler, samplerIndex) => {
        const samplerDef = context.createPropertyDef(sampler);
        samplerDef.input = context.accessorIndexMap.get(sampler.getInput());
        samplerDef.output = context.accessorIndexMap.get(sampler.getOutput());
        samplerDef.interpolation = sampler.getInterpolation();
        samplerIndexMap.set(sampler, samplerIndex);
        return samplerDef;
      });
      animationDef.channels = animation.listChannels().map(channel => {
        const channelDef = context.createPropertyDef(channel);
        channelDef.sampler = samplerIndexMap.get(channel.getSampler());
        channelDef.target = {
          node: context.nodeIndexMap.get(channel.getTargetNode()),
          path: channel.getTargetPath()
        };
        return channelDef;
      });
      context.animationIndexMap.set(animation, index);
      return animationDef;
    });
    /* Scenes. */
    json.scenes = root.listScenes().map((scene, index) => {
      const sceneDef = context.createPropertyDef(scene);
      sceneDef.nodes = scene.listChildren().map(node => context.nodeIndexMap.get(node));
      context.sceneIndexMap.set(scene, index);
      return sceneDef;
    });
    const defaultScene = root.getDefaultScene();
    if (defaultScene) {
      json.scene = root.listScenes().indexOf(defaultScene);
    }
    /* Extensions (2/2). */
    json.extensionsUsed = extensionsUsed.map(ext => ext.extensionName);
    json.extensionsRequired = extensionsRequired.map(ext => ext.extensionName);
    extensionsUsed.forEach(extension => extension.write(context));
    //
    clean(json);
    return jsonDoc;
  }
}
/**
 * Removes empty and null values from an object.
 * @param object
 * @internal
 */
function clean(object) {
  const unused = [];
  for (const key in object) {
    const value = object[key];
    if (Array.isArray(value) && value.length === 0) {
      unused.push(key);
    } else if (value === null || value === '') {
      unused.push(key);
    } else if (value && typeof value === 'object' && Object.keys(value).length === 0) {
      unused.push(key);
    }
  }
  for (const key of unused) {
    delete object[key];
  }
}

var ChunkType;
(function (ChunkType) {
  ChunkType[ChunkType["JSON"] = 1313821514] = "JSON";
  ChunkType[ChunkType["BIN"] = 5130562] = "BIN";
})(ChunkType || (ChunkType = {}));
/**
 * *Abstract I/O service.*
 *
 * The most common use of the I/O service is to read/write a {@link Document} with a given path.
 * Methods are also available for converting in-memory representations of raw glTF files, both
 * binary (*Uint8Array*) and JSON ({@link JSONDocument}).
 *
 * For platform-specific implementations, see {@link NodeIO}, {@link WebIO}, and {@link DenoIO}.
 *
 * @category I/O
 */
class PlatformIO {
  constructor() {
    this._logger = Logger.DEFAULT_INSTANCE;
    this._extensions = new Set();
    this._dependencies = {};
    this._vertexLayout = VertexLayout.INTERLEAVED;
    /** @hidden */
    this.lastReadBytes = 0;
    /** @hidden */
    this.lastWriteBytes = 0;
  }
  /** Sets the {@link Logger} used by this I/O instance. Defaults to Logger.DEFAULT_INSTANCE. */
  setLogger(logger) {
    this._logger = logger;
    return this;
  }
  /** Registers extensions, enabling I/O class to read and write glTF assets requiring them. */
  registerExtensions(extensions) {
    for (const extension of extensions) {
      this._extensions.add(extension);
      extension.register();
    }
    return this;
  }
  /** Registers dependencies used (e.g. by extensions) in the I/O process. */
  registerDependencies(dependencies) {
    Object.assign(this._dependencies, dependencies);
    return this;
  }
  /**
   * Sets the vertex layout method used by this I/O instance. Defaults to
   * VertexLayout.INTERLEAVED.
   */
  setVertexLayout(layout) {
    this._vertexLayout = layout;
    return this;
  }
  /**********************************************************************************************
   * Public Read API.
   */
  /** Reads a {@link Document} from the given URI. */
  async read(uri) {
    return await this.readJSON(await this.readAsJSON(uri));
  }
  /** Loads a URI and returns a {@link JSONDocument} struct, without parsing. */
  async readAsJSON(uri) {
    const view = await this.readURI(uri, 'view');
    this.lastReadBytes = view.byteLength;
    const jsonDoc = isGLB(view) ? this._binaryToJSON(view) : {
      json: JSON.parse(BufferUtils.decodeText(view)),
      resources: {}
    };
    // Read external resources first, before Data URIs are replaced.
    await this._readResourcesExternal(jsonDoc, this.dirname(uri));
    this._readResourcesInternal(jsonDoc);
    return jsonDoc;
  }
  /** Converts glTF-formatted JSON and a resource map to a {@link Document}. */
  async readJSON(jsonDoc) {
    jsonDoc = this._copyJSON(jsonDoc);
    this._readResourcesInternal(jsonDoc);
    return GLTFReader.read(jsonDoc, {
      extensions: Array.from(this._extensions),
      dependencies: this._dependencies,
      logger: this._logger
    });
  }
  /** Converts a GLB-formatted Uint8Array to a {@link JSONDocument}. */
  async binaryToJSON(glb) {
    const jsonDoc = this._binaryToJSON(BufferUtils.assertView(glb));
    this._readResourcesInternal(jsonDoc);
    const json = jsonDoc.json;
    // Check for external references, which can't be resolved by this method.
    if (json.buffers && json.buffers.some(bufferDef => isExternalBuffer(jsonDoc, bufferDef))) {
      throw new Error('Cannot resolve external buffers with binaryToJSON().');
    } else if (json.images && json.images.some(imageDef => isExternalImage(jsonDoc, imageDef))) {
      throw new Error('Cannot resolve external images with binaryToJSON().');
    }
    return jsonDoc;
  }
  /** Converts a GLB-formatted Uint8Array to a {@link Document}. */
  async readBinary(glb) {
    return this.readJSON(await this.binaryToJSON(BufferUtils.assertView(glb)));
  }
  /**********************************************************************************************
   * Public Write API.
   */
  /** Converts a {@link Document} to glTF-formatted JSON and a resource map. */
  async writeJSON(doc, _options = {}) {
    if (_options.format === Format.GLB && doc.getRoot().listBuffers().length > 1) {
      throw new Error('GLB must have 0–1 buffers.');
    }
    return GLTFWriter.write(doc, {
      format: _options.format || Format.GLTF,
      basename: _options.basename || '',
      logger: this._logger,
      vertexLayout: this._vertexLayout,
      dependencies: _extends$1({}, this._dependencies),
      extensions: Array.from(this._extensions)
    });
  }
  /** Converts a {@link Document} to a GLB-formatted Uint8Array. */
  async writeBinary(doc) {
    const {
      json,
      resources
    } = await this.writeJSON(doc, {
      format: Format.GLB
    });
    const header = new Uint32Array([0x46546c67, 2, 12]);
    const jsonText = JSON.stringify(json);
    const jsonChunkData = BufferUtils.pad(BufferUtils.encodeText(jsonText), 0x20);
    const jsonChunkHeader = BufferUtils.toView(new Uint32Array([jsonChunkData.byteLength, 0x4e4f534a]));
    const jsonChunk = BufferUtils.concat([jsonChunkHeader, jsonChunkData]);
    header[header.length - 1] += jsonChunk.byteLength;
    const binBuffer = Object.values(resources)[0];
    if (!binBuffer || !binBuffer.byteLength) {
      return BufferUtils.concat([BufferUtils.toView(header), jsonChunk]);
    }
    const binChunkData = BufferUtils.pad(binBuffer, 0x00);
    const binChunkHeader = BufferUtils.toView(new Uint32Array([binChunkData.byteLength, 0x004e4942]));
    const binChunk = BufferUtils.concat([binChunkHeader, binChunkData]);
    header[header.length - 1] += binChunk.byteLength;
    return BufferUtils.concat([BufferUtils.toView(header), jsonChunk, binChunk]);
  }
  /**********************************************************************************************
   * Internal.
   */
  async _readResourcesExternal(jsonDoc, base) {
    var _this = this;
    const images = jsonDoc.json.images || [];
    const buffers = jsonDoc.json.buffers || [];
    const pendingResources = [...images, ...buffers].map(async function (resource) {
      const uri = resource.uri;
      if (!uri || uri.match(/data:/)) return Promise.resolve();
      jsonDoc.resources[uri] = await _this.readURI(_this.resolve(base, uri), 'view');
      _this.lastReadBytes += jsonDoc.resources[uri].byteLength;
    });
    await Promise.all(pendingResources);
  }
  _readResourcesInternal(jsonDoc) {
    // NOTICE: This method may be called more than once during the loading
    // process (e.g. WebIO.read) and should handle that safely.
    function resolveResource(resource) {
      if (!resource.uri) return;
      if (resource.uri in jsonDoc.resources) {
        BufferUtils.assertView(jsonDoc.resources[resource.uri]);
        return;
      }
      if (resource.uri.match(/data:/)) {
        // Rewrite Data URIs to something short and unique.
        const resourceUUID = `__${uuid()}.${FileUtils.extension(resource.uri)}`;
        jsonDoc.resources[resourceUUID] = BufferUtils.createBufferFromDataURI(resource.uri);
        resource.uri = resourceUUID;
      }
    }
    // Unpack images.
    const images = jsonDoc.json.images || [];
    images.forEach(image => {
      if (image.bufferView === undefined && image.uri === undefined) {
        throw new Error('Missing resource URI or buffer view.');
      }
      resolveResource(image);
    });
    // Unpack buffers.
    const buffers = jsonDoc.json.buffers || [];
    buffers.forEach(resolveResource);
  }
  /**
   * Creates a shallow copy of glTF-formatted {@link JSONDocument}.
   *
   * Images, Buffers, and Resources objects are deep copies so that PlatformIO can safely
   * modify them during the parsing process. Other properties are shallow copies, and buffers
   * are passed by reference.
   */
  _copyJSON(jsonDoc) {
    const {
      images,
      buffers
    } = jsonDoc.json;
    jsonDoc = {
      json: _extends$1({}, jsonDoc.json),
      resources: _extends$1({}, jsonDoc.resources)
    };
    if (images) {
      jsonDoc.json.images = images.map(image => _extends$1({}, image));
    }
    if (buffers) {
      jsonDoc.json.buffers = buffers.map(buffer => _extends$1({}, buffer));
    }
    return jsonDoc;
  }
  /** Internal version of binaryToJSON; does not warn about external resources. */
  _binaryToJSON(glb) {
    // Decode and verify GLB header.
    if (!isGLB(glb)) {
      throw new Error('Invalid glTF 2.0 binary.');
    }
    // Decode JSON chunk.
    const jsonChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + 12, 2);
    if (jsonChunkHeader[1] !== ChunkType.JSON) {
      throw new Error('Missing required GLB JSON chunk.');
    }
    const jsonByteOffset = 20;
    const jsonByteLength = jsonChunkHeader[0];
    const jsonText = BufferUtils.decodeText(BufferUtils.toView(glb, jsonByteOffset, jsonByteLength));
    const json = JSON.parse(jsonText);
    // Decode BIN chunk.
    const binByteOffset = jsonByteOffset + jsonByteLength;
    if (glb.byteLength <= binByteOffset) {
      return {
        json,
        resources: {}
      };
    }
    const binChunkHeader = new Uint32Array(glb.buffer, glb.byteOffset + binByteOffset, 2);
    if (binChunkHeader[1] !== ChunkType.BIN) {
      // Allow GLB files without BIN chunk, but with unknown chunk
      // Spec: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#chunks-overview
      return {
        json,
        resources: {}
      };
    }
    const binByteLength = binChunkHeader[0];
    const binBuffer = BufferUtils.toView(glb, binByteOffset + 8, binByteLength);
    return {
      json,
      resources: {
        [GLB_BUFFER]: binBuffer
      }
    };
  }
}
function isExternalBuffer(jsonDocument, bufferDef) {
  return bufferDef.uri !== undefined && !(bufferDef.uri in jsonDocument.resources);
}
function isExternalImage(jsonDocument, imageDef) {
  return imageDef.uri !== undefined && !(imageDef.uri in jsonDocument.resources) && imageDef.bufferView === undefined;
}
function isGLB(view) {
  if (view.byteLength < 3 * Uint32Array.BYTES_PER_ELEMENT) return false;
  const header = new Uint32Array(view.buffer, view.byteOffset, 3);
  return header[0] === 0x46546c67 && header[1] === 2;
}

/**
 * *I/O service for Web.*
 *
 * The most common use of the I/O service is to read/write a {@link Document} with a given path.
 * Methods are also available for converting in-memory representations of raw glTF files, both
 * binary (*Uint8Array*) and JSON ({@link JSONDocument}).
 *
 * Usage:
 *
 * ```typescript
 * import { WebIO } from '@gltf-transform/core';
 *
 * const io = new WebIO({credentials: 'include'});
 *
 * // Read.
 * let document;
 * document = await io.read('model.glb');  // → Document
 * document = await io.readBinary(glb);    // Uint8Array → Document
 *
 * // Write.
 * const glb = await io.writeBinary(document); // Document → Uint8Array
 * ```
 *
 * @category I/O
 */
class WebIO extends PlatformIO {
  /**
   * Constructs a new WebIO service. Instances are reusable.
   * @param fetchConfig Configuration object for Fetch API.
   */
  constructor(fetchConfig = HTTPUtils.DEFAULT_INIT) {
    super();
    this._fetchConfig = void 0;
    this._fetchConfig = fetchConfig;
  }
  async readURI(uri, type) {
    const response = await fetch(uri, this._fetchConfig);
    switch (type) {
      case 'view':
        return new Uint8Array(await response.arrayBuffer());
      case 'text':
        return response.text();
    }
  }
  resolve(base, path) {
    return HTTPUtils.resolve(base, path);
  }
  dirname(uri) {
    return HTTPUtils.dirname(uri);
  }
}

var ModelErrorCode;
(function (ModelErrorCode) {
    ModelErrorCode["LOAD_FAILED"] = "LOAD_FAILED";
    ModelErrorCode["RESOURCE_CREATION_FAILED"] = "RESOURCE_CREATION_FAILED";
    ModelErrorCode["INVALID_MODEL"] = "INVALID_MODEL";
    ModelErrorCode["RESOURCE_NOT_FOUND"] = "RESOURCE_NOT_FOUND";
    ModelErrorCode["ANIMATION_NOT_FOUND"] = "ANIMATION_NOT_FOUND";
    ModelErrorCode["GL_ERROR"] = "GL_ERROR";
    ModelErrorCode["INVALID_DATA"] = "INVALID_DATA";
    ModelErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    ModelErrorCode["ANIMATION_INVALID_DATA"] = "ANIMATION_INVALID_DATA";
    ModelErrorCode["ANIMATION_INTERPOLATION_ERROR"] = "ANIMATION_INTERPOLATION_ERROR";
})(ModelErrorCode || (ModelErrorCode = {}));
function createModelError(code, message, modelId) {
    return {
        name: 'ModelError',
        message,
        code,
        modelId
    };
}

/// <reference lib="dom" />
// Define a fixed mapping from sampler names to texture units
const SAMPLER_TEXTURE_UNIT_MAP = {
    'u_BaseColorSampler': 0,
    'u_NormalSampler': 1,
    'u_MetallicRoughnessSampler': 2,
    'u_OcclusionSampler': 3,
    'u_EmissiveSampler': 4,
    // Add more samplers here as needed
};
var TextureType;
(function (TextureType) {
    TextureType[TextureType["BaseColor"] = 0] = "BaseColor";
    TextureType[TextureType["MetallicRoughness"] = 1] = "MetallicRoughness";
    TextureType[TextureType["Normal"] = 2] = "Normal";
    TextureType[TextureType["Occlusion"] = 3] = "Occlusion";
    TextureType[TextureType["Emissive"] = 4] = "Emissive";
})(TextureType || (TextureType = {}));

///////////////////////////////////////////////////
// KTX2 Header.
///////////////////////////////////////////////////
const KHR_SUPERCOMPRESSION_NONE = 0;
///////////////////////////////////////////////////
// Data Format Descriptor (DFD).
///////////////////////////////////////////////////
const KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT = 0;
const KHR_DF_VENDORID_KHRONOS = 0;
const KHR_DF_VERSION = 2;
const KHR_DF_MODEL_UNSPECIFIED = 0;
const KHR_DF_MODEL_ETC1S = 163;
const KHR_DF_MODEL_UASTC = 166;
const KHR_DF_FLAG_ALPHA_STRAIGHT = 0;
const KHR_DF_TRANSFER_SRGB = 2;
const KHR_DF_PRIMARIES_BT709 = 1;
const KHR_DF_SAMPLE_DATATYPE_SIGNED = 0x40;
///////////////////////////////////////////////////
// VK FORMAT.
///////////////////////////////////////////////////
const VK_FORMAT_UNDEFINED = 0;

/**
 * Represents an unpacked KTX 2.0 texture container. Data for individual mip levels are stored in
 * the `.levels` array, typically compressed in Basis Universal formats. Additional properties
 * provide metadata required to process, transcode, and upload these textures.
 */
class KTX2Container {
  constructor() {
    /**
     * Specifies the image format using Vulkan VkFormat enum values. When using Basis Universal
     * texture formats, `vkFormat` must be VK_FORMAT_UNDEFINED.
     */
    this.vkFormat = VK_FORMAT_UNDEFINED;
    /**
     * Size of the data type in bytes used to upload the data to a graphics API. When `vkFormat` is
     * VK_FORMAT_UNDEFINED, `typeSize` must be 1.
     */
    this.typeSize = 1;
    /** Width of the texture image for level 0, in pixels. */
    this.pixelWidth = 0;
    /** Height of the texture image for level 0, in pixels. */
    this.pixelHeight = 0;
    /** Depth of the texture image for level 0, in pixels (3D textures only). */
    this.pixelDepth = 0;
    /** Number of array elements (array textures only). */
    this.layerCount = 0;
    /**
     * Number of cubemap faces. For cubemaps and cubemap arrays, `faceCount` must be 6. For all
     * other textures, `faceCount` must be 1. Cubemap faces are stored in +X, -X, +Y, -Y, +Z, -Z
     * order.
     */
    this.faceCount = 1;
    /** Indicates which supercompression scheme has been applied to mip level images, if any. */
    this.supercompressionScheme = KHR_SUPERCOMPRESSION_NONE;
    /** Mip levels, ordered largest (original) to smallest (~1px). */
    this.levels = [];
    /** Data Format Descriptor. */
    this.dataFormatDescriptor = [{
      vendorId: KHR_DF_VENDORID_KHRONOS,
      descriptorType: KHR_DF_KHR_DESCRIPTORTYPE_BASICFORMAT,
      descriptorBlockSize: 0,
      versionNumber: KHR_DF_VERSION,
      colorModel: KHR_DF_MODEL_UNSPECIFIED,
      colorPrimaries: KHR_DF_PRIMARIES_BT709,
      transferFunction: KHR_DF_TRANSFER_SRGB,
      flags: KHR_DF_FLAG_ALPHA_STRAIGHT,
      texelBlockDimension: [0, 0, 0, 0],
      bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
      samples: []
    }];
    /** Key/Value Data. */
    this.keyValue = {};
    /** Supercompression Global Data. */
    this.globalData = null;
  }
}

class BufferReader {
  constructor(data, byteOffset, byteLength, littleEndian) {
    this._dataView = void 0;
    this._littleEndian = void 0;
    this._offset = void 0;
    this._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);
    this._littleEndian = littleEndian;
    this._offset = 0;
  }
  _nextUint8() {
    const value = this._dataView.getUint8(this._offset);
    this._offset += 1;
    return value;
  }
  _nextUint16() {
    const value = this._dataView.getUint16(this._offset, this._littleEndian);
    this._offset += 2;
    return value;
  }
  _nextUint32() {
    const value = this._dataView.getUint32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  }
  _nextUint64() {
    const left = this._dataView.getUint32(this._offset, this._littleEndian);
    const right = this._dataView.getUint32(this._offset + 4, this._littleEndian);
    // TODO(cleanup): Just test this...
    // const value = this._littleEndian ? left + (2 ** 32 * right) : (2 ** 32 * left) + right;
    const value = left + 2 ** 32 * right;
    this._offset += 8;
    return value;
  }
  _nextInt32() {
    const value = this._dataView.getInt32(this._offset, this._littleEndian);
    this._offset += 4;
    return value;
  }
  _nextUint8Array(len) {
    const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._offset, len);
    this._offset += len;
    return value;
  }
  _skip(bytes) {
    this._offset += bytes;
    return this;
  }
  _scan(maxByteLength, term = 0x00) {
    const byteOffset = this._offset;
    let byteLength = 0;
    while (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {
      byteLength++;
      this._offset++;
    }
    if (byteLength < maxByteLength) this._offset++;
    return new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + byteOffset, byteLength);
  }
}
///////////////////////////////////////////////////
// KTX2 Header.
///////////////////////////////////////////////////
const KTX2_ID = [
// '´', 'K', 'T', 'X', '2', '0', 'ª', '\r', '\n', '\x1A', '\n'
0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];
/** Decodes an ArrayBuffer to text. */
function decodeText(buffer) {
  return new TextDecoder().decode(buffer);
}

/**
 * Parses a KTX 2.0 file, returning an unpacked {@link KTX2Container} instance with all associated
 * data. The container's mip levels and other binary data are pointers into the original file, not
 * copies, so the original file should not be overwritten after reading.
 *
 * @param data Bytes of KTX 2.0 file, as Uint8Array or Buffer.
 */
function read(data) {
  ///////////////////////////////////////////////////
  // KTX 2.0 Identifier.
  ///////////////////////////////////////////////////
  const id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);
  if (id[0] !== KTX2_ID[0] ||
  // '´'
  id[1] !== KTX2_ID[1] ||
  // 'K'
  id[2] !== KTX2_ID[2] ||
  // 'T'
  id[3] !== KTX2_ID[3] ||
  // 'X'
  id[4] !== KTX2_ID[4] ||
  // ' '
  id[5] !== KTX2_ID[5] ||
  // '2'
  id[6] !== KTX2_ID[6] ||
  // '0'
  id[7] !== KTX2_ID[7] ||
  // 'ª'
  id[8] !== KTX2_ID[8] ||
  // '\r'
  id[9] !== KTX2_ID[9] ||
  // '\n'
  id[10] !== KTX2_ID[10] ||
  // '\x1A'
  id[11] !== KTX2_ID[11] // '\n'
  ) {
    throw new Error('Missing KTX 2.0 identifier.');
  }
  const container = new KTX2Container();
  ///////////////////////////////////////////////////
  // Header.
  ///////////////////////////////////////////////////
  const headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;
  const headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);
  container.vkFormat = headerReader._nextUint32();
  container.typeSize = headerReader._nextUint32();
  container.pixelWidth = headerReader._nextUint32();
  container.pixelHeight = headerReader._nextUint32();
  container.pixelDepth = headerReader._nextUint32();
  container.layerCount = headerReader._nextUint32();
  container.faceCount = headerReader._nextUint32();
  const levelCount = headerReader._nextUint32();
  container.supercompressionScheme = headerReader._nextUint32();
  const dfdByteOffset = headerReader._nextUint32();
  const dfdByteLength = headerReader._nextUint32();
  const kvdByteOffset = headerReader._nextUint32();
  const kvdByteLength = headerReader._nextUint32();
  const sgdByteOffset = headerReader._nextUint64();
  const sgdByteLength = headerReader._nextUint64();
  ///////////////////////////////////////////////////
  // Level Index.
  ///////////////////////////////////////////////////
  const levelByteLength = levelCount * 3 * 8;
  const levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);
  for (let i = 0; i < levelCount; i++) {
    container.levels.push({
      levelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),
      uncompressedByteLength: levelReader._nextUint64()
    });
  }
  ///////////////////////////////////////////////////
  // Data Format Descriptor (DFD).
  ///////////////////////////////////////////////////
  const dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);
  const dfd = {
    vendorId: dfdReader._skip(4 /* totalSize */)._nextUint16(),
    descriptorType: dfdReader._nextUint16(),
    versionNumber: dfdReader._nextUint16(),
    descriptorBlockSize: dfdReader._nextUint16(),
    colorModel: dfdReader._nextUint8(),
    colorPrimaries: dfdReader._nextUint8(),
    transferFunction: dfdReader._nextUint8(),
    flags: dfdReader._nextUint8(),
    texelBlockDimension: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
    bytesPlane: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
    samples: []
  };
  const sampleStart = 6;
  const sampleWords = 4;
  const numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;
  for (let i = 0; i < numSamples; i++) {
    const sample = {
      bitOffset: dfdReader._nextUint16(),
      bitLength: dfdReader._nextUint8(),
      channelType: dfdReader._nextUint8(),
      samplePosition: [dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8(), dfdReader._nextUint8()],
      sampleLower: -Infinity,
      sampleUpper: Infinity
    };
    if (sample.channelType & KHR_DF_SAMPLE_DATATYPE_SIGNED) {
      sample.sampleLower = dfdReader._nextInt32();
      sample.sampleUpper = dfdReader._nextInt32();
    } else {
      sample.sampleLower = dfdReader._nextUint32();
      sample.sampleUpper = dfdReader._nextUint32();
    }
    dfd.samples[i] = sample;
  }
  container.dataFormatDescriptor.length = 0;
  container.dataFormatDescriptor.push(dfd);
  ///////////////////////////////////////////////////
  // Key/Value Data (KVD).
  ///////////////////////////////////////////////////
  const kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);
  while (kvdReader._offset < kvdByteLength) {
    const keyValueByteLength = kvdReader._nextUint32();
    const keyData = kvdReader._scan(keyValueByteLength);
    const key = decodeText(keyData);
    container.keyValue[key] = kvdReader._nextUint8Array(keyValueByteLength - keyData.byteLength - 1);
    if (key.match(/^ktx/i)) {
      const text = decodeText(container.keyValue[key]);
      container.keyValue[key] = text.substring(0, text.lastIndexOf('\x00'));
    }
    const kvPadding = keyValueByteLength % 4 ? 4 - keyValueByteLength % 4 : 0; // align(4)
    // 4-byte alignment.
    kvdReader._skip(kvPadding);
  }
  ///////////////////////////////////////////////////
  // Supercompression Global Data (SGD).
  ///////////////////////////////////////////////////
  if (sgdByteLength <= 0) return container;
  const sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);
  const endpointCount = sgdReader._nextUint16();
  const selectorCount = sgdReader._nextUint16();
  const endpointsByteLength = sgdReader._nextUint32();
  const selectorsByteLength = sgdReader._nextUint32();
  const tablesByteLength = sgdReader._nextUint32();
  const extendedByteLength = sgdReader._nextUint32();
  const imageDescs = [];
  for (let i = 0; i < levelCount; i++) {
    imageDescs.push({
      imageFlags: sgdReader._nextUint32(),
      rgbSliceByteOffset: sgdReader._nextUint32(),
      rgbSliceByteLength: sgdReader._nextUint32(),
      alphaSliceByteOffset: sgdReader._nextUint32(),
      alphaSliceByteLength: sgdReader._nextUint32()
    });
  }
  const endpointsByteOffset = sgdByteOffset + sgdReader._offset;
  const selectorsByteOffset = endpointsByteOffset + endpointsByteLength;
  const tablesByteOffset = selectorsByteOffset + selectorsByteLength;
  const extendedByteOffset = tablesByteOffset + tablesByteLength;
  const endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);
  const selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);
  const tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);
  const extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);
  container.globalData = {
    endpointCount,
    selectorCount,
    imageDescs,
    endpointsData,
    selectorsData,
    tablesData,
    extendedData
  };
  return container;
}

const EXT_MESH_GPU_INSTANCING = 'EXT_mesh_gpu_instancing';
const EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';
const EXT_TEXTURE_WEBP = 'EXT_texture_webp';
const EXT_TEXTURE_AVIF = 'EXT_texture_avif';
const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';
const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';
const KHR_MATERIALS_ANISOTROPY = 'KHR_materials_anisotropy';
const KHR_MATERIALS_CLEARCOAT = 'KHR_materials_clearcoat';
const KHR_MATERIALS_DIFFUSE_TRANSMISSION = 'KHR_materials_diffuse_transmission';
const KHR_MATERIALS_DISPERSION = 'KHR_materials_dispersion';
const KHR_MATERIALS_EMISSIVE_STRENGTH = 'KHR_materials_emissive_strength';
const KHR_MATERIALS_IOR = 'KHR_materials_ior';
const KHR_MATERIALS_IRIDESCENCE = 'KHR_materials_iridescence';
const KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS = 'KHR_materials_pbrSpecularGlossiness';
const KHR_MATERIALS_SHEEN = 'KHR_materials_sheen';
const KHR_MATERIALS_SPECULAR = 'KHR_materials_specular';
const KHR_MATERIALS_TRANSMISSION = 'KHR_materials_transmission';
const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';
const KHR_MATERIALS_VOLUME = 'KHR_materials_volume';
const KHR_MATERIALS_VARIANTS = 'KHR_materials_variants';
const KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';
const KHR_TEXTURE_BASISU = 'KHR_texture_basisu';
const KHR_TEXTURE_TRANSFORM = 'KHR_texture_transform';
const KHR_XMP_JSON_LD = 'KHR_xmp_json_ld';

// See BufferViewUsage in `writer-context.ts`.
const INSTANCE_ATTRIBUTE = 'INSTANCE_ATTRIBUTE';
/**
 * Defines GPU instances of a {@link Mesh} under one {@link Node}. See {@link EXTMeshGPUInstancing}.
 */
class InstancedMesh extends ExtensionProperty {
  init() {
    this.extensionName = EXT_MESH_GPU_INSTANCING;
    this.propertyType = 'InstancedMesh';
    this.parentTypes = [PropertyType.NODE];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      attributes: new RefMap()
    });
  }
  /** Returns an instance attribute as an {@link Accessor}. */
  getAttribute(semantic) {
    return this.getRefMap('attributes', semantic);
  }
  /**
   * Sets an instance attribute to an {@link Accessor}. All attributes must have the same
   * instance count.
   */
  setAttribute(semantic, accessor) {
    return this.setRefMap('attributes', semantic, accessor, {
      usage: INSTANCE_ATTRIBUTE
    });
  }
  /**
   * Lists all instance attributes {@link Accessor}s associated with the InstancedMesh. Order
   * will be consistent with the order returned by {@link .listSemantics}().
   */
  listAttributes() {
    return this.listRefMapValues('attributes');
  }
  /**
   * Lists all instance attribute semantics associated with the primitive. Order will be
   * consistent with the order returned by {@link .listAttributes}().
   */
  listSemantics() {
    return this.listRefMapKeys('attributes');
  }
}
InstancedMesh.EXTENSION_NAME = EXT_MESH_GPU_INSTANCING;

const NAME$o = EXT_MESH_GPU_INSTANCING;
/**
 * [`EXT_mesh_gpu_instancing`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/)
 * prepares mesh data for efficient GPU instancing.
 *
 * GPU instancing allows engines to render many copies of a single mesh at once using a small number
 * of draw calls. Instancing is particularly useful for things like trees, grass, road signs, etc.
 * Keep in mind that predefined batches, as used in this extension, may prevent frustum culling
 * within a batch. Dividing batches into collocated cells may be preferable to using a single large
 * batch.
 *
 * > _**NOTICE:** While this extension stores mesh data optimized for GPU instancing, it
 * > is important to note that (1) GPU instancing and other optimizations are possible — and
 * > encouraged — even without this extension, and (2) other common meanings of the term
 * > "instancing" exist, distinct from this extension. See
 * > [Appendix: Motivation and Purpose](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing#appendix-motivation-and-purpose)
 * > of the `EXT_mesh_gpu_instancing` specification._
 *
 * Properties:
 * - {@link InstancedMesh}
 *
 * ### Example
 *
 * The `EXTMeshGPUInstancing` class provides a single {@link ExtensionProperty} type, `InstancedMesh`,
 * which may be attached to any {@link Node} instance. For example:
 *
 * ```typescript
 * import { EXTMeshGPUInstancing } from '@gltf-transform/extensions';
 *
 * // Create standard mesh, node, and scene hierarchy.
 * // ...
 *
 * // Assign positions for each instance.
 * const batchPositions = doc.createAccessor('instance_positions')
 * 	.setArray(new Float32Array([
 * 		0, 0, 0,
 * 		1, 0, 0,
 * 		2, 0, 0,
 * 	]))
 * 	.setType(Accessor.Type.VEC3)
 * 	.setBuffer(buffer);
 *
 * // Assign IDs for each instance.
 * const batchIDs = doc.createAccessor('instance_ids')
 * 	.setArray(new Uint8Array([0, 1, 2]))
 * 	.setType(Accessor.Type.SCALAR)
 * 	.setBuffer(buffer);
 *
 * // Create an Extension attached to the Document.
 * const batchExtension = document.createExtension(EXTMeshGPUInstancing)
 * 	.setRequired(true);
 * const batch = batchExtension.createInstancedMesh()
 * 	.setAttribute('TRANSLATION', batchPositions)
 * 	.setAttribute('_ID', batchIDs);
 *
 * node
 * 	.setMesh(mesh)
 * 	.setExtension('EXT_mesh_gpu_instancing', batch);
 * ```
 *
 * Standard instance attributes are `TRANSLATION`, `ROTATION`, and `SCALE`, and support the accessor
 * types allowed by the extension specification. Custom instance attributes are allowed, and should
 * be prefixed with an underscore (`_*`).
 */
class EXTMeshGPUInstancing extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$o;
    /** @hidden */
    this.provideTypes = [PropertyType.NODE];
    /** @hidden */
    this.prewriteTypes = [PropertyType.ACCESSOR];
  }
  /** Creates a new InstancedMesh property for use on a {@link Node}. */
  createInstancedMesh() {
    return new InstancedMesh(this.document.getGraph());
  }
  /** @hidden */
  read(context) {
    const jsonDoc = context.jsonDoc;
    const nodeDefs = jsonDoc.json.nodes || [];
    nodeDefs.forEach((nodeDef, nodeIndex) => {
      if (!nodeDef.extensions || !nodeDef.extensions[NAME$o]) return;
      const instancedMeshDef = nodeDef.extensions[NAME$o];
      const instancedMesh = this.createInstancedMesh();
      for (const semantic in instancedMeshDef.attributes) {
        instancedMesh.setAttribute(semantic, context.accessors[instancedMeshDef.attributes[semantic]]);
      }
      context.nodes[nodeIndex].setExtension(NAME$o, instancedMesh);
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    // Set usage for instance attribute accessors, so they are stored in separate buffer
    // views grouped by parent reference.
    context.accessorUsageGroupedByParent.add(INSTANCE_ATTRIBUTE);
    for (const prop of this.properties) {
      for (const attribute of prop.listAttributes()) {
        context.addAccessorToUsageGroup(attribute, INSTANCE_ATTRIBUTE);
      }
    }
    return this;
  }
  /** @hidden */
  write(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listNodes().forEach(node => {
      const instancedMesh = node.getExtension(NAME$o);
      if (instancedMesh) {
        const nodeIndex = context.nodeIndexMap.get(node);
        const nodeDef = jsonDoc.json.nodes[nodeIndex];
        const instancedMeshDef = {
          attributes: {}
        };
        instancedMesh.listSemantics().forEach(semantic => {
          const attribute = instancedMesh.getAttribute(semantic);
          instancedMeshDef.attributes[semantic] = context.accessorIndexMap.get(attribute);
        });
        nodeDef.extensions = nodeDef.extensions || {};
        nodeDef.extensions[NAME$o] = instancedMeshDef;
      }
    });
    return this;
  }
}
EXTMeshGPUInstancing.EXTENSION_NAME = NAME$o;

function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function (n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

var EncoderMethod$1;
(function (EncoderMethod) {
  EncoderMethod["QUANTIZE"] = "quantize";
  EncoderMethod["FILTER"] = "filter";
})(EncoderMethod$1 || (EncoderMethod$1 = {}));
var MeshoptMode;
(function (MeshoptMode) {
  MeshoptMode["ATTRIBUTES"] = "ATTRIBUTES";
  MeshoptMode["TRIANGLES"] = "TRIANGLES";
  MeshoptMode["INDICES"] = "INDICES";
})(MeshoptMode || (MeshoptMode = {}));
var MeshoptFilter;
(function (MeshoptFilter) {
  /** No filter — quantize only. */
  MeshoptFilter["NONE"] = "NONE";
  /** Four 8- or 16-bit normalized values. */
  MeshoptFilter["OCTAHEDRAL"] = "OCTAHEDRAL";
  /** Four 16-bit normalized values. */
  MeshoptFilter["QUATERNION"] = "QUATERNION";
  /** K single-precision floating point values. */
  MeshoptFilter["EXPONENTIAL"] = "EXPONENTIAL";
})(MeshoptFilter || (MeshoptFilter = {}));

const {
  BYTE,
  SHORT,
  FLOAT
} = Accessor.ComponentType;
const {
  encodeNormalizedInt,
  decodeNormalizedInt
} = MathUtils;
/** Pre-processes array with required filters or padding. */
function prepareAccessor(accessor, encoder, mode, filterOptions) {
  const {
    filter,
    bits
  } = filterOptions;
  const result = {
    array: accessor.getArray(),
    byteStride: accessor.getElementSize() * accessor.getComponentSize(),
    componentType: accessor.getComponentType(),
    normalized: accessor.getNormalized()
  };
  if (mode !== MeshoptMode.ATTRIBUTES) return result;
  if (filter !== MeshoptFilter.NONE) {
    let array = accessor.getNormalized() ? decodeNormalizedIntArray(accessor) : new Float32Array(result.array);
    switch (filter) {
      case MeshoptFilter.EXPONENTIAL:
        // → K single-precision floating point values.
        result.byteStride = accessor.getElementSize() * 4;
        result.componentType = FLOAT;
        result.normalized = false;
        result.array = encoder.encodeFilterExp(array, accessor.getCount(), result.byteStride, bits);
        break;
      case MeshoptFilter.OCTAHEDRAL:
        // → four 8- or 16-bit normalized values.
        result.byteStride = bits > 8 ? 8 : 4;
        result.componentType = bits > 8 ? SHORT : BYTE;
        result.normalized = true;
        array = accessor.getElementSize() === 3 ? padNormals(array) : array;
        result.array = encoder.encodeFilterOct(array, accessor.getCount(), result.byteStride, bits);
        break;
      case MeshoptFilter.QUATERNION:
        // → four 16-bit normalized values.
        result.byteStride = 8;
        result.componentType = SHORT;
        result.normalized = true;
        result.array = encoder.encodeFilterQuat(array, accessor.getCount(), result.byteStride, bits);
        break;
      default:
        throw new Error('Invalid filter.');
    }
    result.min = accessor.getMin([]);
    result.max = accessor.getMax([]);
    if (accessor.getNormalized()) {
      result.min = result.min.map(v => decodeNormalizedInt(v, accessor.getComponentType()));
      result.max = result.max.map(v => decodeNormalizedInt(v, accessor.getComponentType()));
    }
    if (result.normalized) {
      result.min = result.min.map(v => encodeNormalizedInt(v, result.componentType));
      result.max = result.max.map(v => encodeNormalizedInt(v, result.componentType));
    }
  } else if (result.byteStride % 4) {
    result.array = padArrayElements(result.array, accessor.getElementSize());
    result.byteStride = result.array.byteLength / accessor.getCount();
  }
  return result;
}
function decodeNormalizedIntArray(attribute) {
  const componentType = attribute.getComponentType();
  const srcArray = attribute.getArray();
  const dstArray = new Float32Array(srcArray.length);
  for (let i = 0; i < srcArray.length; i++) {
    dstArray[i] = decodeNormalizedInt(srcArray[i], componentType);
  }
  return dstArray;
}
/** Pads array to 4 byte alignment, required for Meshopt ATTRIBUTE buffer views. */
function padArrayElements(srcArray, elementSize) {
  const byteStride = BufferUtils.padNumber(srcArray.BYTES_PER_ELEMENT * elementSize);
  const elementStride = byteStride / srcArray.BYTES_PER_ELEMENT;
  const elementCount = srcArray.length / elementSize;
  const dstArray = new srcArray.constructor(elementCount * elementStride);
  for (let i = 0; i * elementSize < srcArray.length; i++) {
    for (let j = 0; j < elementSize; j++) {
      dstArray[i * elementStride + j] = srcArray[i * elementSize + j];
    }
  }
  return dstArray;
}
/** Pad normals with a .w component for octahedral encoding. */
function padNormals(srcArray) {
  const dstArray = new Float32Array(srcArray.length * 4 / 3);
  for (let i = 0, il = srcArray.length / 3; i < il; i++) {
    dstArray[i * 4] = srcArray[i * 3];
    dstArray[i * 4 + 1] = srcArray[i * 3 + 1];
    dstArray[i * 4 + 2] = srcArray[i * 3 + 2];
  }
  return dstArray;
}
function getMeshoptMode(accessor, usage) {
  if (usage === WriterContext.BufferViewUsage.ELEMENT_ARRAY_BUFFER) {
    const isTriangles = accessor.listParents().some(parent => {
      return parent instanceof Primitive && parent.getMode() === Primitive.Mode.TRIANGLES;
    });
    return isTriangles ? MeshoptMode.TRIANGLES : MeshoptMode.INDICES;
  }
  return MeshoptMode.ATTRIBUTES;
}
function getMeshoptFilter(accessor, doc) {
  const refs = doc.getGraph().listParentEdges(accessor).filter(edge => !(edge.getParent() instanceof Root));
  for (const ref of refs) {
    const refName = ref.getName();
    const refKey = ref.getAttributes().key || '';
    const isDelta = ref.getParent().propertyType === PropertyType.PRIMITIVE_TARGET;
    // Indices.
    if (refName === 'indices') return {
      filter: MeshoptFilter.NONE
    };
    // Attributes.
    //
    // NOTES:
    // - Vertex attributes should be filtered IFF they are _not_ quantized in
    //   'packages/cli/src/transforms/meshopt.ts'.
    // - POSITION and TEXCOORD_0 could use exponential filtering, but this produces broken
    //   output in some cases (e.g. Matilda.glb), for unknown reasons. gltfpack uses manual
    //   quantization for these attributes.
    // - NORMAL and TANGENT attributes use Octahedral filters, but deltas in morphs do not.
    // - When specifying bit depth for vertex attributes, check the defaults in `quantize.ts`
    //	 and overrides in `meshopt.ts`. Don't store deltas at higher precision than base.
    if (refName === 'attributes') {
      if (refKey === 'POSITION') return {
        filter: MeshoptFilter.NONE
      };
      if (refKey === 'TEXCOORD_0') return {
        filter: MeshoptFilter.NONE
      };
      if (refKey.startsWith('JOINTS_')) return {
        filter: MeshoptFilter.NONE
      };
      if (refKey.startsWith('WEIGHTS_')) return {
        filter: MeshoptFilter.NONE
      };
      if (refKey === 'NORMAL' || refKey === 'TANGENT') {
        return isDelta ? {
          filter: MeshoptFilter.NONE
        } : {
          filter: MeshoptFilter.OCTAHEDRAL,
          bits: 8
        };
      }
    }
    // Animation.
    if (refName === 'output') {
      const targetPath = getTargetPath(accessor);
      if (targetPath === 'rotation') return {
        filter: MeshoptFilter.QUATERNION,
        bits: 16
      };
      if (targetPath === 'translation') return {
        filter: MeshoptFilter.EXPONENTIAL,
        bits: 12
      };
      if (targetPath === 'scale') return {
        filter: MeshoptFilter.EXPONENTIAL,
        bits: 12
      };
      return {
        filter: MeshoptFilter.NONE
      };
    }
    // See: https://github.com/donmccurdy/glTF-Transform/issues/489
    if (refName === 'input') return {
      filter: MeshoptFilter.NONE
    };
    if (refName === 'inverseBindMatrices') return {
      filter: MeshoptFilter.NONE
    };
  }
  return {
    filter: MeshoptFilter.NONE
  };
}
function getTargetPath(accessor) {
  for (const sampler of accessor.listParents()) {
    if (!(sampler instanceof AnimationSampler)) continue;
    for (const channel of sampler.listParents()) {
      if (!(channel instanceof AnimationChannel)) continue;
      return channel.getTargetPath();
    }
  }
  return null;
}

/**
 * Returns true for a fallback buffer, else false.
 *
 *   - All references to the fallback buffer must come from bufferViews that
 *     have a EXT_meshopt_compression extension specified.
 *   - No references to the fallback buffer may come from
 *     EXT_meshopt_compression extension JSON.
 */
function isFallbackBuffer(bufferDef) {
  if (!bufferDef.extensions || !bufferDef.extensions[EXT_MESHOPT_COMPRESSION]) return false;
  const fallbackDef = bufferDef.extensions[EXT_MESHOPT_COMPRESSION];
  return !!fallbackDef.fallback;
}

const NAME$n = EXT_MESHOPT_COMPRESSION;
const DEFAULT_ENCODER_OPTIONS$1 = {
  method: EncoderMethod$1.QUANTIZE
};
/**
 * [`EXT_meshopt_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/)
 * provides compression and fast decoding for geometry, morph targets, and animations.
 *
 * Meshopt compression (based on the [meshoptimizer](https://github.com/zeux/meshoptimizer)
 * library) offers a lightweight decoder with very fast runtime decompression, and is
 * appropriate for models of any size. Meshopt can reduce the transmission sizes of geometry,
 * morph targets, animation, and other numeric data stored in buffer views. When textures are
 * large, other complementary compression methods should be used as well.
 *
 * For the full benefits of meshopt compression, **apply gzip, brotli, or another lossless
 * compression method** to the resulting .glb, .gltf, or .bin files. Meshopt specifically
 * pre-optimizes assets for this purpose — without this secondary compression, the size
 * reduction is considerably less.
 *
 * Be aware that decompression happens before uploading to the GPU. While Meshopt decoding is
 * considerably faster than Draco decoding, neither compression method will improve runtime
 * performance directly. To improve framerate, you'll need to simplify the geometry by reducing
 * vertex count or draw calls — not just compress it. Finally, be aware that Meshopt compression is
 * lossy: repeatedly compressing and decompressing a model in a pipeline will lose precision, so
 * compression should generally be the last stage of an art workflow, and uncompressed original
 * files should be kept.
 *
 * The meshoptimizer library ([github](https://github.com/zeux/meshoptimizer/tree/master/js),
 * [npm](https://www.npmjs.com/package/meshoptimizer)) is a required dependency for reading or
 * writing files, and must be provided by the application. Compression may alternatively be applied
 * with the [gltfpack](https://github.com/zeux/meshoptimizer/tree/master/gltf) tool.
 *
 * ### Example
 *
 * ```typescript
 * import { NodeIO } from '@gltf-transform/core';
 * import { reorder, quantize } from '@gltf-transform/functions';
 * import { EXTMeshoptCompression } from '@gltf-transform/extensions';
 * import { MeshoptDecoder, MeshoptEncoder } from 'meshoptimizer';
 *
 * await MeshoptDecoder.ready;
 * await MeshoptEncoder.ready;
 *
 * const io = new NodeIO()
 *	.registerExtensions([EXTMeshoptCompression])
 *	.registerDependencies({
 *		'meshopt.decoder': MeshoptDecoder,
 *		'meshopt.encoder': MeshoptEncoder,
 *	});
 *
 * // Read and decode.
 * const document = await io.read('compressed.glb');
 *
 * // Write and encode. (Medium, -c)
 * await document.transform(
 * 	reorder({encoder: MeshoptEncoder}),
 * 	quantize()
 * );
 * document.createExtension(EXTMeshoptCompression)
 * 	.setRequired(true)
 * 	.setEncoderOptions({ method: EXTMeshoptCompression.EncoderMethod.QUANTIZE });
 * await io.write('compressed-medium.glb', document);
 *
 * // Write and encode. (High, -cc)
 * await document.transform(
 * 	reorder({encoder: MeshoptEncoder}),
 * 	quantize({pattern: /^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\d+)?$/}),
 * );
 * document.createExtension(EXTMeshoptCompression)
 * 	.setRequired(true)
 * 	.setEncoderOptions({ method: EXTMeshoptCompression.EncoderMethod.FILTER });
 * await io.write('compressed-high.glb', document);
 * ```
 */
class EXTMeshoptCompression extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$n;
    /** @hidden */
    this.prereadTypes = [PropertyType.BUFFER, PropertyType.PRIMITIVE];
    /** @hidden */
    this.prewriteTypes = [PropertyType.BUFFER, PropertyType.ACCESSOR];
    /** @hidden */
    this.readDependencies = ['meshopt.decoder'];
    /** @hidden */
    this.writeDependencies = ['meshopt.encoder'];
    this._decoder = null;
    this._decoderFallbackBufferMap = new Map();
    this._encoder = null;
    this._encoderOptions = DEFAULT_ENCODER_OPTIONS$1;
    this._encoderFallbackBuffer = null;
    this._encoderBufferViews = {};
    this._encoderBufferViewData = {};
    this._encoderBufferViewAccessors = {};
  }
  /** @hidden */
  install(key, dependency) {
    if (key === 'meshopt.decoder') {
      this._decoder = dependency;
    }
    if (key === 'meshopt.encoder') {
      this._encoder = dependency;
    }
    return this;
  }
  /**
   * Configures Meshopt options for quality/compression tuning. The two methods rely on different
   * pre-processing before compression, and should be compared on the basis of (a) quality/loss
   * and (b) final asset size after _also_ applying a lossless compression such as gzip or brotli.
   *
   * - QUANTIZE: Default. Pre-process with {@link quantize quantize()} (lossy to specified
   * 	precision) before applying lossless Meshopt compression. Offers a considerable compression
   * 	ratio with or without further supercompression. Equivalent to `gltfpack -c`.
   * - FILTER: Pre-process with lossy filters to improve compression, before applying lossless
   *	Meshopt compression. While output may initially be larger than with the QUANTIZE method,
   *	this method will benefit more from supercompression (e.g. gzip or brotli). Equivalent to
   * 	`gltfpack -cc`.
   *
   * Output with the FILTER method will generally be smaller after supercompression (e.g. gzip or
   * brotli) is applied, but may be larger than QUANTIZE output without it. Decoding is very fast
   * with both methods.
   *
   * Example:
   *
   * ```ts
   * import { EXTMeshoptCompression } from '@gltf-transform/extensions';
   *
   * doc.createExtension(EXTMeshoptCompression)
   * 	.setRequired(true)
   * 	.setEncoderOptions({
   * 		method: EXTMeshoptCompression.EncoderMethod.QUANTIZE
   * 	});
   * ```
   */
  setEncoderOptions(options) {
    this._encoderOptions = _extends({}, DEFAULT_ENCODER_OPTIONS$1, options);
    return this;
  }
  /**********************************************************************************************
   * Decoding.
   */
  /** @internal Checks preconditions, decodes buffer views, and creates decoded primitives. */
  preread(context, propertyType) {
    if (!this._decoder) {
      if (!this.isRequired()) return this;
      throw new Error(`[${NAME$n}] Please install extension dependency, "meshopt.decoder".`);
    }
    if (!this._decoder.supported) {
      if (!this.isRequired()) return this;
      throw new Error(`[${NAME$n}]: Missing WASM support.`);
    }
    if (propertyType === PropertyType.BUFFER) {
      this._prereadBuffers(context);
    } else if (propertyType === PropertyType.PRIMITIVE) {
      this._prereadPrimitives(context);
    }
    return this;
  }
  /** @internal Decode buffer views. */
  _prereadBuffers(context) {
    const jsonDoc = context.jsonDoc;
    const viewDefs = jsonDoc.json.bufferViews || [];
    viewDefs.forEach((viewDef, index) => {
      if (!viewDef.extensions || !viewDef.extensions[NAME$n]) return;
      const meshoptDef = viewDef.extensions[NAME$n];
      const byteOffset = meshoptDef.byteOffset || 0;
      const byteLength = meshoptDef.byteLength || 0;
      const count = meshoptDef.count;
      const stride = meshoptDef.byteStride;
      const result = new Uint8Array(count * stride);
      const bufferDef = jsonDoc.json.buffers[meshoptDef.buffer];
      // TODO(cleanup): Should be encapsulated in writer-context.ts.
      const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];
      const source = BufferUtils.toView(resource, byteOffset, byteLength);
      this._decoder.decodeGltfBuffer(result, count, stride, source, meshoptDef.mode, meshoptDef.filter);
      context.bufferViews[index] = result;
    });
  }
  /**
   * Mark fallback buffers and replacements.
   *
   * Note: Alignment with primitives is arbitrary; this just needs to happen
   * after Buffers have been parsed.
   * @internal
   */
  _prereadPrimitives(context) {
    const jsonDoc = context.jsonDoc;
    const viewDefs = jsonDoc.json.bufferViews || [];
    //
    viewDefs.forEach(viewDef => {
      if (!viewDef.extensions || !viewDef.extensions[NAME$n]) return;
      const meshoptDef = viewDef.extensions[NAME$n];
      const buffer = context.buffers[meshoptDef.buffer];
      const fallbackBuffer = context.buffers[viewDef.buffer];
      const fallbackBufferDef = jsonDoc.json.buffers[viewDef.buffer];
      if (isFallbackBuffer(fallbackBufferDef)) {
        this._decoderFallbackBufferMap.set(fallbackBuffer, buffer);
      }
    });
  }
  /** @hidden Removes Fallback buffers, if extension is required. */
  read(_context) {
    if (!this.isRequired()) return this;
    // Replace fallback buffers.
    for (const [fallbackBuffer, buffer] of this._decoderFallbackBufferMap) {
      for (const parent of fallbackBuffer.listParents()) {
        if (parent instanceof Accessor) {
          parent.swap(fallbackBuffer, buffer);
        }
      }
      fallbackBuffer.dispose();
    }
    return this;
  }
  /**********************************************************************************************
   * Encoding.
   */
  /** @internal Claims accessors that can be compressed and writes compressed buffer views. */
  prewrite(context, propertyType) {
    if (propertyType === PropertyType.ACCESSOR) {
      this._prewriteAccessors(context);
    } else if (propertyType === PropertyType.BUFFER) {
      this._prewriteBuffers(context);
    }
    return this;
  }
  /** @internal Claims accessors that can be compressed. */
  _prewriteAccessors(context) {
    const json = context.jsonDoc.json;
    const encoder = this._encoder;
    const options = this._encoderOptions;
    const graph = this.document.getGraph();
    const fallbackBuffer = this.document.createBuffer(); // Disposed on write.
    const fallbackBufferIndex = this.document.getRoot().listBuffers().indexOf(fallbackBuffer);
    let nextID = 1;
    const parentToID = new Map();
    const getParentID = property => {
      for (const parent of graph.listParents(property)) {
        if (parent.propertyType === PropertyType.ROOT) continue;
        let id = parentToID.get(property);
        if (id === undefined) parentToID.set(property, id = nextID++);
        return id;
      }
      return -1;
    };
    this._encoderFallbackBuffer = fallbackBuffer;
    this._encoderBufferViews = {};
    this._encoderBufferViewData = {};
    this._encoderBufferViewAccessors = {};
    for (const accessor of this.document.getRoot().listAccessors()) {
      // See: https://github.com/donmccurdy/glTF-Transform/pull/323#issuecomment-898791251
      // Example: https://skfb.ly/6qAD8
      if (getTargetPath(accessor) === 'weights') continue;
      // See: https://github.com/donmccurdy/glTF-Transform/issues/289
      if (accessor.getSparse()) continue;
      const usage = context.getAccessorUsage(accessor);
      const parentID = context.accessorUsageGroupedByParent.has(usage) ? getParentID(accessor) : null;
      const mode = getMeshoptMode(accessor, usage);
      const filter = options.method === EncoderMethod$1.FILTER ? getMeshoptFilter(accessor, this.document) : {
        filter: MeshoptFilter.NONE
      };
      const preparedAccessor = prepareAccessor(accessor, encoder, mode, filter);
      const {
        array,
        byteStride
      } = preparedAccessor;
      const buffer = accessor.getBuffer();
      if (!buffer) throw new Error(`${NAME$n}: Missing buffer for accessor.`);
      const bufferIndex = this.document.getRoot().listBuffers().indexOf(buffer);
      // Buffer view grouping key.
      const key = [usage, parentID, mode, filter.filter, byteStride, bufferIndex].join(':');
      let bufferView = this._encoderBufferViews[key];
      let bufferViewData = this._encoderBufferViewData[key];
      let bufferViewAccessors = this._encoderBufferViewAccessors[key];
      // Write new buffer view, if needed.
      if (!bufferView || !bufferViewData) {
        bufferViewAccessors = this._encoderBufferViewAccessors[key] = [];
        bufferViewData = this._encoderBufferViewData[key] = [];
        bufferView = this._encoderBufferViews[key] = {
          buffer: fallbackBufferIndex,
          target: WriterContext.USAGE_TO_TARGET[usage],
          byteOffset: 0,
          byteLength: 0,
          byteStride: usage === WriterContext.BufferViewUsage.ARRAY_BUFFER ? byteStride : undefined,
          extensions: {
            [NAME$n]: {
              buffer: bufferIndex,
              byteOffset: 0,
              byteLength: 0,
              mode: mode,
              filter: filter.filter !== MeshoptFilter.NONE ? filter.filter : undefined,
              byteStride: byteStride,
              count: 0
            }
          }
        };
      }
      // Write accessor.
      const accessorDef = context.createAccessorDef(accessor);
      accessorDef.componentType = preparedAccessor.componentType;
      accessorDef.normalized = preparedAccessor.normalized;
      accessorDef.byteOffset = bufferView.byteLength;
      if (accessorDef.min && preparedAccessor.min) accessorDef.min = preparedAccessor.min;
      if (accessorDef.max && preparedAccessor.max) accessorDef.max = preparedAccessor.max;
      context.accessorIndexMap.set(accessor, json.accessors.length);
      json.accessors.push(accessorDef);
      bufferViewAccessors.push(accessorDef);
      // Update buffer view.
      bufferViewData.push(new Uint8Array(array.buffer, array.byteOffset, array.byteLength));
      bufferView.byteLength += array.byteLength;
      bufferView.extensions.EXT_meshopt_compression.count += accessor.getCount();
    }
  }
  /** @internal Writes compressed buffer views. */
  _prewriteBuffers(context) {
    const encoder = this._encoder;
    for (const key in this._encoderBufferViews) {
      const bufferView = this._encoderBufferViews[key];
      const bufferViewData = this._encoderBufferViewData[key];
      const buffer = this.document.getRoot().listBuffers()[bufferView.extensions[NAME$n].buffer];
      const otherBufferViews = context.otherBufferViews.get(buffer) || [];
      const {
        count,
        byteStride,
        mode
      } = bufferView.extensions[NAME$n];
      const srcArray = BufferUtils.concat(bufferViewData);
      const dstArray = encoder.encodeGltfBuffer(srcArray, count, byteStride, mode);
      const compressedData = BufferUtils.pad(dstArray);
      bufferView.extensions[NAME$n].byteLength = dstArray.byteLength;
      bufferViewData.length = 0;
      bufferViewData.push(compressedData);
      otherBufferViews.push(compressedData);
      context.otherBufferViews.set(buffer, otherBufferViews);
    }
  }
  /** @hidden Puts encoded data into glTF output. */
  write(context) {
    let fallbackBufferByteOffset = 0;
    // Write final encoded buffer view properties.
    for (const key in this._encoderBufferViews) {
      const bufferView = this._encoderBufferViews[key];
      const bufferViewData = this._encoderBufferViewData[key][0];
      const bufferViewIndex = context.otherBufferViewsIndexMap.get(bufferViewData);
      const bufferViewAccessors = this._encoderBufferViewAccessors[key];
      for (const accessorDef of bufferViewAccessors) {
        accessorDef.bufferView = bufferViewIndex;
      }
      const finalBufferViewDef = context.jsonDoc.json.bufferViews[bufferViewIndex];
      const compressedByteOffset = finalBufferViewDef.byteOffset || 0;
      Object.assign(finalBufferViewDef, bufferView);
      finalBufferViewDef.byteOffset = fallbackBufferByteOffset;
      const bufferViewExtensionDef = finalBufferViewDef.extensions[NAME$n];
      bufferViewExtensionDef.byteOffset = compressedByteOffset;
      fallbackBufferByteOffset += BufferUtils.padNumber(bufferView.byteLength);
    }
    // Write final fallback buffer.
    const fallbackBuffer = this._encoderFallbackBuffer;
    const fallbackBufferIndex = context.bufferIndexMap.get(fallbackBuffer);
    const fallbackBufferDef = context.jsonDoc.json.buffers[fallbackBufferIndex];
    fallbackBufferDef.byteLength = fallbackBufferByteOffset;
    fallbackBufferDef.extensions = {
      [NAME$n]: {
        fallback: true
      }
    };
    fallbackBuffer.dispose();
    return this;
  }
}
EXTMeshoptCompression.EXTENSION_NAME = NAME$n;
EXTMeshoptCompression.EncoderMethod = EncoderMethod$1;

const NAME$m = EXT_TEXTURE_AVIF;
class AVIFImageUtils {
  match(array) {
    return array.length >= 12 && BufferUtils.decodeText(array.slice(4, 12)) === 'ftypavif';
  }
  /**
   * Probes size of AVIF or HEIC image. Assumes a single static image, without
   * orientation or other metadata that would affect dimensions.
   */
  getSize(array) {
    if (!this.match(array)) return null;
    // References:
    // - https://stackoverflow.com/questions/66222773/how-to-get-image-dimensions-from-an-avif-file
    // - https://github.com/nodeca/probe-image-size/blob/master/lib/parse_sync/avif.js
    const view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    let box = unbox(view, 0);
    if (!box) return null;
    let offset = box.end;
    while (box = unbox(view, offset)) {
      if (box.type === 'meta') {
        offset = box.start + 4; // version + flags
      } else if (box.type === 'iprp' || box.type === 'ipco') {
        offset = box.start;
      } else if (box.type === 'ispe') {
        return [view.getUint32(box.start + 4), view.getUint32(box.start + 8)];
      } else if (box.type === 'mdat') {
        break; // mdat should be last, unlikely to find metadata past here.
      } else {
        offset = box.end;
      }
    }
    return null;
  }
  getChannels(_buffer) {
    return 4;
  }
}
/**
 * [`EXT_texture_avif`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_avif/)
 * enables AVIF images for any material texture.
 *
 * AVIF offers greatly reduced transmission size, but
 * [requires browser support](https://caniuse.com/avif). Like PNG and JPEG, an AVIF image is
 * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.
 * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format
 * like Basis Universal, with the `KHR_texture_basisu` extension.
 *
 * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the
 * {@link Document}, and affects the entire Document by allowing use of the `image/avif` MIME type
 * and passing AVIF image data to the {@link Texture.setImage} method. Without the Extension, the
 * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF
 * specification.
 *
 * Properties:
 * - N/A
 *
 * ### Example
 *
 * ```typescript
 * import { TextureAVIF } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const avifExtension = document.createExtension(TextureAVIF)
 * 	.setRequired(true);
 * document.createTexture('MyAVIFTexture')
 * 	.setMimeType('image/avif')
 * 	.setImage(fs.readFileSync('my-texture.avif'));
 * ```
 *
 * AVIF conversion is not done automatically when adding the extension as shown above — you must
 * convert the image data first, then pass the `.avif` payload to {@link Texture.setImage}.
 *
 * When the `EXT_texture_avif` extension is added to a file by glTF-Transform, the extension should
 * always be required. This tool does not support writing assets that "fall back" to optional PNG or
 * JPEG image data.
 */
class EXTTextureAVIF extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$m;
    /** @hidden */
    this.prereadTypes = [PropertyType.TEXTURE];
  }
  /** @hidden */
  static register() {
    ImageUtils.registerFormat('image/avif', new AVIFImageUtils());
  }
  /** @hidden */
  preread(context) {
    const textureDefs = context.jsonDoc.json.textures || [];
    textureDefs.forEach(textureDef => {
      if (textureDef.extensions && textureDef.extensions[NAME$m]) {
        textureDef.source = textureDef.extensions[NAME$m].source;
      }
    });
    return this;
  }
  /** @hidden */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  read(context) {
    return this;
  }
  /** @hidden */
  write(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listTextures().forEach(texture => {
      if (texture.getMimeType() === 'image/avif') {
        const imageIndex = context.imageIndexMap.get(texture);
        const textureDefs = jsonDoc.json.textures || [];
        textureDefs.forEach(textureDef => {
          if (textureDef.source === imageIndex) {
            textureDef.extensions = textureDef.extensions || {};
            textureDef.extensions[NAME$m] = {
              source: textureDef.source
            };
            delete textureDef.source;
          }
        });
      }
    });
    return this;
  }
}
EXTTextureAVIF.EXTENSION_NAME = NAME$m;
function unbox(data, offset) {
  if (data.byteLength < 4 + offset) return null;
  // size includes first 4 bytes (length)
  const size = data.getUint32(offset);
  if (data.byteLength < size + offset || size < 8) return null;
  return {
    type: BufferUtils.decodeText(new Uint8Array(data.buffer, data.byteOffset + offset + 4, 4)),
    start: offset + 8,
    end: offset + size
  };
}

const NAME$l = EXT_TEXTURE_WEBP;
class WEBPImageUtils {
  match(array) {
    return array.length >= 12 && array[8] === 87 && array[9] === 69 && array[10] === 66 && array[11] === 80;
  }
  getSize(array) {
    // Reference: http://tools.ietf.org/html/rfc6386
    const RIFF = BufferUtils.decodeText(array.slice(0, 4));
    const WEBP = BufferUtils.decodeText(array.slice(8, 12));
    if (RIFF !== 'RIFF' || WEBP !== 'WEBP') return null;
    const view = new DataView(array.buffer, array.byteOffset);
    // Reference: https://wiki.tcl-lang.org/page/Reading+WEBP+image+dimensions
    let offset = 12;
    while (offset < view.byteLength) {
      const chunkId = BufferUtils.decodeText(new Uint8Array([view.getUint8(offset), view.getUint8(offset + 1), view.getUint8(offset + 2), view.getUint8(offset + 3)]));
      const chunkByteLength = view.getUint32(offset + 4, true);
      if (chunkId === 'VP8 ') {
        const width = view.getInt16(offset + 14, true) & 0x3fff;
        const height = view.getInt16(offset + 16, true) & 0x3fff;
        return [width, height];
      } else if (chunkId === 'VP8L') {
        const b0 = view.getUint8(offset + 9);
        const b1 = view.getUint8(offset + 10);
        const b2 = view.getUint8(offset + 11);
        const b3 = view.getUint8(offset + 12);
        const width = 1 + ((b1 & 0x3f) << 8 | b0);
        const height = 1 + ((b3 & 0xf) << 10 | b2 << 2 | (b1 & 0xc0) >> 6);
        return [width, height];
      }
      offset += 8 + chunkByteLength + chunkByteLength % 2;
    }
    return null;
  }
  getChannels(_buffer) {
    return 4;
  }
}
/**
 * [`EXT_texture_webp`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp/)
 * enables WebP images for any material texture.
 *
 * WebP offers greatly reduced transmission size, but
 * [requires browser support](https://caniuse.com/webp). Like PNG and JPEG, a WebP image is
 * *fully decompressed* when uploaded to the GPU, which increases upload time and GPU memory cost.
 * For seamless uploads and minimal GPU memory cost, it is necessary to use a GPU texture format
 * like Basis Universal, with the `KHR_texture_basisu` extension.
 *
 * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the
 * {@link Document}, and affects the entire Document by allowing use of the `image/webp` MIME type
 * and passing WebP image data to the {@link Texture.setImage} method. Without the Extension, the
 * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF
 * specification.
 *
 * Properties:
 * - N/A
 *
 * ### Example
 *
 * ```typescript
 * import { EXTTextureWebP } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const webpExtension = document.createExtension(EXTTextureWebP)
 * 	.setRequired(true);
 * document.createTexture('MyWebPTexture')
 * 	.setMimeType('image/webp')
 * 	.setImage(fs.readFileSync('my-texture.webp'));
 * ```
 *
 * WebP conversion is not done automatically when adding the extension as shown above — you must
 * convert the image data first, then pass the `.webp` payload to {@link Texture.setImage}.
 *
 * When the `EXT_texture_webp` extension is added to a file by glTF-Transform, the extension should
 * always be required. This tool does not support writing assets that "fall back" to optional PNG or
 * JPEG image data.
 */
class EXTTextureWebP extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$l;
    /** @hidden */
    this.prereadTypes = [PropertyType.TEXTURE];
  }
  /** @hidden */
  static register() {
    ImageUtils.registerFormat('image/webp', new WEBPImageUtils());
  }
  /** @hidden */
  preread(context) {
    const textureDefs = context.jsonDoc.json.textures || [];
    textureDefs.forEach(textureDef => {
      if (textureDef.extensions && textureDef.extensions[NAME$l]) {
        textureDef.source = textureDef.extensions[NAME$l].source;
      }
    });
    return this;
  }
  /** @hidden */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  read(context) {
    return this;
  }
  /** @hidden */
  write(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listTextures().forEach(texture => {
      if (texture.getMimeType() === 'image/webp') {
        const imageIndex = context.imageIndexMap.get(texture);
        const textureDefs = jsonDoc.json.textures || [];
        textureDefs.forEach(textureDef => {
          if (textureDef.source === imageIndex) {
            textureDef.extensions = textureDef.extensions || {};
            textureDef.extensions[NAME$l] = {
              source: textureDef.source
            };
            delete textureDef.source;
          }
        });
      }
    });
    return this;
  }
}
EXTTextureWebP.EXTENSION_NAME = NAME$l;

const NAME$k = KHR_DRACO_MESH_COMPRESSION;
let decoderModule;
// Initialized when decoder module loads.
let COMPONENT_ARRAY;
let DATA_TYPE;
function decodeGeometry(decoder, data) {
  const buffer = new decoderModule.DecoderBuffer();
  try {
    buffer.Init(data, data.length);
    const geometryType = decoder.GetEncodedGeometryType(buffer);
    if (geometryType !== decoderModule.TRIANGULAR_MESH) {
      throw new Error(`[${NAME$k}] Unknown geometry type.`);
    }
    const dracoMesh = new decoderModule.Mesh();
    const status = decoder.DecodeBufferToMesh(buffer, dracoMesh);
    if (!status.ok() || dracoMesh.ptr === 0) {
      throw new Error(`[${NAME$k}] Decoding failure.`);
    }
    return dracoMesh;
  } finally {
    decoderModule.destroy(buffer);
  }
}
function decodeIndex(decoder, mesh) {
  const numFaces = mesh.num_faces();
  const numIndices = numFaces * 3;
  let ptr;
  let indices;
  if (mesh.num_points() <= 65534) {
    const byteLength = numIndices * Uint16Array.BYTES_PER_ELEMENT;
    ptr = decoderModule._malloc(byteLength);
    decoder.GetTrianglesUInt16Array(mesh, byteLength, ptr);
    indices = new Uint16Array(decoderModule.HEAPU16.buffer, ptr, numIndices).slice();
  } else {
    const byteLength = numIndices * Uint32Array.BYTES_PER_ELEMENT;
    ptr = decoderModule._malloc(byteLength);
    decoder.GetTrianglesUInt32Array(mesh, byteLength, ptr);
    indices = new Uint32Array(decoderModule.HEAPU32.buffer, ptr, numIndices).slice();
  }
  decoderModule._free(ptr);
  return indices;
}
function decodeAttribute(decoder, mesh, attribute, accessorDef) {
  const dataType = DATA_TYPE[accessorDef.componentType];
  const ArrayCtor = COMPONENT_ARRAY[accessorDef.componentType];
  const numComponents = attribute.num_components();
  const numPoints = mesh.num_points();
  const numValues = numPoints * numComponents;
  const byteLength = numValues * ArrayCtor.BYTES_PER_ELEMENT;
  const ptr = decoderModule._malloc(byteLength);
  decoder.GetAttributeDataArrayForAllPoints(mesh, attribute, dataType, byteLength, ptr);
  const array = new ArrayCtor(decoderModule.HEAPF32.buffer, ptr, numValues).slice();
  decoderModule._free(ptr);
  return array;
}
function initDecoderModule(_decoderModule) {
  decoderModule = _decoderModule;
  COMPONENT_ARRAY = {
    [Accessor.ComponentType.FLOAT]: Float32Array,
    [Accessor.ComponentType.UNSIGNED_INT]: Uint32Array,
    [Accessor.ComponentType.UNSIGNED_SHORT]: Uint16Array,
    [Accessor.ComponentType.UNSIGNED_BYTE]: Uint8Array,
    [Accessor.ComponentType.SHORT]: Int16Array,
    [Accessor.ComponentType.BYTE]: Int8Array
  };
  DATA_TYPE = {
    [Accessor.ComponentType.FLOAT]: decoderModule.DT_FLOAT32,
    [Accessor.ComponentType.UNSIGNED_INT]: decoderModule.DT_UINT32,
    [Accessor.ComponentType.UNSIGNED_SHORT]: decoderModule.DT_UINT16,
    [Accessor.ComponentType.UNSIGNED_BYTE]: decoderModule.DT_UINT8,
    [Accessor.ComponentType.SHORT]: decoderModule.DT_INT16,
    [Accessor.ComponentType.BYTE]: decoderModule.DT_INT8
  };
}

let encoderModule;
var EncoderMethod;
(function (EncoderMethod) {
  EncoderMethod[EncoderMethod["EDGEBREAKER"] = 1] = "EDGEBREAKER";
  EncoderMethod[EncoderMethod["SEQUENTIAL"] = 0] = "SEQUENTIAL";
})(EncoderMethod || (EncoderMethod = {}));
var AttributeEnum;
(function (AttributeEnum) {
  AttributeEnum["POSITION"] = "POSITION";
  AttributeEnum["NORMAL"] = "NORMAL";
  AttributeEnum["COLOR"] = "COLOR";
  AttributeEnum["TEX_COORD"] = "TEX_COORD";
  AttributeEnum["GENERIC"] = "GENERIC";
})(AttributeEnum || (AttributeEnum = {}));
const DEFAULT_QUANTIZATION_BITS = {
  [AttributeEnum.POSITION]: 14,
  [AttributeEnum.NORMAL]: 10,
  [AttributeEnum.COLOR]: 8,
  [AttributeEnum.TEX_COORD]: 12,
  [AttributeEnum.GENERIC]: 12
};
const DEFAULT_ENCODER_OPTIONS = {
  decodeSpeed: 5,
  encodeSpeed: 5,
  method: EncoderMethod.EDGEBREAKER,
  quantizationBits: DEFAULT_QUANTIZATION_BITS,
  quantizationVolume: 'mesh'
};
function initEncoderModule(_encoderModule) {
  encoderModule = _encoderModule;
}
/**
 * References:
 * - https://github.com/mrdoob/three.js/blob/dev/examples/js/exporters/DRACOExporter.js
 * - https://github.com/CesiumGS/gltf-pipeline/blob/master/lib/compressDracoMeshes.js
 */
function encodeGeometry(prim, _options = DEFAULT_ENCODER_OPTIONS) {
  const options = _extends({}, DEFAULT_ENCODER_OPTIONS, _options);
  options.quantizationBits = _extends({}, DEFAULT_QUANTIZATION_BITS, _options.quantizationBits);
  const builder = new encoderModule.MeshBuilder();
  const mesh = new encoderModule.Mesh();
  const encoder = new encoderModule.ExpertEncoder(mesh);
  const attributeIDs = {};
  const dracoBuffer = new encoderModule.DracoInt8Array();
  const hasMorphTargets = prim.listTargets().length > 0;
  let hasSparseAttributes = false;
  for (const semantic of prim.listSemantics()) {
    const attribute = prim.getAttribute(semantic);
    if (attribute.getSparse()) {
      hasSparseAttributes = true;
      continue;
    }
    const attributeEnum = getAttributeEnum(semantic);
    const attributeID = addAttribute(builder, attribute.getComponentType(), mesh, encoderModule[attributeEnum], attribute.getCount(), attribute.getElementSize(), attribute.getArray());
    if (attributeID === -1) throw new Error(`Error compressing "${semantic}" attribute.`);
    attributeIDs[semantic] = attributeID;
    if (options.quantizationVolume === 'mesh' || semantic !== 'POSITION') {
      encoder.SetAttributeQuantization(attributeID, options.quantizationBits[attributeEnum]);
    } else if (typeof options.quantizationVolume === 'object') {
      const {
        quantizationVolume
      } = options;
      const range = Math.max(quantizationVolume.max[0] - quantizationVolume.min[0], quantizationVolume.max[1] - quantizationVolume.min[1], quantizationVolume.max[2] - quantizationVolume.min[2]);
      encoder.SetAttributeExplicitQuantization(attributeID, options.quantizationBits[attributeEnum], attribute.getElementSize(), quantizationVolume.min, range);
    } else {
      throw new Error('Invalid quantization volume state.');
    }
  }
  const indices = prim.getIndices();
  if (!indices) throw new EncodingError('Primitive must have indices.');
  builder.AddFacesToMesh(mesh, indices.getCount() / 3, indices.getArray());
  encoder.SetSpeedOptions(options.encodeSpeed, options.decodeSpeed);
  encoder.SetTrackEncodedProperties(true);
  // TODO(cleanup): Use edgebreaker without deduplication if possible.
  // See https://github.com/google/draco/issues/929.
  if (options.method === EncoderMethod.SEQUENTIAL || hasMorphTargets || hasSparseAttributes) {
    encoder.SetEncodingMethod(encoderModule.MESH_SEQUENTIAL_ENCODING);
  } else {
    encoder.SetEncodingMethod(encoderModule.MESH_EDGEBREAKER_ENCODING);
  }
  // Encode, preserving vertex order for primitives with morph targets and sparse accessors.
  const byteLength = encoder.EncodeToDracoBuffer(!(hasMorphTargets || hasSparseAttributes), dracoBuffer);
  if (byteLength <= 0) throw new EncodingError('Error applying Draco compression.');
  const data = new Uint8Array(byteLength);
  for (let i = 0; i < byteLength; ++i) {
    data[i] = dracoBuffer.GetValue(i);
  }
  const numVertices = encoder.GetNumberOfEncodedPoints();
  const numIndices = encoder.GetNumberOfEncodedFaces() * 3;
  encoderModule.destroy(dracoBuffer);
  encoderModule.destroy(mesh);
  encoderModule.destroy(builder);
  encoderModule.destroy(encoder);
  return {
    numVertices,
    numIndices,
    data,
    attributeIDs
  };
}
function getAttributeEnum(semantic) {
  if (semantic === 'POSITION') {
    return AttributeEnum.POSITION;
  } else if (semantic === 'NORMAL') {
    return AttributeEnum.NORMAL;
  } else if (semantic.startsWith('COLOR_')) {
    return AttributeEnum.COLOR;
  } else if (semantic.startsWith('TEXCOORD_')) {
    return AttributeEnum.TEX_COORD;
  }
  return AttributeEnum.GENERIC;
}
function addAttribute(builder, componentType, mesh, attribute, count, itemSize, array) {
  switch (componentType) {
    case Accessor.ComponentType.UNSIGNED_BYTE:
      return builder.AddUInt8Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.BYTE:
      return builder.AddInt8Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.UNSIGNED_SHORT:
      return builder.AddUInt16Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.SHORT:
      return builder.AddInt16Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.UNSIGNED_INT:
      return builder.AddUInt32Attribute(mesh, attribute, count, itemSize, array);
    case Accessor.ComponentType.FLOAT:
      return builder.AddFloatAttribute(mesh, attribute, count, itemSize, array);
    default:
      throw new Error(`Unexpected component type, "${componentType}".`);
  }
}
class EncodingError extends Error {}

const NAME$j = KHR_DRACO_MESH_COMPRESSION;
/**
 * [`KHR_draco_mesh_compression`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/)
 * provides advanced compression for mesh geometry.
 *
 * For models where geometry is a significant factor (>1 MB), Draco can reduce filesize by ~95%
 * in many cases. When animation or textures are large, other complementary compression methods
 * should be used as well. For geometry <1MB, the size of the WASM decoder library may outweigh
 * size savings.
 *
 * Be aware that decompression happens before uploading to the GPU — this will add some latency to
 * the parsing process, and means that compressing geometry with  Draco does _not_ affect runtime
 * performance. To improve framerate, you'll need to simplify the geometry by reducing vertex count
 * or draw calls — not just compress it. Finally, be aware that Draco compression is lossy:
 * repeatedly compressing and decompressing a model in a pipeline will lose precision, so
 * compression should generally be the last stage of an art workflow, and uncompressed original
 * files should be kept.
 *
 * A decoder or encoder from the `draco3dgltf` npm module for Node.js (or
 * [elsewhere for web](https://stackoverflow.com/a/66978236/1314762)) is required for reading and writing,
 * and must be provided by the application.
 *
 * ### Encoding options
 *
 * Two compression methods are available: 'edgebreaker' and 'sequential'. The
 * edgebreaker method will give higher compression in general, but changes the
 * order of the model's vertices. To preserve index order, use sequential
 * compression. When a mesh uses morph targets, or a high decoding speed is
 * selected, sequential compression will automatically be chosen.
 *
 * Both speed options affect the encoder's choice of algorithms. For example, a
 * requirement for fast decoding may prevent the encoder from using the best
 * compression methods even if the encoding speed is set to 0. In general, the
 * faster of the two options limits the choice of features that can be used by the
 * encoder. Setting --decodeSpeed to be faster than the --encodeSpeed may allow
 * the encoder to choose the optimal method out of the available features for the
 * given --decodeSpeed.
 *
 * ### Example
 *
 * ```typescript
 * import { NodeIO } from '@gltf-transform/core';
 * import { KHRDracoMeshCompression } from '@gltf-transform/extensions';
 *
 * import draco3d from 'draco3dgltf';
 *
 * // ...
 *
 * const io = new NodeIO()
 *	.registerExtensions([KHRDracoMeshCompression])
 *	.registerDependencies({
 *		'draco3d.decoder': await draco3d.createDecoderModule(), // Optional.
 *		'draco3d.encoder': await draco3d.createEncoderModule(), // Optional.
 *	});
 *
 * // Read and decode.
 * const document = await io.read('compressed.glb');
 *
 * // Write and encode.
 * document.createExtension(KHRDracoMeshCompression)
 * 	.setRequired(true)
 * 	.setEncoderOptions({
 * 		method: KHRDracoMeshCompression.EncoderMethod.EDGEBREAKER,
 * 		encodeSpeed: 5,
 * 		decodeSpeed: 5,
 * 	});
 * await io.write('compressed.glb', document);
 * ```
 */
class KHRDracoMeshCompression extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$j;
    /** @hidden */
    this.prereadTypes = [PropertyType.PRIMITIVE];
    /** @hidden */
    this.prewriteTypes = [PropertyType.ACCESSOR];
    /** @hidden */
    this.readDependencies = ['draco3d.decoder'];
    /** @hidden */
    this.writeDependencies = ['draco3d.encoder'];
    this._decoderModule = null;
    this._encoderModule = null;
    this._encoderOptions = {};
  }
  /** @hidden */
  install(key, dependency) {
    if (key === 'draco3d.decoder') {
      this._decoderModule = dependency;
      initDecoderModule(this._decoderModule);
    }
    if (key === 'draco3d.encoder') {
      this._encoderModule = dependency;
      initEncoderModule(this._encoderModule);
    }
    return this;
  }
  /**
   * Sets Draco compression options. Compression does not take effect until the Document is
   * written with an I/O class.
   *
   * Defaults:
   * ```
   * decodeSpeed?: number = 5;
   * encodeSpeed?: number = 5;
   * method?: EncoderMethod = EncoderMethod.EDGEBREAKER;
   * quantizationBits?: {[ATTRIBUTE_NAME]: bits};
   * quantizationVolume?: 'mesh' | 'scene' | bbox = 'mesh';
   * ```
   */
  setEncoderOptions(options) {
    this._encoderOptions = options;
    return this;
  }
  /** @hidden */
  preread(context) {
    if (!this._decoderModule) {
      throw new Error(`[${NAME$j}] Please install extension dependency, "draco3d.decoder".`);
    }
    const logger = this.document.getLogger();
    const jsonDoc = context.jsonDoc;
    const dracoMeshes = new Map();
    try {
      const meshDefs = jsonDoc.json.meshes || [];
      for (const meshDef of meshDefs) {
        for (const primDef of meshDef.primitives) {
          if (!primDef.extensions || !primDef.extensions[NAME$j]) continue;
          const dracoDef = primDef.extensions[NAME$j];
          let [decoder, dracoMesh] = dracoMeshes.get(dracoDef.bufferView) || [];
          if (!dracoMesh || !decoder) {
            const bufferViewDef = jsonDoc.json.bufferViews[dracoDef.bufferView];
            const bufferDef = jsonDoc.json.buffers[bufferViewDef.buffer];
            // TODO(cleanup): Should be encapsulated in writer-context.ts.
            const resource = bufferDef.uri ? jsonDoc.resources[bufferDef.uri] : jsonDoc.resources[GLB_BUFFER];
            const byteOffset = bufferViewDef.byteOffset || 0;
            const byteLength = bufferViewDef.byteLength;
            const compressedData = BufferUtils.toView(resource, byteOffset, byteLength);
            decoder = new this._decoderModule.Decoder();
            dracoMesh = decodeGeometry(decoder, compressedData);
            dracoMeshes.set(dracoDef.bufferView, [decoder, dracoMesh]);
            logger.debug(`[${NAME$j}] Decompressed ${compressedData.byteLength} bytes.`);
          }
          // Attributes.
          for (const semantic in primDef.attributes) {
            const accessorDef = context.jsonDoc.json.accessors[primDef.attributes[semantic]];
            const dracoAttribute = decoder.GetAttributeByUniqueId(dracoMesh, dracoDef.attributes[semantic]);
            const attributeArray = decodeAttribute(decoder, dracoMesh, dracoAttribute, accessorDef);
            context.accessors[primDef.attributes[semantic]].setArray(attributeArray);
          }
          // Indices. Optional, see https://github.com/google/draco/issues/720.
          if (primDef.indices !== undefined) {
            context.accessors[primDef.indices].setArray(decodeIndex(decoder, dracoMesh));
          }
        }
      }
    } finally {
      for (const [decoder, dracoMesh] of Array.from(dracoMeshes.values())) {
        this._decoderModule.destroy(decoder);
        this._decoderModule.destroy(dracoMesh);
      }
    }
    return this;
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  prewrite(context, _propertyType) {
    if (!this._encoderModule) {
      throw new Error(`[${NAME$j}] Please install extension dependency, "draco3d.encoder".`);
    }
    const logger = this.document.getLogger();
    logger.debug(`[${NAME$j}] Compression options: ${JSON.stringify(this._encoderOptions)}`);
    const primitiveHashMap = listDracoPrimitives(this.document);
    const primitiveEncodingMap = new Map();
    let quantizationVolume = 'mesh';
    if (this._encoderOptions.quantizationVolume === 'scene') {
      if (this.document.getRoot().listScenes().length !== 1) {
        logger.warn(`[${NAME$j}]: quantizationVolume=scene requires exactly 1 scene.`);
      } else {
        quantizationVolume = getBounds(this.document.getRoot().listScenes().pop());
      }
    }
    for (const prim of Array.from(primitiveHashMap.keys())) {
      const primHash = primitiveHashMap.get(prim);
      if (!primHash) throw new Error('Unexpected primitive.');
      // Reuse an existing EncodedPrimitive, if possible.
      if (primitiveEncodingMap.has(primHash)) {
        primitiveEncodingMap.set(primHash, primitiveEncodingMap.get(primHash));
        continue;
      }
      const indices = prim.getIndices(); // Condition for listDracoPrimitives().
      const accessorDefs = context.jsonDoc.json.accessors;
      // Create a new EncodedPrimitive.
      let encodedPrim;
      try {
        encodedPrim = encodeGeometry(prim, _extends({}, this._encoderOptions, {
          quantizationVolume
        }));
      } catch (e) {
        if (e instanceof EncodingError) {
          logger.warn(`[${NAME$j}]: ${e.message} Skipping primitive compression.`);
          continue;
        }
        throw e;
      }
      primitiveEncodingMap.set(primHash, encodedPrim);
      // Create indices definition, update count.
      const indicesDef = context.createAccessorDef(indices);
      indicesDef.count = encodedPrim.numIndices;
      context.accessorIndexMap.set(indices, accessorDefs.length);
      accessorDefs.push(indicesDef);
      // In rare cases Draco increases vertex count, requiring a larger index component type.
      // https://github.com/donmccurdy/glTF-Transform/issues/1370
      if (encodedPrim.numVertices > 65534 && indicesDef.componentType !== Accessor.ComponentType.UNSIGNED_INT) {
        indicesDef.componentType = Accessor.ComponentType.UNSIGNED_INT;
      }
      // Create attribute definitions, update count.
      for (const semantic of prim.listSemantics()) {
        const attribute = prim.getAttribute(semantic);
        if (encodedPrim.attributeIDs[semantic] === undefined) continue; // sparse
        const attributeDef = context.createAccessorDef(attribute);
        attributeDef.count = encodedPrim.numVertices;
        context.accessorIndexMap.set(attribute, accessorDefs.length);
        accessorDefs.push(attributeDef);
      }
      // Map compressed buffer view to a Buffer.
      const buffer = prim.getAttribute('POSITION').getBuffer() || this.document.getRoot().listBuffers()[0];
      if (!context.otherBufferViews.has(buffer)) context.otherBufferViews.set(buffer, []);
      context.otherBufferViews.get(buffer).push(encodedPrim.data);
    }
    logger.debug(`[${NAME$j}] Compressed ${primitiveHashMap.size} primitives.`);
    context.extensionData[NAME$j] = {
      primitiveHashMap,
      primitiveEncodingMap
    };
    return this;
  }
  /** @hidden */
  write(context) {
    const dracoContext = context.extensionData[NAME$j];
    for (const mesh of this.document.getRoot().listMeshes()) {
      const meshDef = context.jsonDoc.json.meshes[context.meshIndexMap.get(mesh)];
      for (let i = 0; i < mesh.listPrimitives().length; i++) {
        const prim = mesh.listPrimitives()[i];
        const primDef = meshDef.primitives[i];
        const primHash = dracoContext.primitiveHashMap.get(prim);
        if (!primHash) continue;
        const encodedPrim = dracoContext.primitiveEncodingMap.get(primHash);
        if (!encodedPrim) continue;
        primDef.extensions = primDef.extensions || {};
        primDef.extensions[NAME$j] = {
          bufferView: context.otherBufferViewsIndexMap.get(encodedPrim.data),
          attributes: encodedPrim.attributeIDs
        };
      }
    }
    // Omit the extension if nothing was compressed.
    if (!dracoContext.primitiveHashMap.size) {
      const json = context.jsonDoc.json;
      json.extensionsUsed = (json.extensionsUsed || []).filter(name => name !== NAME$j);
      json.extensionsRequired = (json.extensionsRequired || []).filter(name => name !== NAME$j);
    }
    return this;
  }
}
/**
 * Returns a list of Primitives compatible with Draco compression. If any required preconditions
 * fail, and would break assumptions required for compression, this function will throw an error.
 */
KHRDracoMeshCompression.EXTENSION_NAME = NAME$j;
/**
 * Compression method. `EncoderMethod.EDGEBREAKER` usually provides a higher compression ratio,
 * while `EncoderMethod.SEQUENTIAL` better preserves original verter order.
 */
KHRDracoMeshCompression.EncoderMethod = EncoderMethod;
function listDracoPrimitives(doc) {
  const logger = doc.getLogger();
  const included = new Set();
  const excluded = new Set();
  let nonIndexed = 0;
  let nonTriangles = 0;
  // Support compressing only indexed, mode=TRIANGLES primitives.
  for (const mesh of doc.getRoot().listMeshes()) {
    for (const prim of mesh.listPrimitives()) {
      if (!prim.getIndices()) {
        excluded.add(prim);
        nonIndexed++;
      } else if (prim.getMode() !== Primitive.Mode.TRIANGLES) {
        excluded.add(prim);
        nonTriangles++;
      } else {
        included.add(prim);
      }
    }
  }
  if (nonIndexed > 0) {
    logger.warn(`[${NAME$j}] Skipping Draco compression of ${nonIndexed} non-indexed primitives.`);
  }
  if (nonTriangles > 0) {
    logger.warn(`[${NAME$j}] Skipping Draco compression of ${nonTriangles} non-TRIANGLES primitives.`);
  }
  // Create an Accessor->index mapping.
  const accessors = doc.getRoot().listAccessors();
  const accessorIndices = new Map();
  for (let i = 0; i < accessors.length; i++) accessorIndices.set(accessors[i], i);
  // For each compressed Primitive, create a hash key identifying its accessors. Map each
  // compressed Primitive and Accessor to this hash key.
  const includedAccessors = new Map();
  const includedHashKeys = new Set();
  const primToHashKey = new Map();
  for (const prim of Array.from(included)) {
    let hashKey = createHashKey(prim, accessorIndices);
    // If accessors of an identical primitive have already been checked, we're done.
    if (includedHashKeys.has(hashKey)) {
      primToHashKey.set(prim, hashKey);
      continue;
    }
    // If any accessors are already in use, but the same hashKey hasn't been written, then we
    // need to create copies of these accessors for the current encoded primitive. We can't
    // reuse the same compressed accessor for two encoded primitives, because Draco might
    // change the vertex count, change the vertex order, or cause other conflicts.
    if (includedAccessors.has(prim.getIndices())) {
      const indices = prim.getIndices(); // Condition for 'included' list.
      const dstIndices = indices.clone();
      accessorIndices.set(dstIndices, doc.getRoot().listAccessors().length - 1);
      prim.swap(indices, dstIndices); // TODO(cleanup): I/O should not modify Document.
    }
    for (const attribute of prim.listAttributes()) {
      if (includedAccessors.has(attribute)) {
        const dstAttribute = attribute.clone();
        accessorIndices.set(dstAttribute, doc.getRoot().listAccessors().length - 1);
        prim.swap(attribute, dstAttribute); // TODO(cleanup): I/O should not modify Document.
      }
    }
    // With conflicts resolved, compute the hash key again.
    hashKey = createHashKey(prim, accessorIndices);
    // Commit the primitive and its accessors to the hash key.
    includedHashKeys.add(hashKey);
    primToHashKey.set(prim, hashKey);
    includedAccessors.set(prim.getIndices(), hashKey);
    for (const attribute of prim.listAttributes()) {
      includedAccessors.set(attribute, hashKey);
    }
  }
  // For each compressed Accessor, ensure that it isn't used except by a Primitive.
  for (const accessor of Array.from(includedAccessors.keys())) {
    const parentTypes = new Set(accessor.listParents().map(prop => prop.propertyType));
    if (parentTypes.size !== 2 || !parentTypes.has(PropertyType.PRIMITIVE) || !parentTypes.has(PropertyType.ROOT)) {
      throw new Error(`[${NAME$j}] Compressed accessors must only be used as indices or vertex attributes.`);
    }
  }
  // For each compressed Primitive, ensure that Accessors are mapped only to the same hash key.
  for (const prim of Array.from(included)) {
    const hashKey = primToHashKey.get(prim);
    const indices = prim.getIndices(); // Condition for 'included' list.
    if (includedAccessors.get(indices) !== hashKey || prim.listAttributes().some(attr => includedAccessors.get(attr) !== hashKey)) {
      throw new Error(`[${NAME$j}] Draco primitives must share all, or no, accessors.`);
    }
  }
  // For each excluded Primitive, ensure that no Accessors are compressed.
  for (const prim of Array.from(excluded)) {
    const indices = prim.getIndices(); // Condition for 'included' list.
    if (includedAccessors.has(indices) || prim.listAttributes().some(attr => includedAccessors.has(attr))) {
      throw new Error(`[${NAME$j}] Accessor cannot be shared by compressed and uncompressed primitives.`);
    }
  }
  return primToHashKey;
}
function createHashKey(prim, indexMap) {
  const hashElements = [];
  const indices = prim.getIndices(); // Condition for 'included' list.
  hashElements.push(indexMap.get(indices));
  for (const attribute of prim.listAttributes()) {
    hashElements.push(indexMap.get(attribute));
  }
  return hashElements.sort().join('|');
}

/**
 * Defines a light attached to a {@link Node}. See {@link KHRLightsPunctual}.
 */
class Light extends ExtensionProperty {
  /**********************************************************************************************
   * INSTANCE.
   */
  init() {
    this.extensionName = KHR_LIGHTS_PUNCTUAL;
    this.propertyType = 'Light';
    this.parentTypes = [PropertyType.NODE];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      color: [1, 1, 1],
      intensity: 1,
      type: Light.Type.POINT,
      range: null,
      innerConeAngle: 0,
      outerConeAngle: Math.PI / 4
    });
  }
  /**********************************************************************************************
   * COLOR.
   */
  /** Light color; Linear-sRGB components. */
  getColor() {
    return this.get('color');
  }
  /** Light color; Linear-sRGB components. */
  setColor(color) {
    return this.set('color', color);
  }
  /**********************************************************************************************
   * INTENSITY.
   */
  /**
   * Brightness of light. Units depend on the type of light: point and spot lights use luminous
   * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).
   */
  getIntensity() {
    return this.get('intensity');
  }
  /**
   * Brightness of light. Units depend on the type of light: point and spot lights use luminous
   * intensity in candela (lm/sr) while directional lights use illuminance in lux (lm/m2).
   */
  setIntensity(intensity) {
    return this.set('intensity', intensity);
  }
  /**********************************************************************************************
   * TYPE.
   */
  /** Type. */
  getType() {
    return this.get('type');
  }
  /** Type. */
  setType(type) {
    return this.set('type', type);
  }
  /**********************************************************************************************
   * RANGE.
   */
  /**
   * Hint defining a distance cutoff at which the light's intensity may be considered to have
   * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range
   * is assumed to be infinite.
   */
  getRange() {
    return this.get('range');
  }
  /**
   * Hint defining a distance cutoff at which the light's intensity may be considered to have
   * reached zero. Supported only for point and spot lights. Must be > 0. When undefined, range
   * is assumed to be infinite.
   */
  setRange(range) {
    return this.set('range', range);
  }
  /**********************************************************************************************
   * SPOT LIGHT PROPERTIES
   */
  /**
   * Angle, in radians, from centre of spotlight where falloff begins. Must be >= 0 and
   * < outerConeAngle.
   */
  getInnerConeAngle() {
    return this.get('innerConeAngle');
  }
  /**
   * Angle, in radians, from centre of spotlight where falloff begins. Must be >= 0 and
   * < outerConeAngle.
   */
  setInnerConeAngle(angle) {
    return this.set('innerConeAngle', angle);
  }
  /**
   * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and
   * <= PI / 2.0.
   */
  getOuterConeAngle() {
    return this.get('outerConeAngle');
  }
  /**
   * Angle, in radians, from centre of spotlight where falloff ends. Must be > innerConeAngle and
   * <= PI / 2.0.
   */
  setOuterConeAngle(angle) {
    return this.set('outerConeAngle', angle);
  }
}
Light.EXTENSION_NAME = KHR_LIGHTS_PUNCTUAL;
/**********************************************************************************************
 * CONSTANTS.
 */
Light.Type = {
  POINT: 'point',
  SPOT: 'spot',
  DIRECTIONAL: 'directional'
};

const NAME$i = KHR_LIGHTS_PUNCTUAL;
/**
 * [`KHR_lights_punctual`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_lights_punctual/) defines three "punctual" light types: directional, point and
 * spot.
 *
 * Punctual lights are parameterized, infinitely small points that emit light in
 * well-defined directions and intensities. Lights are referenced by nodes and inherit the transform
 * of that node.
 *
 * Properties:
 * - {@link Light}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRLightsPunctual, Light, LightType } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const lightsExtension = document.createExtension(KHRLightsPunctual);
 *
 * // Create a Light property.
 * const light = lightsExtension.createLight()
 *	.setType(LightType.POINT)
 *	.setIntensity(2.0)
 *	.setColor([1.0, 0.0, 0.0]);
 *
 * // Attach the property to a Material.
 * node.setExtension('KHR_lights_punctual', light);
 * ```
 */
class KHRLightsPunctual extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$i;
  }
  /** Creates a new punctual Light property for use on a {@link Node}. */
  createLight(name = '') {
    return new Light(this.document.getGraph(), name);
  }
  /** @hidden */
  read(context) {
    const jsonDoc = context.jsonDoc;
    if (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME$i]) return this;
    const rootDef = jsonDoc.json.extensions[NAME$i];
    const lightDefs = rootDef.lights || [];
    const lights = lightDefs.map(lightDef => {
      var _lightDef$spot, _lightDef$spot2;
      const light = this.createLight().setName(lightDef.name || '').setType(lightDef.type);
      if (lightDef.color !== undefined) light.setColor(lightDef.color);
      if (lightDef.intensity !== undefined) light.setIntensity(lightDef.intensity);
      if (lightDef.range !== undefined) light.setRange(lightDef.range);
      if (((_lightDef$spot = lightDef.spot) == null ? void 0 : _lightDef$spot.innerConeAngle) !== undefined) {
        light.setInnerConeAngle(lightDef.spot.innerConeAngle);
      }
      if (((_lightDef$spot2 = lightDef.spot) == null ? void 0 : _lightDef$spot2.outerConeAngle) !== undefined) {
        light.setOuterConeAngle(lightDef.spot.outerConeAngle);
      }
      return light;
    });
    jsonDoc.json.nodes.forEach((nodeDef, nodeIndex) => {
      if (!nodeDef.extensions || !nodeDef.extensions[NAME$i]) return;
      const lightNodeDef = nodeDef.extensions[NAME$i];
      context.nodes[nodeIndex].setExtension(NAME$i, lights[lightNodeDef.light]);
    });
    return this;
  }
  /** @hidden */
  write(context) {
    const jsonDoc = context.jsonDoc;
    if (this.properties.size === 0) return this;
    const lightDefs = [];
    const lightIndexMap = new Map();
    for (const property of this.properties) {
      const light = property;
      const lightDef = {
        type: light.getType()
      };
      if (!MathUtils.eq(light.getColor(), [1, 1, 1])) lightDef.color = light.getColor();
      if (light.getIntensity() !== 1) lightDef.intensity = light.getIntensity();
      if (light.getRange() != null) lightDef.range = light.getRange();
      if (light.getName()) lightDef.name = light.getName();
      if (light.getType() === Light.Type.SPOT) {
        lightDef.spot = {
          innerConeAngle: light.getInnerConeAngle(),
          outerConeAngle: light.getOuterConeAngle()
        };
      }
      lightDefs.push(lightDef);
      lightIndexMap.set(light, lightDefs.length - 1);
    }
    this.document.getRoot().listNodes().forEach(node => {
      const light = node.getExtension(NAME$i);
      if (light) {
        const nodeIndex = context.nodeIndexMap.get(node);
        const nodeDef = jsonDoc.json.nodes[nodeIndex];
        nodeDef.extensions = nodeDef.extensions || {};
        nodeDef.extensions[NAME$i] = {
          light: lightIndexMap.get(light)
        };
      }
    });
    jsonDoc.json.extensions = jsonDoc.json.extensions || {};
    jsonDoc.json.extensions[NAME$i] = {
      lights: lightDefs
    };
    return this;
  }
}
KHRLightsPunctual.EXTENSION_NAME = NAME$i;

const {
  R: R$7,
  G: G$7,
  B: B$5
} = TextureChannel;
/**
 * Defines anisotropy (directionally-dependent reflections) on a PBR {@link Material}. See
 * {@link KHRMaterialsAnisotropy}.
 */
class Anisotropy extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_ANISOTROPY;
    this.propertyType = 'Anisotropy';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      anisotropyStrength: 0.0,
      anisotropyRotation: 0.0,
      anisotropyTexture: null,
      anisotropyTextureInfo: new TextureInfo(this.graph, 'anisotropyTextureInfo')
    });
  }
  /**********************************************************************************************
   * Anisotropy strength.
   */
  /** Anisotropy strength. */
  getAnisotropyStrength() {
    return this.get('anisotropyStrength');
  }
  /** Anisotropy strength. */
  setAnisotropyStrength(strength) {
    return this.set('anisotropyStrength', strength);
  }
  /**********************************************************************************************
   * Anisotropy rotation.
   */
  /** Anisotropy rotation; linear multiplier. */
  getAnisotropyRotation() {
    return this.get('anisotropyRotation');
  }
  /** Anisotropy rotation; linear multiplier. */
  setAnisotropyRotation(rotation) {
    return this.set('anisotropyRotation', rotation);
  }
  /**********************************************************************************************
   * Anisotropy texture.
   */
  /**
   * Anisotropy texture. Red and green channels represent the anisotropy
   * direction in [-1, 1] tangent, bitangent space, to be rotated by
   * anisotropyRotation. The blue channel contains strength as [0, 1] to be
   * multiplied by anisotropyStrength.
   */
  getAnisotropyTexture() {
    return this.getRef('anisotropyTexture');
  }
  /**
   * Settings affecting the material's use of its anisotropy texture. If no
   * texture is attached, {@link TextureInfo} is `null`.
   */
  getAnisotropyTextureInfo() {
    return this.getRef('anisotropyTexture') ? this.getRef('anisotropyTextureInfo') : null;
  }
  /** Anisotropy texture. See {@link Anisotropy.getAnisotropyTexture getAnisotropyTexture}. */
  setAnisotropyTexture(texture) {
    return this.setRef('anisotropyTexture', texture, {
      channels: R$7 | G$7 | B$5
    });
  }
}
Anisotropy.EXTENSION_NAME = KHR_MATERIALS_ANISOTROPY;

const NAME$h = KHR_MATERIALS_ANISOTROPY;
/**
 * [`KHR_materials_anisotropy`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_anisotropy/)
 * defines anisotropy (directionally-dependent reflections) on a PBR material.
 *
 * ![Illustration](/media/extensions/khr-materials-anisotropy.jpg)
 *
 * > _**Figure:** Effect of each color channel in the anisotropyTexture. Left
 * > to right: the full anisotropy texture, filling the red channel with black,
 * > filling the green channel with black, filling the blue channel with black.
 * > Source: [Khronos Group & Wayfair](https://github.com/KhronosGroup/glTF-Sample-Assets/tree/main/Models/AnisotropyBarnLamp)._
 *
 * This extension defines the anisotropic property of a material as observable with brushed metals
 * for instance. An asymmetric specular lobe model is introduced to allow for such phenomena. The
 * visually distinct feature of that lobe is the elongated appearance of the specular reflection.
 * For a single punctual light source, the specular reflection will eventually degenerate into a
 * zero width line in the limit, that is where the material is fully anisotropic, as opposed to be
 * fully isotropic in which case the specular reflection is radially symmetric.
 *
 * Properties:
 * - {@link Anisotropy}
 *
 * ### Example
 *
 * The `KHRMaterialsAnisotropy` class provides a single {@link ExtensionProperty} type, `Anisotropy`,
 * which may be attached to any {@link Material} instance. For example:
 *
 * ```typescript
 * import { KHRMaterialsAnisotropy, Anisotropy } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const anisotropyExtension = document.createExtension(KHRMaterialsAnisotropy);
 *
 * // Create an Anisotropy property.
 * const anisotropy = anisotropyExtension.createAnisotropy()
 * 	.setAnisotropyStrength(1.0)
 * 	.setAnisotropyRotation(Math.PI / 4);
 *
 * // Attach the property to a Material.
 * material.setExtension('KHR_materials_anisotropy', anisotropy);
 * ```
 */
class KHRMaterialsAnisotropy extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$h;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Anisotropy property for use on a {@link Material}. */
  createAnisotropy() {
    return new Anisotropy(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$h]) {
        const anisotropy = this.createAnisotropy();
        context.materials[materialIndex].setExtension(NAME$h, anisotropy);
        const anisotropyDef = materialDef.extensions[NAME$h];
        // Factors.
        if (anisotropyDef.anisotropyStrength !== undefined) {
          anisotropy.setAnisotropyStrength(anisotropyDef.anisotropyStrength);
        }
        if (anisotropyDef.anisotropyRotation !== undefined) {
          anisotropy.setAnisotropyRotation(anisotropyDef.anisotropyRotation);
        }
        // Textures.
        if (anisotropyDef.anisotropyTexture !== undefined) {
          const textureInfoDef = anisotropyDef.anisotropyTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          anisotropy.setAnisotropyTexture(texture);
          context.setTextureInfo(anisotropy.getAnisotropyTextureInfo(), textureInfoDef);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const anisotropy = material.getExtension(NAME$h);
      if (anisotropy) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        const anisotropyDef = materialDef.extensions[NAME$h] = {};
        if (anisotropy.getAnisotropyStrength() > 0) {
          anisotropyDef.anisotropyStrength = anisotropy.getAnisotropyStrength();
        }
        if (anisotropy.getAnisotropyRotation() !== 0) {
          anisotropyDef.anisotropyRotation = anisotropy.getAnisotropyRotation();
        }
        // Textures.
        if (anisotropy.getAnisotropyTexture()) {
          const texture = anisotropy.getAnisotropyTexture();
          const textureInfo = anisotropy.getAnisotropyTextureInfo();
          anisotropyDef.anisotropyTexture = context.createTextureInfoDef(texture, textureInfo);
        }
      }
    });
    return this;
  }
}
KHRMaterialsAnisotropy.EXTENSION_NAME = NAME$h;

const {
  R: R$6,
  G: G$6,
  B: B$4
} = TextureChannel;
/**
 * Defines clear coat for a PBR material. See {@link KHRMaterialsClearcoat}.
 */
class Clearcoat extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_CLEARCOAT;
    this.propertyType = 'Clearcoat';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      clearcoatFactor: 0,
      clearcoatTexture: null,
      clearcoatTextureInfo: new TextureInfo(this.graph, 'clearcoatTextureInfo'),
      clearcoatRoughnessFactor: 0,
      clearcoatRoughnessTexture: null,
      clearcoatRoughnessTextureInfo: new TextureInfo(this.graph, 'clearcoatRoughnessTextureInfo'),
      clearcoatNormalScale: 1,
      clearcoatNormalTexture: null,
      clearcoatNormalTextureInfo: new TextureInfo(this.graph, 'clearcoatNormalTextureInfo')
    });
  }
  /**********************************************************************************************
   * Clearcoat.
   */
  /** Clearcoat; linear multiplier. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */
  getClearcoatFactor() {
    return this.get('clearcoatFactor');
  }
  /** Clearcoat; linear multiplier. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */
  setClearcoatFactor(factor) {
    return this.set('clearcoatFactor', factor);
  }
  /**
   * Clearcoat texture; linear multiplier. The `r` channel of this texture specifies an amount
   * [0-1] of coating over the surface of the material, which may have its own roughness and
   * normal map properties.
   */
  getClearcoatTexture() {
    return this.getRef('clearcoatTexture');
  }
  /**
   * Settings affecting the material's use of its clearcoat texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getClearcoatTextureInfo() {
    return this.getRef('clearcoatTexture') ? this.getRef('clearcoatTextureInfo') : null;
  }
  /** Sets clearcoat texture. See {@link Clearcoat.getClearcoatTexture getClearcoatTexture}. */
  setClearcoatTexture(texture) {
    return this.setRef('clearcoatTexture', texture, {
      channels: R$6
    });
  }
  /**********************************************************************************************
   * Clearcoat roughness.
   */
  /**
   * Clearcoat roughness; linear multiplier.
   * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.
   */
  getClearcoatRoughnessFactor() {
    return this.get('clearcoatRoughnessFactor');
  }
  /**
   * Clearcoat roughness; linear multiplier.
   * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.
   */
  setClearcoatRoughnessFactor(factor) {
    return this.set('clearcoatRoughnessFactor', factor);
  }
  /**
   * Clearcoat roughness texture; linear multiplier. The `g` channel of this texture specifies
   * roughness, independent of the base layer's roughness.
   */
  getClearcoatRoughnessTexture() {
    return this.getRef('clearcoatRoughnessTexture');
  }
  /**
   * Settings affecting the material's use of its clearcoat roughness texture. If no texture is
   * attached, {@link TextureInfo} is `null`.
   */
  getClearcoatRoughnessTextureInfo() {
    return this.getRef('clearcoatRoughnessTexture') ? this.getRef('clearcoatRoughnessTextureInfo') : null;
  }
  /**
   * Sets clearcoat roughness texture.
   * See {@link Clearcoat.getClearcoatRoughnessTexture getClearcoatRoughnessTexture}.
   */
  setClearcoatRoughnessTexture(texture) {
    return this.setRef('clearcoatRoughnessTexture', texture, {
      channels: G$6
    });
  }
  /**********************************************************************************************
   * Clearcoat normals.
   */
  /** Clearcoat normal scale. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */
  getClearcoatNormalScale() {
    return this.get('clearcoatNormalScale');
  }
  /** Clearcoat normal scale. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */
  setClearcoatNormalScale(scale) {
    return this.set('clearcoatNormalScale', scale);
  }
  /**
   * Clearcoat normal map. Independent of the material base layer normal map.
   */
  getClearcoatNormalTexture() {
    return this.getRef('clearcoatNormalTexture');
  }
  /**
   * Settings affecting the material's use of its clearcoat normal texture. If no texture is
   * attached, {@link TextureInfo} is `null`.
   */
  getClearcoatNormalTextureInfo() {
    return this.getRef('clearcoatNormalTexture') ? this.getRef('clearcoatNormalTextureInfo') : null;
  }
  /** Sets clearcoat normal texture. See {@link Clearcoat.getClearcoatNormalTexture getClearcoatNormalTexture}. */
  setClearcoatNormalTexture(texture) {
    return this.setRef('clearcoatNormalTexture', texture, {
      channels: R$6 | G$6 | B$4
    });
  }
}
Clearcoat.EXTENSION_NAME = KHR_MATERIALS_CLEARCOAT;

const NAME$g = KHR_MATERIALS_CLEARCOAT;
/**
 * [KHR_materials_clearcoat](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_clearcoat/)
 * defines a clear coating on a glTF PBR material.
 *
 * ![Illustration](/media/extensions/khr-materials-clearcoat.png)
 *
 * > _**Figure:** Comparison of a carbon-fiber material without clearcoat (left) and with clearcoat
 * > (right). Source: [Filament](https://google.github.io/filament/Materials.html)._
 *
 * A clear coat is a common technique used in Physically-Based
 * Rendering for a protective layer applied to a base material.
 * Commonly used to represent car paint, carbon fiber, or thin lacquers.
 *
 * Properties:
 * - {@link Clearcoat}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRMaterialsClearcoat, Clearcoat } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const clearcoatExtension = document.createExtension(KHRMaterialsClearcoat);
 *
 * // Create Clearcoat property.
 * const clearcoat = clearcoatExtension.createClearcoat()
 *	.setClearcoatFactor(1.0);
 *
 * // Assign to a Material.
 * material.setExtension('KHR_materials_clearcoat', clearcoat);
 * ```
 */
class KHRMaterialsClearcoat extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$g;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Clearcoat property for use on a {@link Material}. */
  createClearcoat() {
    return new Clearcoat(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$g]) {
        const clearcoat = this.createClearcoat();
        context.materials[materialIndex].setExtension(NAME$g, clearcoat);
        const clearcoatDef = materialDef.extensions[NAME$g];
        // Factors.
        if (clearcoatDef.clearcoatFactor !== undefined) {
          clearcoat.setClearcoatFactor(clearcoatDef.clearcoatFactor);
        }
        if (clearcoatDef.clearcoatRoughnessFactor !== undefined) {
          clearcoat.setClearcoatRoughnessFactor(clearcoatDef.clearcoatRoughnessFactor);
        }
        // Textures.
        if (clearcoatDef.clearcoatTexture !== undefined) {
          const textureInfoDef = clearcoatDef.clearcoatTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          clearcoat.setClearcoatTexture(texture);
          context.setTextureInfo(clearcoat.getClearcoatTextureInfo(), textureInfoDef);
        }
        if (clearcoatDef.clearcoatRoughnessTexture !== undefined) {
          const textureInfoDef = clearcoatDef.clearcoatRoughnessTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          clearcoat.setClearcoatRoughnessTexture(texture);
          context.setTextureInfo(clearcoat.getClearcoatRoughnessTextureInfo(), textureInfoDef);
        }
        if (clearcoatDef.clearcoatNormalTexture !== undefined) {
          const textureInfoDef = clearcoatDef.clearcoatNormalTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          clearcoat.setClearcoatNormalTexture(texture);
          context.setTextureInfo(clearcoat.getClearcoatNormalTextureInfo(), textureInfoDef);
          if (textureInfoDef.scale !== undefined) {
            clearcoat.setClearcoatNormalScale(textureInfoDef.scale);
          }
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const clearcoat = material.getExtension(NAME$g);
      if (clearcoat) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        const clearcoatDef = materialDef.extensions[NAME$g] = {
          clearcoatFactor: clearcoat.getClearcoatFactor(),
          clearcoatRoughnessFactor: clearcoat.getClearcoatRoughnessFactor()
        };
        // Textures.
        if (clearcoat.getClearcoatTexture()) {
          const texture = clearcoat.getClearcoatTexture();
          const textureInfo = clearcoat.getClearcoatTextureInfo();
          clearcoatDef.clearcoatTexture = context.createTextureInfoDef(texture, textureInfo);
        }
        if (clearcoat.getClearcoatRoughnessTexture()) {
          const texture = clearcoat.getClearcoatRoughnessTexture();
          const textureInfo = clearcoat.getClearcoatRoughnessTextureInfo();
          clearcoatDef.clearcoatRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);
        }
        if (clearcoat.getClearcoatNormalTexture()) {
          const texture = clearcoat.getClearcoatNormalTexture();
          const textureInfo = clearcoat.getClearcoatNormalTextureInfo();
          clearcoatDef.clearcoatNormalTexture = context.createTextureInfoDef(texture, textureInfo);
          if (clearcoat.getClearcoatNormalScale() !== 1) {
            clearcoatDef.clearcoatNormalTexture.scale = clearcoat.getClearcoatNormalScale();
          }
        }
      }
    });
    return this;
  }
}
KHRMaterialsClearcoat.EXTENSION_NAME = NAME$g;

const {
  R: R$5,
  G: G$5,
  B: B$3,
  A: A$3
} = TextureChannel;
/**
 * Defines diffuse transmission on a PBR {@link Material}. See {@link KHRMaterialsDiffuseTransmission}.
 *
 * @experimental KHR_materials_diffuse_transmission is not yet ratified by the Khronos Group.
 */
class DiffuseTransmission extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_DIFFUSE_TRANSMISSION;
    this.propertyType = 'DiffuseTransmission';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      diffuseTransmissionFactor: 0.0,
      diffuseTransmissionTexture: null,
      diffuseTransmissionTextureInfo: new TextureInfo(this.graph, 'diffuseTransmissionTextureInfo'),
      diffuseTransmissionColorFactor: [1.0, 1.0, 1.0],
      diffuseTransmissionColorTexture: null,
      diffuseTransmissionColorTextureInfo: new TextureInfo(this.graph, 'diffuseTransmissionColorTextureInfo')
    });
  }
  /**********************************************************************************************
   * Diffuse transmission.
   */
  /**
   * Percentage of reflected, non-specularly reflected light that is transmitted through the
   * surface via the Lambertian diffuse transmission, i.e., the strength of the diffuse
   * transmission effect.
   */
  getDiffuseTransmissionFactor() {
    return this.get('diffuseTransmissionFactor');
  }
  /**
   * Percentage of reflected, non-specularly reflected light that is transmitted through the
   * surface via the Lambertian diffuse transmission, i.e., the strength of the diffuse
   * transmission effect.
   */
  setDiffuseTransmissionFactor(factor) {
    return this.set('diffuseTransmissionFactor', factor);
  }
  /**
   * Texture that defines the strength of the diffuse transmission effect, stored in the alpha (A)
   * channel. Will be multiplied by the diffuseTransmissionFactor.
   */
  getDiffuseTransmissionTexture() {
    return this.getRef('diffuseTransmissionTexture');
  }
  /**
   * Settings affecting the material's use of its diffuse transmission texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getDiffuseTransmissionTextureInfo() {
    return this.getRef('diffuseTransmissionTexture') ? this.getRef('diffuseTransmissionTextureInfo') : null;
  }
  /**
   * Texture that defines the strength of the diffuse transmission effect, stored in the alpha (A)
   * channel. Will be multiplied by the diffuseTransmissionFactor.
   */
  setDiffuseTransmissionTexture(texture) {
    return this.setRef('diffuseTransmissionTexture', texture, {
      channels: A$3
    });
  }
  /**********************************************************************************************
   * Diffuse transmission color.
   */
  /** Color of the transmitted light; Linear-sRGB components. */
  getDiffuseTransmissionColorFactor() {
    return this.get('diffuseTransmissionColorFactor');
  }
  /** Color of the transmitted light; Linear-sRGB components. */
  setDiffuseTransmissionColorFactor(factor) {
    return this.set('diffuseTransmissionColorFactor', factor);
  }
  /**
   * Texture that defines the color of the transmitted light, stored in the RGB channels and
   * encoded in sRGB. This texture will be multiplied by diffuseTransmissionColorFactor.
   */
  getDiffuseTransmissionColorTexture() {
    return this.getRef('diffuseTransmissionColorTexture');
  }
  /**
   * Settings affecting the material's use of its diffuse transmission color texture. If no
   * texture is attached, {@link TextureInfo} is `null`.
   */
  getDiffuseTransmissionColorTextureInfo() {
    return this.getRef('diffuseTransmissionColorTexture') ? this.getRef('diffuseTransmissionColorTextureInfo') : null;
  }
  /**
   * Texture that defines the color of the transmitted light, stored in the RGB channels and
   * encoded in sRGB. This texture will be multiplied by diffuseTransmissionColorFactor.
   */
  setDiffuseTransmissionColorTexture(texture) {
    return this.setRef('diffuseTransmissionColorTexture', texture, {
      channels: R$5 | G$5 | B$3
    });
  }
}
DiffuseTransmission.EXTENSION_NAME = KHR_MATERIALS_DIFFUSE_TRANSMISSION;

const NAME$f = KHR_MATERIALS_DIFFUSE_TRANSMISSION;
/**
 * [KHR_materials_diffuse_transmission](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_diffuse_transmission/)
 * defines diffuse transmission on a glTF PBR material.
 *
 * ![Illustration](/media/extensions/khr-materials-diffuse-transmission.png)
 *
 * > _**Figure:** Sphere using `KHR_materials_diffuse_transmission` with varying roughness (0.0, 0.2, 0.4).
 * > Source: Khronos Group._
 *
 * Adds a Lambertian diffuse transmission BSDF to the metallic-roughness
 * material. Thin, dielectric objects like leaves or paper diffusely transmit
 * incoming light to the opposite side of the surface. For optically thick
 * media (volumes) with short scattering distances and therefore dense
 * scattering behavior, a diffuse transmission lobe is a phenomenological
 * plausible and cheap approximation.
 *
 * Properties:
 * - {@link DiffuseTransmission}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRMaterialsDiffuseTransmission, DiffuseTransmission } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const diffuseTransmissionExtension = document.createExtension(KHRMaterialsDiffuseTransmission);
 *
 * // Create DiffuseTransmission property.
 * const diffuseTransmission = diffuseTransmission.createDiffuseTransmission()
 *	.setDiffuseTransmissionFactor(1.0);
 *
 * // Assign to a Material.
 * material.setExtension('KHR_materials_diffuse_transmission', diffuseTransmission);
 * ```
 *
 * @experimental KHR_materials_diffuse_transmission is not yet ratified by the Khronos Group.
 */
class KHRMaterialsDiffuseTransmission extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$f;
  }
  /** Creates a new DiffuseTransmission property for use on a {@link Material}. */
  createDiffuseTransmission() {
    return new DiffuseTransmission(this.document.getGraph());
  }
  /** @hidden */
  read(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$f]) {
        const transmission = this.createDiffuseTransmission();
        context.materials[materialIndex].setExtension(NAME$f, transmission);
        const transmissionDef = materialDef.extensions[NAME$f];
        // Factors.
        if (transmissionDef.diffuseTransmissionFactor !== undefined) {
          transmission.setDiffuseTransmissionFactor(transmissionDef.diffuseTransmissionFactor);
        }
        if (transmissionDef.diffuseTransmissionColorFactor !== undefined) {
          transmission.setDiffuseTransmissionColorFactor(transmissionDef.diffuseTransmissionColorFactor);
        }
        // Textures.
        if (transmissionDef.diffuseTransmissionTexture !== undefined) {
          const textureInfoDef = transmissionDef.diffuseTransmissionTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          transmission.setDiffuseTransmissionTexture(texture);
          context.setTextureInfo(transmission.getDiffuseTransmissionTextureInfo(), textureInfoDef);
        }
        if (transmissionDef.diffuseTransmissionColorTexture !== undefined) {
          const textureInfoDef = transmissionDef.diffuseTransmissionColorTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          transmission.setDiffuseTransmissionColorTexture(texture);
          context.setTextureInfo(transmission.getDiffuseTransmissionColorTextureInfo(), textureInfoDef);
        }
      }
    });
    return this;
  }
  /** @hidden */
  write(context) {
    const jsonDoc = context.jsonDoc;
    for (const material of this.document.getRoot().listMaterials()) {
      const transmission = material.getExtension(NAME$f);
      if (!transmission) continue;
      const materialIndex = context.materialIndexMap.get(material);
      const materialDef = jsonDoc.json.materials[materialIndex];
      materialDef.extensions = materialDef.extensions || {};
      // Factors.
      const transmissionDef = materialDef.extensions[NAME$f] = {
        diffuseTransmissionFactor: transmission.getDiffuseTransmissionFactor(),
        diffuseTransmissionColorFactor: transmission.getDiffuseTransmissionColorFactor()
      };
      // Textures.
      if (transmission.getDiffuseTransmissionTexture()) {
        const texture = transmission.getDiffuseTransmissionTexture();
        const textureInfo = transmission.getDiffuseTransmissionTextureInfo();
        transmissionDef.diffuseTransmissionTexture = context.createTextureInfoDef(texture, textureInfo);
      }
      if (transmission.getDiffuseTransmissionColorTexture()) {
        const texture = transmission.getDiffuseTransmissionColorTexture();
        const textureInfo = transmission.getDiffuseTransmissionColorTextureInfo();
        transmissionDef.diffuseTransmissionColorTexture = context.createTextureInfoDef(texture, textureInfo);
      }
    }
    return this;
  }
}
KHRMaterialsDiffuseTransmission.EXTENSION_NAME = NAME$f;

/**
 * Defines dispersion for a PBR {@link Material}. See {@link KHRMaterialsDispersion}.
 */
class Dispersion extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_DISPERSION;
    this.propertyType = 'Dispersion';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      dispersion: 0
    });
  }
  /**********************************************************************************************
   * Dispersion.
   */
  /** Dispersion. */
  getDispersion() {
    return this.get('dispersion');
  }
  /** Dispersion. */
  setDispersion(dispersion) {
    return this.set('dispersion', dispersion);
  }
}
Dispersion.EXTENSION_NAME = KHR_MATERIALS_DISPERSION;

const NAME$e = KHR_MATERIALS_DISPERSION;
/**
 * [KHR_materials_dispersion](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_dispersion/)
 * defines dispersion on a glTF PBR material.
 *
 * ![illustration](/media/extensions/khr-materials-dispersion.jpg)
 *
 * > _**Figure:** Prisms demonstrating volumetric refraction and dispersion, for varying
 * > values of dispersion and IOR. Source: Khronos Group, rendered in Adobe Stager._
 *
 * Dispersion enables configuring the strength of the angular separation of colors (chromatic
 * aberration) transmitting through a relatively clear volume.  It is an enhancement to the
 * default `KHR_materials_volume` transmission model which assumes no dispersion.
 *
 * Properties:
 * - {@link Dispersion}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRMaterialsDispersion, Dispersion } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const dispersionExtension = document.createExtension(KHRMaterialsDispersion);
 *
 * // Create Dispersion property.
 * const dispersion = dispersionExtension.createDispersion().setDispersion(1.0);
 *
 * // Assign to a Material.
 * material.setExtension('KHR_materials_dispersion', dispersion);
 * ```
 */
class KHRMaterialsDispersion extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$e;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Dispersion property for use on a {@link Material}. */
  createDispersion() {
    return new Dispersion(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$e]) {
        const dispersion = this.createDispersion();
        context.materials[materialIndex].setExtension(NAME$e, dispersion);
        const dispersionDef = materialDef.extensions[NAME$e];
        // Factors.
        if (dispersionDef.dispersion !== undefined) {
          dispersion.setDispersion(dispersionDef.dispersion);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const dispersion = material.getExtension(NAME$e);
      if (dispersion) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        materialDef.extensions[NAME$e] = {
          dispersion: dispersion.getDispersion()
        };
      }
    });
    return this;
  }
}
KHRMaterialsDispersion.EXTENSION_NAME = NAME$e;

/**
 * Defines emissive strength for a PBR {@link Material}, allowing high-dynamic-range
 * (HDR) emissive materials. See {@link KHRMaterialsEmissiveStrength}.
 */
class EmissiveStrength extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_EMISSIVE_STRENGTH;
    this.propertyType = 'EmissiveStrength';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      emissiveStrength: 1.0
    });
  }
  /**********************************************************************************************
   * EmissiveStrength.
   */
  /** EmissiveStrength. */
  getEmissiveStrength() {
    return this.get('emissiveStrength');
  }
  /** EmissiveStrength. */
  setEmissiveStrength(strength) {
    return this.set('emissiveStrength', strength);
  }
}
EmissiveStrength.EXTENSION_NAME = KHR_MATERIALS_EMISSIVE_STRENGTH;

const NAME$d = KHR_MATERIALS_EMISSIVE_STRENGTH;
/**
 * [KHR_materials_emissive_strength](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/)
 * defines emissive strength and enables high-dynamic-range (HDR) emissive materials.
 *
 * ![Illustration](/media/extensions/khr-materials-emissive-strength.jpg)
 *
 * > _**Figure:** Cubes with emissive color #59BCF3 and emissive strength
 * > increasing from 1 to 256 nits, left to right. Rendered in [three.js](https://threejs.org/),
 * > with independent point lighting and a bloom effect.
 * > Source: [Don McCurdy](https://www.donmccurdy.com/2024/04/27/emission-and-bloom/)._
 *
 * The core glTF 2.0 material model includes {@link Material.setEmissiveFactor `emissiveFactor`}
 * and {@link Material.setEmissiveTexture `emissiveTexture`} to control the color and intensity
 * of the light being emitted by the material, clamped to the range [0.0, 1.0]. However, in
 * PBR environments with HDR reflections and lighting, stronger emission effects may be desirable.
 *
 * In this extension, a new {@link EmissiveStrength.setEmissiveStrength `emissiveStrength`} scalar
 * factor is supplied, which governs the upper limit of emissive strength per material and may be
 * given arbitrarily high values.
 *
 * For implementations where a physical light unit is needed, the units for the multiplicative
 * product of the emissive texture and factor are candela per square meter (cd / m2), sometimes
 * called _nits_. Many realtime rendering engines simplify this calculation by assuming that an
 * emissive factor of 1.0 results in a fully exposed pixel.
 *
 * Properties:
 * - {@link EmissiveStrength}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRMaterialsEmissiveStrength, EmissiveStrength } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const emissiveStrengthExtension = document.createExtension(KHRMaterialsEmissiveStrength);
 *
 * // Create EmissiveStrength property.
 * const emissiveStrength = emissiveStrengthExtension
 * 	.createEmissiveStrength().setEmissiveStrength(5.0);
 *
 * // Assign to a Material.
 * material.setExtension('KHR_materials_emissive_strength', emissiveStrength);
 * ```
 */
class KHRMaterialsEmissiveStrength extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$d;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new EmissiveStrength property for use on a {@link Material}. */
  createEmissiveStrength() {
    return new EmissiveStrength(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$d]) {
        const emissiveStrength = this.createEmissiveStrength();
        context.materials[materialIndex].setExtension(NAME$d, emissiveStrength);
        const emissiveStrengthDef = materialDef.extensions[NAME$d];
        // Factors.
        if (emissiveStrengthDef.emissiveStrength !== undefined) {
          emissiveStrength.setEmissiveStrength(emissiveStrengthDef.emissiveStrength);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const emissiveStrength = material.getExtension(NAME$d);
      if (emissiveStrength) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        materialDef.extensions[NAME$d] = {
          emissiveStrength: emissiveStrength.getEmissiveStrength()
        };
      }
    });
    return this;
  }
}
KHRMaterialsEmissiveStrength.EXTENSION_NAME = NAME$d;

/**
 * Defines index of refraction for a PBR {@link Material}. See {@link KHRMaterialsIOR}.
 */
class IOR extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_IOR;
    this.propertyType = 'IOR';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      ior: 1.5
    });
  }
  /**********************************************************************************************
   * IOR.
   */
  /** IOR. */
  getIOR() {
    return this.get('ior');
  }
  /** IOR. */
  setIOR(ior) {
    return this.set('ior', ior);
  }
}
IOR.EXTENSION_NAME = KHR_MATERIALS_IOR;

const NAME$c = KHR_MATERIALS_IOR;
/**
 * [KHR_materials_ior](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_ior/)
 * defines index of refraction on a glTF PBR material.
 *
 * The dielectric BRDF of the metallic-roughness material in glTF uses a fixed value of 1.5 for the
 * index of refraction. This is a good fit for many plastics and glass, but not for other materials
 * like water or asphalt, sapphire or diamond. `KHR_materials_ior` allows users to set the index of
 * refraction to a certain value.
 *
 * Properties:
 * - {@link IOR}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRMaterialsIOR, IOR } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const iorExtension = document.createExtension(KHRMaterialsIOR);
 *
 * // Create IOR property.
 * const ior = iorExtension.createIOR().setIOR(1.0);
 *
 * // Assign to a Material.
 * material.setExtension('KHR_materials_ior', ior);
 * ```
 */
class KHRMaterialsIOR extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$c;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new IOR property for use on a {@link Material}. */
  createIOR() {
    return new IOR(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$c]) {
        const ior = this.createIOR();
        context.materials[materialIndex].setExtension(NAME$c, ior);
        const iorDef = materialDef.extensions[NAME$c];
        // Factors.
        if (iorDef.ior !== undefined) {
          ior.setIOR(iorDef.ior);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const ior = material.getExtension(NAME$c);
      if (ior) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        materialDef.extensions[NAME$c] = {
          ior: ior.getIOR()
        };
      }
    });
    return this;
  }
}
KHRMaterialsIOR.EXTENSION_NAME = NAME$c;

const {
  R: R$4,
  G: G$4
} = TextureChannel;
/**
 * Defines iridescence (thin film interference) on a PBR {@link Material}. See {@link KHRMaterialsIridescence}.
 */
class Iridescence extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_IRIDESCENCE;
    this.propertyType = 'Iridescence';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      iridescenceFactor: 0.0,
      iridescenceTexture: null,
      iridescenceTextureInfo: new TextureInfo(this.graph, 'iridescenceTextureInfo'),
      iridescenceIOR: 1.3,
      iridescenceThicknessMinimum: 100,
      iridescenceThicknessMaximum: 400,
      iridescenceThicknessTexture: null,
      iridescenceThicknessTextureInfo: new TextureInfo(this.graph, 'iridescenceThicknessTextureInfo')
    });
  }
  /**********************************************************************************************
   * Iridescence.
   */
  /** Iridescence; linear multiplier. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */
  getIridescenceFactor() {
    return this.get('iridescenceFactor');
  }
  /** Iridescence; linear multiplier. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */
  setIridescenceFactor(factor) {
    return this.set('iridescenceFactor', factor);
  }
  /**
   * Iridescence intensity.
   *
   * Only the red (R) channel is used for iridescence intensity, but this texture may optionally
   * be packed with additional data in the other channels.
   */
  getIridescenceTexture() {
    return this.getRef('iridescenceTexture');
  }
  /**
   * Settings affecting the material's use of its iridescence texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getIridescenceTextureInfo() {
    return this.getRef('iridescenceTexture') ? this.getRef('iridescenceTextureInfo') : null;
  }
  /** Iridescence intensity. See {@link Iridescence.getIridescenceTexture getIridescenceTexture}. */
  setIridescenceTexture(texture) {
    return this.setRef('iridescenceTexture', texture, {
      channels: R$4
    });
  }
  /**********************************************************************************************
   * Iridescence IOR.
   */
  /** Index of refraction of the dielectric thin-film layer. */
  getIridescenceIOR() {
    return this.get('iridescenceIOR');
  }
  /** Index of refraction of the dielectric thin-film layer. */
  setIridescenceIOR(ior) {
    return this.set('iridescenceIOR', ior);
  }
  /**********************************************************************************************
   * Iridescence thickness.
   */
  /** Minimum thickness of the thin-film layer, in nanometers (nm). */
  getIridescenceThicknessMinimum() {
    return this.get('iridescenceThicknessMinimum');
  }
  /** Minimum thickness of the thin-film layer, in nanometers (nm). */
  setIridescenceThicknessMinimum(thickness) {
    return this.set('iridescenceThicknessMinimum', thickness);
  }
  /** Maximum thickness of the thin-film layer, in nanometers (nm). */
  getIridescenceThicknessMaximum() {
    return this.get('iridescenceThicknessMaximum');
  }
  /** Maximum thickness of the thin-film layer, in nanometers (nm). */
  setIridescenceThicknessMaximum(thickness) {
    return this.set('iridescenceThicknessMaximum', thickness);
  }
  /**
   * The green channel of this texture defines the thickness of the
   * thin-film layer by blending between the minimum and maximum thickness.
   */
  getIridescenceThicknessTexture() {
    return this.getRef('iridescenceThicknessTexture');
  }
  /**
   * Settings affecting the material's use of its iridescence thickness texture.
   * If no texture is attached, {@link TextureInfo} is `null`.
   */
  getIridescenceThicknessTextureInfo() {
    return this.getRef('iridescenceThicknessTexture') ? this.getRef('iridescenceThicknessTextureInfo') : null;
  }
  /**
   * Sets iridescence thickness texture.
   * See {@link Iridescence.getIridescenceThicknessTexture getIridescenceThicknessTexture}.
   */
  setIridescenceThicknessTexture(texture) {
    return this.setRef('iridescenceThicknessTexture', texture, {
      channels: G$4
    });
  }
}
Iridescence.EXTENSION_NAME = KHR_MATERIALS_IRIDESCENCE;

const NAME$b = KHR_MATERIALS_IRIDESCENCE;
/**
 * [`KHR_materials_iridescence`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_iridescence/)
 * defines iridescence (thin film interference) on a PBR material.
 *
 * ![Illustration](/media/extensions/khr-materials-iridescence.png)
 *
 * > _**Figure:** Varying levels of iridescence IOR values.
 * > Source: [Khronos Group](https://github.com/KhronosGroup/gltf/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence)._
 *
 * Iridescence describes an effect where hue varies depending on the viewing
 * angle and illumination angle: A thin-film of a semi-transparent layer
 * results in inter-reflections and due to thin-film interference, certain
 * wavelengths get absorbed or amplified. Iridescence can be seen on soap
 * bubbles, oil films, or on the wings of many insects. With this extension,
 * thickness and index of refraction (IOR) of the thin-film can be specified,
 * enabling iridescent materials.
 *
 * Properties:
 * - {@link Iridescence}
 *
 * ### Example
 *
 * The `KHRMaterialsIridescence` class provides a single {@link ExtensionProperty} type, `Iridescence`,
 * which may be attached to any {@link Material} instance. For example:
 *
 * ```typescript
 * import { KHRMaterialsIridescence, Iridescence } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const iridescenceExtension = document.createExtension(KHRMaterialsIridescence);
 *
 * // Create an Iridescence property.
 * const iridescence = iridescenceExtension.createIridescence()
 * 	.setIridescenceFactor(1.0)
 * 	.setIridescenceIOR(1.8);
 *
 * // Attach the property to a Material.
 * material.setExtension('KHR_materials_iridescence', iridescence);
 * ```
 */
class KHRMaterialsIridescence extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$b;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Iridescence property for use on a {@link Material}. */
  createIridescence() {
    return new Iridescence(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$b]) {
        const iridescence = this.createIridescence();
        context.materials[materialIndex].setExtension(NAME$b, iridescence);
        const iridescenceDef = materialDef.extensions[NAME$b];
        // Factors.
        if (iridescenceDef.iridescenceFactor !== undefined) {
          iridescence.setIridescenceFactor(iridescenceDef.iridescenceFactor);
        }
        if (iridescenceDef.iridescenceIor !== undefined) {
          iridescence.setIridescenceIOR(iridescenceDef.iridescenceIor);
        }
        if (iridescenceDef.iridescenceThicknessMinimum !== undefined) {
          iridescence.setIridescenceThicknessMinimum(iridescenceDef.iridescenceThicknessMinimum);
        }
        if (iridescenceDef.iridescenceThicknessMaximum !== undefined) {
          iridescence.setIridescenceThicknessMaximum(iridescenceDef.iridescenceThicknessMaximum);
        }
        // Textures.
        if (iridescenceDef.iridescenceTexture !== undefined) {
          const textureInfoDef = iridescenceDef.iridescenceTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          iridescence.setIridescenceTexture(texture);
          context.setTextureInfo(iridescence.getIridescenceTextureInfo(), textureInfoDef);
        }
        if (iridescenceDef.iridescenceThicknessTexture !== undefined) {
          const textureInfoDef = iridescenceDef.iridescenceThicknessTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          iridescence.setIridescenceThicknessTexture(texture);
          context.setTextureInfo(iridescence.getIridescenceThicknessTextureInfo(), textureInfoDef);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const iridescence = material.getExtension(NAME$b);
      if (iridescence) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        const iridescenceDef = materialDef.extensions[NAME$b] = {};
        if (iridescence.getIridescenceFactor() > 0) {
          iridescenceDef.iridescenceFactor = iridescence.getIridescenceFactor();
        }
        if (iridescence.getIridescenceIOR() !== 1.3) {
          iridescenceDef.iridescenceIor = iridescence.getIridescenceIOR();
        }
        if (iridescence.getIridescenceThicknessMinimum() !== 100) {
          iridescenceDef.iridescenceThicknessMinimum = iridescence.getIridescenceThicknessMinimum();
        }
        if (iridescence.getIridescenceThicknessMaximum() !== 400) {
          iridescenceDef.iridescenceThicknessMaximum = iridescence.getIridescenceThicknessMaximum();
        }
        // Textures.
        if (iridescence.getIridescenceTexture()) {
          const texture = iridescence.getIridescenceTexture();
          const textureInfo = iridescence.getIridescenceTextureInfo();
          iridescenceDef.iridescenceTexture = context.createTextureInfoDef(texture, textureInfo);
        }
        if (iridescence.getIridescenceThicknessTexture()) {
          const texture = iridescence.getIridescenceThicknessTexture();
          const textureInfo = iridescence.getIridescenceThicknessTextureInfo();
          iridescenceDef.iridescenceThicknessTexture = context.createTextureInfoDef(texture, textureInfo);
        }
      }
    });
    return this;
  }
}
KHRMaterialsIridescence.EXTENSION_NAME = NAME$b;

const {
  R: R$3,
  G: G$3,
  B: B$2,
  A: A$2
} = TextureChannel;
/**
 * Converts a {@link Material} to a spec/gloss workflow. See {@link KHRMaterialsPBRSpecularGlossiness}.
 */
class PBRSpecularGlossiness extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
    this.propertyType = 'PBRSpecularGlossiness';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      diffuseFactor: [1.0, 1.0, 1.0, 1.0],
      diffuseTexture: null,
      diffuseTextureInfo: new TextureInfo(this.graph, 'diffuseTextureInfo'),
      specularFactor: [1.0, 1.0, 1.0],
      glossinessFactor: 1.0,
      specularGlossinessTexture: null,
      specularGlossinessTextureInfo: new TextureInfo(this.graph, 'specularGlossinessTextureInfo')
    });
  }
  /**********************************************************************************************
   * Diffuse.
   */
  /** Diffuse; Linear-sRGB components. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */
  getDiffuseFactor() {
    return this.get('diffuseFactor');
  }
  /** Diffuse; Linear-sRGB components. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */
  setDiffuseFactor(factor) {
    return this.set('diffuseFactor', factor);
  }
  /**
   * Diffuse texture; sRGB. Alternative to baseColorTexture, used within the
   * spec/gloss PBR workflow.
   */
  getDiffuseTexture() {
    return this.getRef('diffuseTexture');
  }
  /**
   * Settings affecting the material's use of its diffuse texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getDiffuseTextureInfo() {
    return this.getRef('diffuseTexture') ? this.getRef('diffuseTextureInfo') : null;
  }
  /** Sets diffuse texture. See {@link PBRSpecularGlossiness.getDiffuseTexture getDiffuseTexture}. */
  setDiffuseTexture(texture) {
    return this.setRef('diffuseTexture', texture, {
      channels: R$3 | G$3 | B$2 | A$2,
      isColor: true
    });
  }
  /**********************************************************************************************
   * Specular.
   */
  /** Specular; linear multiplier. */
  getSpecularFactor() {
    return this.get('specularFactor');
  }
  /** Specular; linear multiplier. */
  setSpecularFactor(factor) {
    return this.set('specularFactor', factor);
  }
  /**********************************************************************************************
   * Glossiness.
   */
  /** Glossiness; linear multiplier. */
  getGlossinessFactor() {
    return this.get('glossinessFactor');
  }
  /** Glossiness; linear multiplier. */
  setGlossinessFactor(factor) {
    return this.set('glossinessFactor', factor);
  }
  /**********************************************************************************************
   * Specular/Glossiness.
   */
  /** Spec/gloss texture; linear multiplier. */
  getSpecularGlossinessTexture() {
    return this.getRef('specularGlossinessTexture');
  }
  /**
   * Settings affecting the material's use of its spec/gloss texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getSpecularGlossinessTextureInfo() {
    return this.getRef('specularGlossinessTexture') ? this.getRef('specularGlossinessTextureInfo') : null;
  }
  /** Spec/gloss texture; linear multiplier. */
  setSpecularGlossinessTexture(texture) {
    return this.setRef('specularGlossinessTexture', texture, {
      channels: R$3 | G$3 | B$2 | A$2
    });
  }
}
PBRSpecularGlossiness.EXTENSION_NAME = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

const NAME$a = KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
/**
 * [`KHR_materials_pbrSpecularGlossiness`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness/)
 * converts a PBR material from the default metal/rough workflow to a spec/gloss workflow.
 *
 * > _**NOTICE:** The spec/gloss workflow does _not_ support other PBR extensions such as clearcoat,
 * > transmission, IOR, etc. For the complete PBR feature set and specular data, use the
 * > {@link KHRMaterialsSpecular} extension instead, which provides specular data within a metal/rough
 * > workflow._
 *
 * ![Illustration](/media/extensions/khr-material-pbr-specular-glossiness.png)
 *
 * > _**Figure:** Components of a PBR spec/gloss material. Source: Khronos Group._
 *
 * Properties:
 * - {@link PBRSpecularGlossiness}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRMaterialsPBRSpecularGlossiness } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const specGlossExtension = document.createExtension(KHRMaterialsPBRSpecularGlossiness);
 *
 * // Create a PBRSpecularGlossiness property.
 * const specGloss = specGlossExtension.createPBRSpecularGlossiness()
 * 	.setSpecularFactor(1.0);
 *
 * // // Assign to a Material.
 * material.setExtension('KHR_materials_pbrSpecularGlossiness', specGloss);
 * ```
 */
class KHRMaterialsPBRSpecularGlossiness extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$a;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new PBRSpecularGlossiness property for use on a {@link Material}. */
  createPBRSpecularGlossiness() {
    return new PBRSpecularGlossiness(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$a]) {
        const specGloss = this.createPBRSpecularGlossiness();
        context.materials[materialIndex].setExtension(NAME$a, specGloss);
        const specGlossDef = materialDef.extensions[NAME$a];
        // Factors.
        if (specGlossDef.diffuseFactor !== undefined) {
          specGloss.setDiffuseFactor(specGlossDef.diffuseFactor);
        }
        if (specGlossDef.specularFactor !== undefined) {
          specGloss.setSpecularFactor(specGlossDef.specularFactor);
        }
        if (specGlossDef.glossinessFactor !== undefined) {
          specGloss.setGlossinessFactor(specGlossDef.glossinessFactor);
        }
        // Textures.
        if (specGlossDef.diffuseTexture !== undefined) {
          const textureInfoDef = specGlossDef.diffuseTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          specGloss.setDiffuseTexture(texture);
          context.setTextureInfo(specGloss.getDiffuseTextureInfo(), textureInfoDef);
        }
        if (specGlossDef.specularGlossinessTexture !== undefined) {
          const textureInfoDef = specGlossDef.specularGlossinessTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          specGloss.setSpecularGlossinessTexture(texture);
          context.setTextureInfo(specGloss.getSpecularGlossinessTextureInfo(), textureInfoDef);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const specGloss = material.getExtension(NAME$a);
      if (specGloss) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        const specGlossDef = materialDef.extensions[NAME$a] = {
          diffuseFactor: specGloss.getDiffuseFactor(),
          specularFactor: specGloss.getSpecularFactor(),
          glossinessFactor: specGloss.getGlossinessFactor()
        };
        // Textures.
        if (specGloss.getDiffuseTexture()) {
          const texture = specGloss.getDiffuseTexture();
          const textureInfo = specGloss.getDiffuseTextureInfo();
          specGlossDef.diffuseTexture = context.createTextureInfoDef(texture, textureInfo);
        }
        if (specGloss.getSpecularGlossinessTexture()) {
          const texture = specGloss.getSpecularGlossinessTexture();
          const textureInfo = specGloss.getSpecularGlossinessTextureInfo();
          specGlossDef.specularGlossinessTexture = context.createTextureInfoDef(texture, textureInfo);
        }
      }
    });
    return this;
  }
}
KHRMaterialsPBRSpecularGlossiness.EXTENSION_NAME = NAME$a;

const {
  R: R$2,
  G: G$2,
  B: B$1,
  A: A$1
} = TextureChannel;
/**
 * Defines sheen on a PBR {@link Material}. See {@link KHRMaterialsSheen}.
 */
class Sheen extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_SHEEN;
    this.propertyType = 'Sheen';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      sheenColorFactor: [0.0, 0.0, 0.0],
      sheenColorTexture: null,
      sheenColorTextureInfo: new TextureInfo(this.graph, 'sheenColorTextureInfo'),
      sheenRoughnessFactor: 0.0,
      sheenRoughnessTexture: null,
      sheenRoughnessTextureInfo: new TextureInfo(this.graph, 'sheenRoughnessTextureInfo')
    });
  }
  /**********************************************************************************************
   * Sheen color.
   */
  /** Sheen; linear multiplier. */
  getSheenColorFactor() {
    return this.get('sheenColorFactor');
  }
  /** Sheen; linear multiplier. */
  setSheenColorFactor(factor) {
    return this.set('sheenColorFactor', factor);
  }
  /**
   * Sheen color texture, in sRGB colorspace.
   */
  getSheenColorTexture() {
    return this.getRef('sheenColorTexture');
  }
  /**
   * Settings affecting the material's use of its sheen color texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getSheenColorTextureInfo() {
    return this.getRef('sheenColorTexture') ? this.getRef('sheenColorTextureInfo') : null;
  }
  /** Sets sheen color texture. See {@link Sheen.getSheenColorTexture getSheenColorTexture}. */
  setSheenColorTexture(texture) {
    return this.setRef('sheenColorTexture', texture, {
      channels: R$2 | G$2 | B$1,
      isColor: true
    });
  }
  /**********************************************************************************************
   * Sheen roughness.
   */
  /** Sheen roughness; linear multiplier. See {@link Sheen.getSheenRoughnessTexture getSheenRoughnessTexture}. */
  getSheenRoughnessFactor() {
    return this.get('sheenRoughnessFactor');
  }
  /** Sheen roughness; linear multiplier. See {@link Sheen.getSheenRoughnessTexture getSheenRoughnessTexture}. */
  setSheenRoughnessFactor(factor) {
    return this.set('sheenRoughnessFactor', factor);
  }
  /**
   * Sheen roughness texture; linear multiplier. The `a` channel of this texture specifies
   * roughness, independent of the base layer's roughness.
   */
  getSheenRoughnessTexture() {
    return this.getRef('sheenRoughnessTexture');
  }
  /**
   * Settings affecting the material's use of its sheen roughness texture. If no texture is
   * attached, {@link TextureInfo} is `null`.
   */
  getSheenRoughnessTextureInfo() {
    return this.getRef('sheenRoughnessTexture') ? this.getRef('sheenRoughnessTextureInfo') : null;
  }
  /**
   * Sets sheen roughness texture.  The `a` channel of this texture specifies
   * roughness, independent of the base layer's roughness.
   */
  setSheenRoughnessTexture(texture) {
    return this.setRef('sheenRoughnessTexture', texture, {
      channels: A$1
    });
  }
}
Sheen.EXTENSION_NAME = KHR_MATERIALS_SHEEN;

const NAME$9 = KHR_MATERIALS_SHEEN;
/**
 * [`KHR_materials_sheen`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_sheen/)
 * defines a velvet-like sheen layered on a glTF PBR material.
 *
 * ![Illustration](/media/extensions/khr-materials-sheen.png)
 *
 * > _**Figure:** A cushion, showing high material roughness and low sheen roughness. Soft
 * > highlights at edges of the material show backscattering from microfibers. Source: Khronos
 * > Group._
 *
 * A sheen layer is a common technique used in Physically-Based Rendering to represent
 * cloth and fabric materials.
 *
 * Properties:
 * - {@link Sheen}
 *
 * ### Example
 *
 * The `KHRMaterialsSheen` class provides a single {@link ExtensionProperty} type, `Sheen`,
 * which may be attached to any {@link Material} instance. For example:
 *
 * ```typescript
 * import { KHRMaterialsSheen, Sheen } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const sheenExtension = document.createExtension(KHRMaterialsSheen);
 *
 * // Create a Sheen property.
 * const sheen = sheenExtension.createSheen()
 * 	.setSheenColorFactor([1.0, 1.0, 1.0]);
 *
 * // Attach the property to a Material.
 * material.setExtension('KHR_materials_sheen', sheen);
 * ```
 */
class KHRMaterialsSheen extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$9;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Sheen property for use on a {@link Material}. */
  createSheen() {
    return new Sheen(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$9]) {
        const sheen = this.createSheen();
        context.materials[materialIndex].setExtension(NAME$9, sheen);
        const sheenDef = materialDef.extensions[NAME$9];
        // Factors.
        if (sheenDef.sheenColorFactor !== undefined) {
          sheen.setSheenColorFactor(sheenDef.sheenColorFactor);
        }
        if (sheenDef.sheenRoughnessFactor !== undefined) {
          sheen.setSheenRoughnessFactor(sheenDef.sheenRoughnessFactor);
        }
        // Textures.
        if (sheenDef.sheenColorTexture !== undefined) {
          const textureInfoDef = sheenDef.sheenColorTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          sheen.setSheenColorTexture(texture);
          context.setTextureInfo(sheen.getSheenColorTextureInfo(), textureInfoDef);
        }
        if (sheenDef.sheenRoughnessTexture !== undefined) {
          const textureInfoDef = sheenDef.sheenRoughnessTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          sheen.setSheenRoughnessTexture(texture);
          context.setTextureInfo(sheen.getSheenRoughnessTextureInfo(), textureInfoDef);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const sheen = material.getExtension(NAME$9);
      if (sheen) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        const sheenDef = materialDef.extensions[NAME$9] = {
          sheenColorFactor: sheen.getSheenColorFactor(),
          sheenRoughnessFactor: sheen.getSheenRoughnessFactor()
        };
        // Textures.
        if (sheen.getSheenColorTexture()) {
          const texture = sheen.getSheenColorTexture();
          const textureInfo = sheen.getSheenColorTextureInfo();
          sheenDef.sheenColorTexture = context.createTextureInfoDef(texture, textureInfo);
        }
        if (sheen.getSheenRoughnessTexture()) {
          const texture = sheen.getSheenRoughnessTexture();
          const textureInfo = sheen.getSheenRoughnessTextureInfo();
          sheenDef.sheenRoughnessTexture = context.createTextureInfoDef(texture, textureInfo);
        }
      }
    });
    return this;
  }
}
KHRMaterialsSheen.EXTENSION_NAME = NAME$9;

const {
  R: R$1,
  G: G$1,
  B,
  A
} = TextureChannel;
/**
 * Defines specular reflectivity on a PBR {@link Material}. See {@link KHRMaterialsSpecular}.
 */
class Specular extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_SPECULAR;
    this.propertyType = 'Specular';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      specularFactor: 1.0,
      specularTexture: null,
      specularTextureInfo: new TextureInfo(this.graph, 'specularTextureInfo'),
      specularColorFactor: [1.0, 1.0, 1.0],
      specularColorTexture: null,
      specularColorTextureInfo: new TextureInfo(this.graph, 'specularColorTextureInfo')
    });
  }
  /**********************************************************************************************
   * Specular.
   */
  /** Specular; linear multiplier. See {@link Specular.getSpecularTexture getSpecularTexture}. */
  getSpecularFactor() {
    return this.get('specularFactor');
  }
  /** Specular; linear multiplier. See {@link Specular.getSpecularTexture getSpecularTexture}. */
  setSpecularFactor(factor) {
    return this.set('specularFactor', factor);
  }
  /** Specular color; Linear-sRGB components. See {@link Specular.getSpecularTexture getSpecularTexture}. */
  getSpecularColorFactor() {
    return this.get('specularColorFactor');
  }
  /** Specular color; Linear-sRGB components. See {@link Specular.getSpecularTexture getSpecularTexture}. */
  setSpecularColorFactor(factor) {
    return this.set('specularColorFactor', factor);
  }
  /**
   * Specular texture; linear multiplier. Configures the strength of the specular reflection in
   * the dielectric BRDF. A value of zero disables the specular reflection, resulting in a pure
   * diffuse material.
   *
   * Only the alpha (A) channel is used for specular strength, but this texture may optionally
   * be packed with specular color (RGB) into a single texture.
   */
  getSpecularTexture() {
    return this.getRef('specularTexture');
  }
  /**
   * Settings affecting the material's use of its specular texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getSpecularTextureInfo() {
    return this.getRef('specularTexture') ? this.getRef('specularTextureInfo') : null;
  }
  /** Sets specular texture. See {@link Specular.getSpecularTexture getSpecularTexture}. */
  setSpecularTexture(texture) {
    return this.setRef('specularTexture', texture, {
      channels: A
    });
  }
  /**
   * Specular color texture; linear multiplier. Defines the F0 color of the specular reflection
   * (RGB channels, encoded in sRGB) in the the dielectric BRDF.
   *
   * Only RGB channels are used here, but this texture may optionally be packed with a specular
   * factor (A) into a single texture.
   */
  getSpecularColorTexture() {
    return this.getRef('specularColorTexture');
  }
  /**
   * Settings affecting the material's use of its specular color texture. If no texture is
   * attached, {@link TextureInfo} is `null`.
   */
  getSpecularColorTextureInfo() {
    return this.getRef('specularColorTexture') ? this.getRef('specularColorTextureInfo') : null;
  }
  /** Sets specular color texture. See {@link Specular.getSpecularColorTexture getSpecularColorTexture}. */
  setSpecularColorTexture(texture) {
    return this.setRef('specularColorTexture', texture, {
      channels: R$1 | G$1 | B,
      isColor: true
    });
  }
}
Specular.EXTENSION_NAME = KHR_MATERIALS_SPECULAR;

const NAME$8 = KHR_MATERIALS_SPECULAR;
/**
 * [`KHR_materials_specular`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_specular/)
 * adjusts the strength of the specular reflection in the dielectric BRDF.
 *
 * KHRMaterialsSpecular is a better alternative to the older
 * {@link KHRMaterialsPBRSpecularGlossiness KHR_materials_pbrSpecularGlossiness} extension, and
 * provides specular information while remaining within a metal/rough PBR workflow. A
 * value of zero disables the specular reflection, resulting in a pure diffuse material.
 *
 * Properties:
 * - {@link Specular}
 *
 * ### Example
 *
 * The `KHRMaterialsSpecular` class provides a single {@link ExtensionProperty} type, `Specular`,
 * which may be attached to any {@link Material} instance. For example:
 *
 * ```typescript
 * import { KHRMaterialsSpecular, Specular } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const specularExtension = document.createExtension(KHRMaterialsSpecular);
 *
 * // Create a Specular property.
 * const specular = specularExtension.createSpecular()
 * 	.setSpecularFactor(1.0);
 *
 * // Attach the property to a Material.
 * material.setExtension('KHR_materials_specular', specular);
 * ```
 */
class KHRMaterialsSpecular extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$8;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Specular property for use on a {@link Material}. */
  createSpecular() {
    return new Specular(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$8]) {
        const specular = this.createSpecular();
        context.materials[materialIndex].setExtension(NAME$8, specular);
        const specularDef = materialDef.extensions[NAME$8];
        // Factors.
        if (specularDef.specularFactor !== undefined) {
          specular.setSpecularFactor(specularDef.specularFactor);
        }
        if (specularDef.specularColorFactor !== undefined) {
          specular.setSpecularColorFactor(specularDef.specularColorFactor);
        }
        // Textures.
        if (specularDef.specularTexture !== undefined) {
          const textureInfoDef = specularDef.specularTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          specular.setSpecularTexture(texture);
          context.setTextureInfo(specular.getSpecularTextureInfo(), textureInfoDef);
        }
        if (specularDef.specularColorTexture !== undefined) {
          const textureInfoDef = specularDef.specularColorTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          specular.setSpecularColorTexture(texture);
          context.setTextureInfo(specular.getSpecularColorTextureInfo(), textureInfoDef);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const specular = material.getExtension(NAME$8);
      if (specular) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        const specularDef = materialDef.extensions[NAME$8] = {};
        if (specular.getSpecularFactor() !== 1) {
          specularDef.specularFactor = specular.getSpecularFactor();
        }
        if (!MathUtils.eq(specular.getSpecularColorFactor(), [1, 1, 1])) {
          specularDef.specularColorFactor = specular.getSpecularColorFactor();
        }
        // Textures.
        if (specular.getSpecularTexture()) {
          const texture = specular.getSpecularTexture();
          const textureInfo = specular.getSpecularTextureInfo();
          specularDef.specularTexture = context.createTextureInfoDef(texture, textureInfo);
        }
        if (specular.getSpecularColorTexture()) {
          const texture = specular.getSpecularColorTexture();
          const textureInfo = specular.getSpecularColorTextureInfo();
          specularDef.specularColorTexture = context.createTextureInfoDef(texture, textureInfo);
        }
      }
    });
    return this;
  }
}
KHRMaterialsSpecular.EXTENSION_NAME = NAME$8;

const {
  R
} = TextureChannel;
/**
 * Defines optical transmission on a PBR {@link Material}. See {@link KHRMaterialsTransmission}.
 */
class Transmission extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_TRANSMISSION;
    this.propertyType = 'Transmission';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      transmissionFactor: 0.0,
      transmissionTexture: null,
      transmissionTextureInfo: new TextureInfo(this.graph, 'transmissionTextureInfo')
    });
  }
  /**********************************************************************************************
   * Transmission.
   */
  /** Transmission; linear multiplier. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */
  getTransmissionFactor() {
    return this.get('transmissionFactor');
  }
  /** Transmission; linear multiplier. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */
  setTransmissionFactor(factor) {
    return this.set('transmissionFactor', factor);
  }
  /**
   * Transmission texture; linear multiplier. The `r` channel of this texture specifies
   * transmission [0-1] of the material's surface. By default this is a thin transparency
   * effect, but volume effects (refraction, subsurface scattering) may be introduced with the
   * addition of the `KHR_materials_volume` extension.
   */
  getTransmissionTexture() {
    return this.getRef('transmissionTexture');
  }
  /**
   * Settings affecting the material's use of its transmission texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getTransmissionTextureInfo() {
    return this.getRef('transmissionTexture') ? this.getRef('transmissionTextureInfo') : null;
  }
  /** Sets transmission texture. See {@link Transmission.getTransmissionTexture getTransmissionTexture}. */
  setTransmissionTexture(texture) {
    return this.setRef('transmissionTexture', texture, {
      channels: R
    });
  }
}
Transmission.EXTENSION_NAME = KHR_MATERIALS_TRANSMISSION;

const NAME$7 = KHR_MATERIALS_TRANSMISSION;
/**
 * [`KHR_materials_transmission`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/)
 * provides a common type of optical transparency: infinitely-thin materials with no refraction,
 * scattering, or dispersion.
 *
 * ![Illustration](/media/extensions/khr-materials-transmission.png)
 *
 * > _**Figure:** Sphere using `KHR_materials_transmission` with varying roughness (0.0, 0.2, 0.4).
 * > Source: Khronos Group._
 *
 * While default PBR materials using alpha blending become invisible as their opacity approaches
 * zero, a transmissive material continues to reflect light in a glass-like manner, even at low
 * transmission values. When combined with {@link KHRMaterialsVolume}, transmission may be used for
 * thicker materials and refractive effects.
 *
 * Properties:
 * - {@link Transmission}
 *
 * ### Example
 *
 * The `KHRMaterialsTransmission` class provides a single {@link ExtensionProperty} type,
 * `Transmission`, which may be attached to any {@link Material} instance. For example:
 *
 * ```typescript
 * import { KHRMaterialsTransmission, Transmission } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const transmissionExtension = document.createExtension(KHRMaterialsTransmission);
 *
 * // Create a Transmission property.
 * const transmission = transmissionExtension.createTransmission()
 * 	.setTransmissionFactor(1.0);
 *
 * // Attach the property to a Material.
 * material.setExtension('KHR_materials_transmission', transmission);
 * ```
 */
class KHRMaterialsTransmission extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$7;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Transmission property for use on a {@link Material}. */
  createTransmission() {
    return new Transmission(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$7]) {
        const transmission = this.createTransmission();
        context.materials[materialIndex].setExtension(NAME$7, transmission);
        const transmissionDef = materialDef.extensions[NAME$7];
        // Factors.
        if (transmissionDef.transmissionFactor !== undefined) {
          transmission.setTransmissionFactor(transmissionDef.transmissionFactor);
        }
        // Textures.
        if (transmissionDef.transmissionTexture !== undefined) {
          const textureInfoDef = transmissionDef.transmissionTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          transmission.setTransmissionTexture(texture);
          context.setTextureInfo(transmission.getTransmissionTextureInfo(), textureInfoDef);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const transmission = material.getExtension(NAME$7);
      if (transmission) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        const transmissionDef = materialDef.extensions[NAME$7] = {
          transmissionFactor: transmission.getTransmissionFactor()
        };
        // Textures.
        if (transmission.getTransmissionTexture()) {
          const texture = transmission.getTransmissionTexture();
          const textureInfo = transmission.getTransmissionTextureInfo();
          transmissionDef.transmissionTexture = context.createTextureInfoDef(texture, textureInfo);
        }
      }
    });
    return this;
  }
}
KHRMaterialsTransmission.EXTENSION_NAME = NAME$7;

/**
 * Converts a PBR {@link Material} to an unlit shading model. See {@link KHRMaterialsUnlit}.
 */
class Unlit extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_UNLIT;
    this.propertyType = 'Unlit';
    this.parentTypes = [PropertyType.MATERIAL];
  }
}
Unlit.EXTENSION_NAME = KHR_MATERIALS_UNLIT;

const NAME$6 = KHR_MATERIALS_UNLIT;
/**
 * [`KHR_materials_unlit`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/)
 * defines an unlit shading model for use in glTF 2.0 materials.
 *
 * ![Illustration](/media/extensions/khr-materials-unlit.png)
 *
 * > _**Figure:** Unlit materials are useful for flat shading, stylized effects, and for improving
 * > performance on mobile devices. Source: [Model by Hayden VanEarden](https://sketchfab.com/3d-models/summertime-kirby-c5711316103a4d67a62c34cfe8710938)._
 *
 * Unlit (also "Shadeless" or "Constant") materials provide a simple alternative to the Physically
 * Based Rendering (PBR) shading models provided by the core specification. Unlit materials are
 * often useful for cheaper rendering on performance-contrained devices, e.g. mobile phones.
 * Additionally, unlit materials can be very useful in achieving stylized, non-photo-realistic
 * effects like hand painted illustrative styles or baked toon shaders.
 *
 * Properties:
 * - {@link Unlit}
 *
 * ### Example
 *
 * The `KHRMaterialsUnlit` class provides a single {@link ExtensionProperty} type, `Unlit`, which may
 * be attached to any {@link Material} instance. For example:
 *
 * ```typescript
 * import { KHRMaterialsUnlit, Unlit } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const unlitExtension = document.createExtension(KHRMaterialsUnlit);
 *
 * // Create an Unlit property.
 * const unlit = unlitExtension.createUnlit();
 *
 * // Attach the property to a Material.
 * material.setExtension('KHR_materials_unlit', unlit);
 * ```
 */
class KHRMaterialsUnlit extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$6;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Unlit property for use on a {@link Material}. */
  createUnlit() {
    return new Unlit(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const materialDefs = context.jsonDoc.json.materials || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$6]) {
        context.materials[materialIndex].setExtension(NAME$6, this.createUnlit());
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      if (material.getExtension(NAME$6)) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        materialDef.extensions[NAME$6] = {};
      }
    });
    return this;
  }
}
KHRMaterialsUnlit.EXTENSION_NAME = NAME$6;

/**
 * Maps {@link Variant}s to {@link Material}s. See {@link KHRMaterialsVariants}.
 */
class Mapping extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_VARIANTS;
    this.propertyType = 'Mapping';
    this.parentTypes = ['MappingList'];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      material: null,
      variants: new RefSet()
    });
  }
  /** The {@link Material} designated for this {@link Primitive}, under the given variants. */
  getMaterial() {
    return this.getRef('material');
  }
  /** The {@link Material} designated for this {@link Primitive}, under the given variants. */
  setMaterial(material) {
    return this.setRef('material', material);
  }
  /** Adds a {@link Variant} to this mapping. */
  addVariant(variant) {
    return this.addRef('variants', variant);
  }
  /** Removes a {@link Variant} from this mapping. */
  removeVariant(variant) {
    return this.removeRef('variants', variant);
  }
  /** Lists {@link Variant}s in this mapping. */
  listVariants() {
    return this.listRefs('variants');
  }
}
Mapping.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;

/**
 * List of material variant {@link Mapping}s. See {@link KHRMaterialsVariants}.
 */
class MappingList extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_VARIANTS;
    this.propertyType = 'MappingList';
    this.parentTypes = [PropertyType.PRIMITIVE];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      mappings: new RefSet()
    });
  }
  /** Adds a {@link Mapping} to this mapping. */
  addMapping(mapping) {
    return this.addRef('mappings', mapping);
  }
  /** Removes a {@link Mapping} from the list for this {@link Primitive}. */
  removeMapping(mapping) {
    return this.removeRef('mappings', mapping);
  }
  /** Lists {@link Mapping}s in this {@link Primitive}. */
  listMappings() {
    return this.listRefs('mappings');
  }
}
MappingList.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;

/**
 * Defines a variant of a {@link Material}. See {@link KHRMaterialsVariants}.
 */
class Variant extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_VARIANTS;
    this.propertyType = 'Variant';
    this.parentTypes = ['MappingList'];
  }
}
Variant.EXTENSION_NAME = KHR_MATERIALS_VARIANTS;

const NAME$5 = KHR_MATERIALS_VARIANTS;
/**
 * [`KHR_materials_variants`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_variants/)
 * defines alternate {@link Material} states for any {@link Primitive} in the scene.
 *
 * ![Illustration](/media/extensions/khr-materials-variants.jpg)
 *
 * > _**Figure:** A sneaker, in three material variants. Source: Khronos Group._
 *
 * Uses include product configurators, night/day states, healthy/damaged states, etc. The
 * `KHRMaterialsVariants` class provides three {@link ExtensionProperty} types: `Variant`, `Mapping`,
 * and `MappingList`. When attached to {@link Primitive} properties, these offer flexible ways of
 * defining the variants available to an application. Triggering a variant is out of scope of this
 * extension, but could be handled in the application with a UI dropdown, particular game states,
 * and so on.
 *
 * Mesh geometry cannot be changed by this extension, although another extension
 * (tentative: `KHR_mesh_variants`) is under consideration by the Khronos Group, for that purpose.
 *
 * Properties:
 * - {@link Variant}
 * - {@link Mapping}
 * - {@link MappingList}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRMaterialsVariants } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const variantExtension = document.createExtension(KHRMaterialsVariants);
 *
 * // Create some Variant states.
 * const healthyVariant = variantExtension.createVariant('Healthy');
 * const damagedVariant = variantExtension.createVariant('Damaged');
 *
 * // Create mappings from a Variant state to a Material.
 * const healthyMapping = variantExtension.createMapping()
 * 	.addVariant(healthyVariant)
 * 	.setMaterial(healthyMat);
 * const damagedMapping = variantExtension.createMapping()
 * 	.addVariant(damagedVariant)
 * 	.setMaterial(damagedMat);
 *
 * // Attach the mappings to a Primitive.
 * primitive.setExtension(
 * 	'KHR_materials_variants',
 * 	variantExtension.createMappingList()
 * 		.addMapping(healthyMapping)
 * 		.addMapping(damagedMapping)
 * );
 * ```
 *
 * A few notes about this extension:
 *
 * 1. Viewers that don't recognized this extension will show the default material for each primitive
 * 	 instead, so assign that material accordingly. This material can be — but doesn't have to be —
 * 	 associated with one of the available variants.
 * 2. Mappings can list multiple Variants. In that case, the first Mapping containing an active
 * 	 Variant will be chosen by the viewer.
 * 3. Variant names are how these states are identified, so choose informative names.
 * 4. When writing the file to an unpacked `.gltf`, instead of an embedded `.glb`, viewers will have
 * 	 the option of downloading only textures associated with the default state, and lazy-loading
 * 	 any textures for inactive Variants only when they are needed.
 */
class KHRMaterialsVariants extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$5;
  }
  /** Creates a new MappingList property. */
  createMappingList() {
    return new MappingList(this.document.getGraph());
  }
  /** Creates a new Variant property. */
  createVariant(name = '') {
    return new Variant(this.document.getGraph(), name);
  }
  /** Creates a new Mapping property. */
  createMapping() {
    return new Mapping(this.document.getGraph());
  }
  /** Lists all Variants on the current Document. */
  listVariants() {
    return Array.from(this.properties).filter(prop => prop instanceof Variant);
  }
  /** @hidden */
  read(context) {
    const jsonDoc = context.jsonDoc;
    if (!jsonDoc.json.extensions || !jsonDoc.json.extensions[NAME$5]) return this;
    // Read all top-level variant names.
    const variantsRootDef = jsonDoc.json.extensions[NAME$5];
    const variantDefs = variantsRootDef.variants || [];
    const variants = variantDefs.map(variantDef => this.createVariant().setName(variantDef.name || ''));
    // For each mesh primitive, read its material/variant mappings.
    const meshDefs = jsonDoc.json.meshes || [];
    meshDefs.forEach((meshDef, meshIndex) => {
      const mesh = context.meshes[meshIndex];
      const primDefs = meshDef.primitives || [];
      primDefs.forEach((primDef, primIndex) => {
        if (!primDef.extensions || !primDef.extensions[NAME$5]) {
          return;
        }
        const mappingList = this.createMappingList();
        const variantPrimDef = primDef.extensions[NAME$5];
        for (const mappingDef of variantPrimDef.mappings) {
          const mapping = this.createMapping();
          if (mappingDef.material !== undefined) {
            mapping.setMaterial(context.materials[mappingDef.material]);
          }
          for (const variantIndex of mappingDef.variants || []) {
            mapping.addVariant(variants[variantIndex]);
          }
          mappingList.addMapping(mapping);
        }
        mesh.listPrimitives()[primIndex].setExtension(NAME$5, mappingList);
      });
    });
    return this;
  }
  /** @hidden */
  write(context) {
    const jsonDoc = context.jsonDoc;
    const variants = this.listVariants();
    if (!variants.length) return this;
    // Write all top-level variant names.
    const variantDefs = [];
    const variantIndexMap = new Map();
    for (const variant of variants) {
      variantIndexMap.set(variant, variantDefs.length);
      variantDefs.push(context.createPropertyDef(variant));
    }
    // For each mesh primitive, write its material/variant mappings.
    for (const mesh of this.document.getRoot().listMeshes()) {
      const meshIndex = context.meshIndexMap.get(mesh);
      mesh.listPrimitives().forEach((prim, primIndex) => {
        const mappingList = prim.getExtension(NAME$5);
        if (!mappingList) return;
        const primDef = context.jsonDoc.json.meshes[meshIndex].primitives[primIndex];
        const mappingDefs = mappingList.listMappings().map(mapping => {
          const mappingDef = context.createPropertyDef(mapping);
          const material = mapping.getMaterial();
          if (material) {
            mappingDef.material = context.materialIndexMap.get(material);
          }
          mappingDef.variants = mapping.listVariants().map(variant => variantIndexMap.get(variant));
          return mappingDef;
        });
        primDef.extensions = primDef.extensions || {};
        primDef.extensions[NAME$5] = {
          mappings: mappingDefs
        };
      });
    }
    jsonDoc.json.extensions = jsonDoc.json.extensions || {};
    jsonDoc.json.extensions[NAME$5] = {
      variants: variantDefs
    };
    return this;
  }
}
KHRMaterialsVariants.EXTENSION_NAME = NAME$5;

const {
  G
} = TextureChannel;
/**
 * Defines volume on a PBR {@link Material}. See {@link KHRMaterialsVolume}.
 */
class Volume extends ExtensionProperty {
  init() {
    this.extensionName = KHR_MATERIALS_VOLUME;
    this.propertyType = 'Volume';
    this.parentTypes = [PropertyType.MATERIAL];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      thicknessFactor: 0.0,
      thicknessTexture: null,
      thicknessTextureInfo: new TextureInfo(this.graph, 'thicknessTexture'),
      attenuationDistance: Infinity,
      attenuationColor: [1.0, 1.0, 1.0]
    });
  }
  /**********************************************************************************************
   * Thickness.
   */
  /**
   * Thickness of the volume beneath the surface in meters in the local coordinate system of the
   * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume
   * boundary. The doubleSided property has no effect on volume boundaries.
   */
  getThicknessFactor() {
    return this.get('thicknessFactor');
  }
  /**
   * Thickness of the volume beneath the surface in meters in the local coordinate system of the
   * node. If the value is 0 the material is thin-walled. Otherwise the material is a volume
   * boundary. The doubleSided property has no effect on volume boundaries.
   */
  setThicknessFactor(factor) {
    return this.set('thicknessFactor', factor);
  }
  /**
   * Texture that defines the thickness, stored in the G channel. This will be multiplied by
   * thicknessFactor.
   */
  getThicknessTexture() {
    return this.getRef('thicknessTexture');
  }
  /**
   * Settings affecting the material's use of its thickness texture. If no texture is attached,
   * {@link TextureInfo} is `null`.
   */
  getThicknessTextureInfo() {
    return this.getRef('thicknessTexture') ? this.getRef('thicknessTextureInfo') : null;
  }
  /**
   * Texture that defines the thickness, stored in the G channel. This will be multiplied by
   * thicknessFactor.
   */
  setThicknessTexture(texture) {
    return this.setRef('thicknessTexture', texture, {
      channels: G
    });
  }
  /**********************************************************************************************
   * Attenuation.
   */
  /**
   * Density of the medium given as the average distance in meters that light travels in the
   * medium before interacting with a particle.
   */
  getAttenuationDistance() {
    return this.get('attenuationDistance');
  }
  /**
   * Density of the medium given as the average distance in meters that light travels in the
   * medium before interacting with a particle.
   */
  setAttenuationDistance(distance) {
    return this.set('attenuationDistance', distance);
  }
  /**
   * Color (linear) that white light turns into due to absorption when reaching the attenuation
   * distance.
   */
  getAttenuationColor() {
    return this.get('attenuationColor');
  }
  /**
   * Color (linear) that white light turns into due to absorption when reaching the attenuation
   * distance.
   */
  setAttenuationColor(color) {
    return this.set('attenuationColor', color);
  }
}
Volume.EXTENSION_NAME = KHR_MATERIALS_VOLUME;

const NAME$4 = KHR_MATERIALS_VOLUME;
/**
 * [KHR_materials_volume](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_materials_volume/)
 * adds refraction, absorption, or scattering to a glTF PBR material already using transmission or
 * translucency.
 *
 * ![Illustration](/media/extensions/khr-materials-volume.png)
 *
 * > _**Figure:** Base color changes the amount of light passing through the volume boundary
 * > (left). The overall color of the object is the same everywhere, as if the object is covered
 * > with a colored, transparent foil. Absorption changes the amount of light traveling through the
 * > volume (right). The overall color depends on the distance the light traveled through it; at
 * > small distances (tail of the dragon) less light is absorbed and the color is brighter than at
 * > large distances. Source: Khronos Group._
 *
 * By default, a glTF 2.0 material describes the scattering properties of a surface enclosing an
 * infinitely thin volume. The surface defined by the mesh represents a thin wall. The volume
 * extension makes it possible to turn the surface into an interface between volumes. The mesh to
 * which the material is attached defines the boundaries of an homogeneous medium and therefore must
 * be manifold. Volumes provide effects like refraction, absorption and scattering. Scattering
 * effects will require future (TBD) extensions.
 *
 * The volume extension must be combined with {@link KHRMaterialsTransmission} or
 * `KHR_materials_translucency` in order to define entry of light into the volume.
 *
 * Properties:
 * - {@link Volume}
 *
 * ### Example
 *
 * The `KHRMaterialsVolume` class provides a single {@link ExtensionProperty} type, `Volume`, which
 * may be attached to any {@link Material} instance. For example:
 *
 * ```typescript
 * import { KHRMaterialsVolume, Volume } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const volumeExtension = document.createExtension(KHRMaterialsVolume);
 *
 * // Create a Volume property.
 * const volume = volumeExtension.createVolume()
 * 	.setThicknessFactor(1.0)
 * 	.setThicknessTexture(texture)
 * 	.setAttenuationDistance(1.0)
 * 	.setAttenuationColorFactor([1, 0.5, 0.5]);
 *
 * // Attach the property to a Material.
 * material.setExtension('KHR_materials_volume', volume);
 * ```
 *
 * A thickness texture is required in most realtime renderers, and can be baked in software such as
 * Blender or Substance Painter. When `thicknessFactor = 0`, all volumetric effects are disabled.
 */
class KHRMaterialsVolume extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$4;
    this.prereadTypes = [PropertyType.MESH];
    this.prewriteTypes = [PropertyType.MESH];
  }
  /** Creates a new Volume property for use on a {@link Material}. */
  createVolume() {
    return new Volume(this.document.getGraph());
  }
  /** @hidden */
  read(_context) {
    return this;
  }
  /** @hidden */
  write(_context) {
    return this;
  }
  /** @hidden */
  preread(context) {
    const jsonDoc = context.jsonDoc;
    const materialDefs = jsonDoc.json.materials || [];
    const textureDefs = jsonDoc.json.textures || [];
    materialDefs.forEach((materialDef, materialIndex) => {
      if (materialDef.extensions && materialDef.extensions[NAME$4]) {
        const volume = this.createVolume();
        context.materials[materialIndex].setExtension(NAME$4, volume);
        const volumeDef = materialDef.extensions[NAME$4];
        // Factors.
        if (volumeDef.thicknessFactor !== undefined) {
          volume.setThicknessFactor(volumeDef.thicknessFactor);
        }
        if (volumeDef.attenuationDistance !== undefined) {
          volume.setAttenuationDistance(volumeDef.attenuationDistance);
        }
        if (volumeDef.attenuationColor !== undefined) {
          volume.setAttenuationColor(volumeDef.attenuationColor);
        }
        // Textures.
        if (volumeDef.thicknessTexture !== undefined) {
          const textureInfoDef = volumeDef.thicknessTexture;
          const texture = context.textures[textureDefs[textureInfoDef.index].source];
          volume.setThicknessTexture(texture);
          context.setTextureInfo(volume.getThicknessTextureInfo(), textureInfoDef);
        }
      }
    });
    return this;
  }
  /** @hidden */
  prewrite(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listMaterials().forEach(material => {
      const volume = material.getExtension(NAME$4);
      if (volume) {
        const materialIndex = context.materialIndexMap.get(material);
        const materialDef = jsonDoc.json.materials[materialIndex];
        materialDef.extensions = materialDef.extensions || {};
        // Factors.
        const volumeDef = materialDef.extensions[NAME$4] = {};
        if (volume.getThicknessFactor() > 0) {
          volumeDef.thicknessFactor = volume.getThicknessFactor();
        }
        if (Number.isFinite(volume.getAttenuationDistance())) {
          volumeDef.attenuationDistance = volume.getAttenuationDistance();
        }
        if (!MathUtils.eq(volume.getAttenuationColor(), [1, 1, 1])) {
          volumeDef.attenuationColor = volume.getAttenuationColor();
        }
        // Textures.
        if (volume.getThicknessTexture()) {
          const texture = volume.getThicknessTexture();
          const textureInfo = volume.getThicknessTextureInfo();
          volumeDef.thicknessTexture = context.createTextureInfoDef(texture, textureInfo);
        }
      }
    });
    return this;
  }
}
KHRMaterialsVolume.EXTENSION_NAME = NAME$4;

const NAME$3 = KHR_MESH_QUANTIZATION;
/**
 * [`KHR_mesh_quantization`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/)
 * expands allowed component types for vertex attributes to include 16- and 8-bit storage.
 *
 * Quantization provides a memory/precision tradeoff — depending on the application needs, 16-bit or
 * 8-bit storage can be sufficient for mesh geometry, at 1/2 or 1/4 the size. For example, a 10x10
 * mesh might be written to a uint16 {@link Accessor}, with values `0–65536`, normalized to be
 * interpreted as `0–1`. With an additional 10x scale on any node {@link Node} instantiating the
 * quantized {@link Mesh}, the model retains its original scale with a minimal quality loss and
 * up to 50% file size reduction.
 *
 * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the
 * {@link Document}, and affects the entire Document by allowing more flexible use of
 * {@link Accessor} types for vertex attributes. Without the Extension, the same use of these data
 * types would yield an invalid glTF document, under the stricter core glTF specification.
 *
 * Properties:
 * - N/A
 *
 * ### Example
 *
 * ```typescript
 * import { KHRMeshQuantization } from '@gltf-transform/extensions';
 * import { quantize } from '@gltf-transform/functions';
 *
 * // Create an Extension attached to the Document.
 * const quantizationExtension = document.createExtension(KHRMeshQuantization).setRequired(true);
 *
 * // Use Uint16Array, Uint8Array, Int16Array, and Int8Array in vertex accessors manually,
 * // or apply the provided quantize() function to compute quantized accessors automatically:
 * await document.transform(quantize({
 * 	quantizePosition: 16,
 * 	quantizeNormal: 12,
 * 	quantizeTexcoord: 14
 * }));
 * ```
 *
 * For more documentation about automatic quantization, see the {@link quantize} function.
 */
class KHRMeshQuantization extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$3;
  }
  /** @hidden */
  read(_) {
    return this;
  }
  /** @hidden */
  write(_) {
    return this;
  }
}
KHRMeshQuantization.EXTENSION_NAME = NAME$3;

const NAME$2 = KHR_TEXTURE_BASISU;
class KTX2ImageUtils {
  match(array) {
    return array[0] === 0xab && array[1] === 0x4b && array[2] === 0x54 && array[3] === 0x58 && array[4] === 0x20 && array[5] === 0x32 && array[6] === 0x30 && array[7] === 0xbb && array[8] === 0x0d && array[9] === 0x0a && array[10] === 0x1a && array[11] === 0x0a;
  }
  getSize(array) {
    const container = read(array);
    return [container.pixelWidth, container.pixelHeight];
  }
  getChannels(array) {
    const container = read(array);
    const dfd = container.dataFormatDescriptor[0];
    if (dfd.colorModel === KHR_DF_MODEL_ETC1S) {
      return dfd.samples.length === 2 && (dfd.samples[1].channelType & 0xf) === 15 ? 4 : 3;
    } else if (dfd.colorModel === KHR_DF_MODEL_UASTC) {
      return (dfd.samples[0].channelType & 0xf) === 3 ? 4 : 3;
    }
    throw new Error(`Unexpected KTX2 colorModel, "${dfd.colorModel}".`);
  }
  getVRAMByteLength(array) {
    const container = read(array);
    const hasAlpha = this.getChannels(array) > 3;
    let uncompressedBytes = 0;
    for (let i = 0; i < container.levels.length; i++) {
      const level = container.levels[i];
      // Use level.uncompressedByteLength for UASTC; for ETC1S it's 0.
      if (level.uncompressedByteLength) {
        uncompressedBytes += level.uncompressedByteLength;
      } else {
        const levelWidth = Math.max(1, Math.floor(container.pixelWidth / Math.pow(2, i)));
        const levelHeight = Math.max(1, Math.floor(container.pixelHeight / Math.pow(2, i)));
        const blockSize = hasAlpha ? 16 : 8;
        uncompressedBytes += levelWidth / 4 * (levelHeight / 4) * blockSize;
      }
    }
    return uncompressedBytes;
  }
}
/**
 * [`KHR_texture_basisu`](https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu)
 * enables KTX2 GPU textures with Basis Universal supercompression for any material texture.
 *
 * GPU texture formats, unlike traditional image formats, remain compressed in GPU memory. As a
 * result, they (1) upload to the GPU much more quickly, and (2) require much less GPU memory. In
 * certain cases they may also have smaller filesizes than PNG or JPEG textures, but this is not
 * guaranteed. GPU textures often require more careful tuning during compression to maintain image
 * quality, but this extra effort is worthwhile for applications that need to maintain a smooth
 * framerate while uploading images, or where GPU memory is limited.
 *
 * Defining no {@link ExtensionProperty} types, this {@link Extension} is simply attached to the
 * {@link Document}, and affects the entire Document by allowing use of the `image/ktx2` MIME type
 * and passing KTX2 image data to the {@link Texture.setImage} method. Without the Extension, the
 * same MIME types and image data would yield an invalid glTF document, under the stricter core glTF
 * specification.
 *
 * Properties:
 * - N/A
 *
 * ### Example
 *
 * ```typescript
 * import { KHRTextureBasisu } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const basisuExtension = document.createExtension(KHRTextureBasisu)
 * 	.setRequired(true);
 * document.createTexture('MyCompressedTexture')
 * 	.setMimeType('image/ktx2')
 * 	.setImage(fs.readFileSync('my-texture.ktx2'));
 * ```
 *
 * Compression is not done automatically when adding the extension as shown above — you must
 * compress the image data first, then pass the `.ktx2` payload to {@link Texture.setImage}. The
 * glTF Transform CLI has functions to help with this, or any similar KTX2-capable
 * utility will work.
 *
 * When the `KHR_texture_basisu` extension is added to a file by glTF Transform, the extension
 * should always be required. This tool does not support writing assets that "fall back" to optional
 * PNG or JPEG image data.
 *
 * > _**NOTICE:** Compressing some textures — particularly 3-component (RGB) normal maps, and
 * > occlusion/roughness/metalness maps, may give poor results with the ETC1S compression option.
 * > These issues can often be avoided with the larger UASTC compression option, or by upscaling the
 * > texture before compressing it.
 * >
 * > For best results when authoring new textures, use
 * > [texture dilation](https://docs.substance3d.com/spdoc/padding-134643719.html) and minimize
 * > prominent UV seams._
 */
class KHRTextureBasisu extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$2;
    /** @hidden */
    this.prereadTypes = [PropertyType.TEXTURE];
  }
  /** @hidden */
  static register() {
    ImageUtils.registerFormat('image/ktx2', new KTX2ImageUtils());
  }
  /** @hidden */
  preread(context) {
    context.jsonDoc.json.textures.forEach(textureDef => {
      if (textureDef.extensions && textureDef.extensions[NAME$2]) {
        const basisuDef = textureDef.extensions[NAME$2];
        textureDef.source = basisuDef.source;
      }
    });
    return this;
  }
  /** @hidden */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  read(context) {
    return this;
  }
  /** @hidden */
  write(context) {
    const jsonDoc = context.jsonDoc;
    this.document.getRoot().listTextures().forEach(texture => {
      if (texture.getMimeType() === 'image/ktx2') {
        const imageIndex = context.imageIndexMap.get(texture);
        jsonDoc.json.textures.forEach(textureDef => {
          if (textureDef.source === imageIndex) {
            textureDef.extensions = textureDef.extensions || {};
            textureDef.extensions[NAME$2] = {
              source: textureDef.source
            };
            delete textureDef.source;
          }
        });
      }
    });
    return this;
  }
}
KHRTextureBasisu.EXTENSION_NAME = NAME$2;

/**
 * Defines UV transform for a {@link TextureInfo}. See {@link KHRTextureTransform}.
 */
class Transform extends ExtensionProperty {
  init() {
    this.extensionName = KHR_TEXTURE_TRANSFORM;
    this.propertyType = 'Transform';
    this.parentTypes = [PropertyType.TEXTURE_INFO];
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      offset: [0.0, 0.0],
      rotation: 0,
      scale: [1.0, 1.0],
      texCoord: null
    });
  }
  getOffset() {
    return this.get('offset');
  }
  setOffset(offset) {
    return this.set('offset', offset);
  }
  getRotation() {
    return this.get('rotation');
  }
  setRotation(rotation) {
    return this.set('rotation', rotation);
  }
  getScale() {
    return this.get('scale');
  }
  setScale(scale) {
    return this.set('scale', scale);
  }
  getTexCoord() {
    return this.get('texCoord');
  }
  setTexCoord(texCoord) {
    return this.set('texCoord', texCoord);
  }
}
Transform.EXTENSION_NAME = KHR_TEXTURE_TRANSFORM;

const NAME$1 = KHR_TEXTURE_TRANSFORM;
/**
 * [`KHR_texture_transform`](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_texture_transform/)
 * adds offset, rotation, and scale to {@link TextureInfo} properties.
 *
 * Affine UV transforms are useful for reducing the number of textures the GPU must load, improving
 * performance when used in techniques like texture atlases. UV transforms cannot be animated at
 * this time.
 *
 * Properties:
 * - {@link Transform}
 *
 * ### Example
 *
 * The `KHRTextureTransform` class provides a single {@link ExtensionProperty} type, `Transform`, which
 * may be attached to any {@link TextureInfo} instance. For example:
 *
 * ```typescript
 * import { KHRTextureTransform } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const transformExtension = document.createExtension(KHRTextureTransform)
 * 	.setRequired(true);
 *
 * // Create a reusable Transform.
 * const transform = transformExtension.createTransform()
 * 	.setScale([100, 100]);
 *
 * // Apply the Transform to a Material's baseColorTexture.
 * document.createMaterial()
 * 	.setBaseColorTexture(myTexture)
 * 	.getBaseColorTextureInfo()
 * 	.setExtension('KHR_texture_transform', transform);
 * ```
 */
class KHRTextureTransform extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME$1;
  }
  /** Creates a new Transform property for use on a {@link TextureInfo}. */
  createTransform() {
    return new Transform(this.document.getGraph());
  }
  /** @hidden */
  read(context) {
    for (const [textureInfo, textureInfoDef] of Array.from(context.textureInfos.entries())) {
      if (!textureInfoDef.extensions || !textureInfoDef.extensions[NAME$1]) continue;
      const transform = this.createTransform();
      const transformDef = textureInfoDef.extensions[NAME$1];
      if (transformDef.offset !== undefined) transform.setOffset(transformDef.offset);
      if (transformDef.rotation !== undefined) transform.setRotation(transformDef.rotation);
      if (transformDef.scale !== undefined) transform.setScale(transformDef.scale);
      if (transformDef.texCoord !== undefined) transform.setTexCoord(transformDef.texCoord);
      textureInfo.setExtension(NAME$1, transform);
    }
    return this;
  }
  /** @hidden */
  write(context) {
    const textureInfoEntries = Array.from(context.textureInfoDefMap.entries());
    for (const [textureInfo, textureInfoDef] of textureInfoEntries) {
      const transform = textureInfo.getExtension(NAME$1);
      if (!transform) continue;
      textureInfoDef.extensions = textureInfoDef.extensions || {};
      const transformDef = {};
      const eq = MathUtils.eq;
      if (!eq(transform.getOffset(), [0, 0])) transformDef.offset = transform.getOffset();
      if (transform.getRotation() !== 0) transformDef.rotation = transform.getRotation();
      if (!eq(transform.getScale(), [1, 1])) transformDef.scale = transform.getScale();
      if (transform.getTexCoord() != null) transformDef.texCoord = transform.getTexCoord();
      textureInfoDef.extensions[NAME$1] = transformDef;
    }
    return this;
  }
}
KHRTextureTransform.EXTENSION_NAME = NAME$1;

const PARENT_TYPES = [PropertyType.ROOT, PropertyType.SCENE, PropertyType.NODE, PropertyType.MESH, PropertyType.MATERIAL, PropertyType.TEXTURE, PropertyType.ANIMATION];
/**
 * Defines an XMP packet associated with a Document or Property. See {@link KHRXMP}.
 */
class Packet extends ExtensionProperty {
  init() {
    this.extensionName = KHR_XMP_JSON_LD;
    this.propertyType = 'Packet';
    this.parentTypes = PARENT_TYPES;
  }
  getDefaults() {
    return Object.assign(super.getDefaults(), {
      context: {},
      properties: {}
    });
  }
  /**********************************************************************************************
   * Context.
   */
  /**
   * Returns the XMP context definition URL for the given term.
   * See: https://json-ld.org/spec/latest/json-ld/#the-context
   * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.
   */
  getContext() {
    return this.get('context');
  }
  /**
   * Sets the XMP context definition URL for the given term.
   * See: https://json-ld.org/spec/latest/json-ld/#the-context
   *
   * Example:
   *
   * ```typescript
   * packet.setContext({
   *   dc: 'http://purl.org/dc/elements/1.1/',
   *   model3d: 'https://schema.khronos.org/model3d/xsd/1.0/',
   * });
   * ```
   *
   * @param term Case-sensitive term. Usually a concise, lowercase, alphanumeric identifier.
   * @param definition URI for XMP namespace.
   */
  setContext(context) {
    return this.set('context', _extends({}, context));
  }
  /**********************************************************************************************
   * Properties.
   */
  /**
   * Lists properties defined in this packet.
   *
   * Example:
   *
   * ```typescript
   * packet.listProperties(); // → ['dc:Language', 'dc:Creator', 'xmp:CreateDate']
   * ```
   */
  listProperties() {
    return Object.keys(this.get('properties'));
  }
  /**
   * Returns the value of a property, as a literal or JSONLD object.
   *
   * Example:
   *
   * ```typescript
   * packet.getProperty('dc:Creator'); // → {"@list": ["Acme, Inc."]}
   * packet.getProperty('dc:Title'); // → {"@type": "rdf:Alt", "rdf:_1": {"@language": "en-US", "@value": "Lamp"}}
   * packet.getProperty('xmp:CreateDate'); // → "2022-01-01"
   * ```
   */
  getProperty(name) {
    const properties = this.get('properties');
    return name in properties ? properties[name] : null;
  }
  /**
   * Sets the value of a property, as a literal or JSONLD object.
   *
   * Example:
   *
   * ```typescript
   * packet.setProperty('dc:Creator', {'@list': ['Acme, Inc.']});
   * packet.setProperty('dc:Title', {
   * 	'@type': 'rdf:Alt',
   * 	'rdf:_1': {'@language': 'en-US', '@value': 'Lamp'}
   * });
   * packet.setProperty('model3d:preferredSurfaces', {'@list': ['vertical']});
   * ```
   */
  setProperty(name, value) {
    this._assertContext(name);
    const properties = _extends({}, this.get('properties'));
    if (value) {
      properties[name] = value;
    } else {
      delete properties[name];
    }
    return this.set('properties', properties);
  }
  /**********************************************************************************************
   * Serialize / Deserialize.
   */
  /**
   * Serializes the packet context and properties to a JSONLD object.
   */
  toJSONLD() {
    const context = copyJSON(this.get('context'));
    const properties = copyJSON(this.get('properties'));
    return _extends({
      '@context': context
    }, properties);
  }
  /**
   * Deserializes a JSONLD packet, then overwrites existing context and properties with
   * the new values.
   */
  fromJSONLD(jsonld) {
    jsonld = copyJSON(jsonld);
    // Context.
    const context = jsonld['@context'];
    if (context) this.set('context', context);
    delete jsonld['@context'];
    // Properties.
    return this.set('properties', jsonld);
  }
  /**********************************************************************************************
   * Validation.
   */
  /** @hidden */
  _assertContext(name) {
    const prefix = name.split(':')[0];
    if (!(prefix in this.get('context'))) {
      throw new Error(`${KHR_XMP_JSON_LD}: Missing context for term, "${name}".`);
    }
  }
}
Packet.EXTENSION_NAME = KHR_XMP_JSON_LD;
function copyJSON(object) {
  return JSON.parse(JSON.stringify(object));
}

const NAME = KHR_XMP_JSON_LD;
/**
 * [KHR_xmp_json_ld](https://github.com/KhronosGroup/gltf/blob/main/extensions/2.0/Khronos/KHR_xmp_json_ld/)
 * defines XMP metadata associated with a glTF asset.
 *
 * XMP metadata provides standardized fields describing the content, provenance, usage
 * restrictions, or other attributes of a 3D model. XMP metadata does not generally affect the
 * parsing or runtime behavior of the content — for that, use custom extensions, custom vertex
 * attributes, or extras. Similarly, storage mechanisms other than XMP should be preferred
 * for binary content like mesh data, animations, or textures.
 *
 * Generally XMP metadata is associated with the entire glTF asset by attaching an XMP {@link Packet}
 * to the document {@link Root}. In less common cases where metadata must be associated with
 * specific subsets of a document, XMP Packets may be attached to {@link Scene}, {@link Node},
 * {@link Mesh}, {@link Material}, {@link Texture}, or {@link Animation} properties.
 *
 * Within each packet, XMP properties become available when an
 * [XMP namespace](https://www.adobe.io/xmp/docs/XMPNamespaces/) is registered
 * with {@link Packet.setContext}. Packets cannot use properties whose namespaces are not
 * registered as context. While not all XMP namespaces are relevant to 3D assets, some common
 * namespaces provide useful metadata about authorship and provenance. Additionally, the `model3d`
 * namespace provides certain properties specific to 3D content, such as Augmented Reality (AR)
 * orientation data.
 *
 * Common XMP contexts for 3D models include:
 *
 * | Prefix      | URI                                         | Name                           |
 * |:------------|:--------------------------------------------|:-------------------------------|
 * | `dc`        | http://purl.org/dc/elements/1.1/            | Dublin Core                    |
 * | `model3d`   | https://schema.khronos.org/model3d/xsd/1.0/ | Model 3D                       |
 * | `rdf`       | http://www.w3.org/1999/02/22-rdf-syntax-ns# | Resource Description Framework |
 * | `xmp`       | http://ns.adobe.com/xap/1.0/                | XMP                            |
 * | `xmpRights` | http://ns.adobe.com/xap/1.0/rights/         | XMP Rights Management          |
 *
 * Only the XMP contexts required for a packet should be assigned, and different packets
 * in the same asset may use different contexts. For greater detail on available XMP
 * contexts and how to use them in glTF assets, see the
 * [3DC Metadata Recommendations](https://github.com/KhronosGroup/3DC-Metadata-Recommendations/blob/main/model3d.md).
 *
 * Properties:
 * - {@link Packet}
 *
 * ### Example
 *
 * ```typescript
 * import { KHRXMP, Packet } from '@gltf-transform/extensions';
 *
 * // Create an Extension attached to the Document.
 * const xmpExtension = document.createExtension(KHRXMP);
 *
 * // Create Packet property.
 * const packet = xmpExtension.createPacket()
 * 	.setContext({
 * 		dc: 'http://purl.org/dc/elements/1.1/',
 * 	})
 *	.setProperty('dc:Creator', {"@list": ["Acme, Inc."]});
 *
 * // Option 1: Assign to Document Root.
 * document.getRoot().setExtension('KHR_xmp_json_ld', packet);
 *
 * // Option 2: Assign to a specific Property.
 * texture.setExtension('KHR_xmp_json_ld', packet);
 * ```
 */
class KHRXMP extends Extension {
  constructor(...args) {
    super(...args);
    this.extensionName = NAME;
  }
  /** Creates a new XMP packet, to be linked with a {@link Document} or {@link Property Properties}. */
  createPacket() {
    return new Packet(this.document.getGraph());
  }
  /** Lists XMP packets currently defined in a {@link Document}. */
  listPackets() {
    return Array.from(this.properties);
  }
  /** @hidden */
  read(context) {
    var _context$jsonDoc$json;
    const extensionDef = (_context$jsonDoc$json = context.jsonDoc.json.extensions) == null ? void 0 : _context$jsonDoc$json[NAME];
    if (!extensionDef || !extensionDef.packets) return this;
    // Deserialize packets.
    const json = context.jsonDoc.json;
    const root = this.document.getRoot();
    const packets = extensionDef.packets.map(packetDef => this.createPacket().fromJSONLD(packetDef));
    const defLists = [[json.asset], json.scenes, json.nodes, json.meshes, json.materials, json.images, json.animations];
    const propertyLists = [[root], root.listScenes(), root.listNodes(), root.listMeshes(), root.listMaterials(), root.listTextures(), root.listAnimations()];
    // Assign packets.
    for (let i = 0; i < defLists.length; i++) {
      const defs = defLists[i] || [];
      for (let j = 0; j < defs.length; j++) {
        const def = defs[j];
        if (def.extensions && def.extensions[NAME]) {
          const xmpDef = def.extensions[NAME];
          propertyLists[i][j].setExtension(NAME, packets[xmpDef.packet]);
        }
      }
    }
    return this;
  }
  /** @hidden */
  write(context) {
    const {
      json
    } = context.jsonDoc;
    const packetDefs = [];
    for (const packet of this.properties) {
      // Serialize packets.
      packetDefs.push(packet.toJSONLD());
      // Assign packets.
      for (const parent of packet.listParents()) {
        let parentDef;
        switch (parent.propertyType) {
          case PropertyType.ROOT:
            parentDef = json.asset;
            break;
          case PropertyType.SCENE:
            parentDef = json.scenes[context.sceneIndexMap.get(parent)];
            break;
          case PropertyType.NODE:
            parentDef = json.nodes[context.nodeIndexMap.get(parent)];
            break;
          case PropertyType.MESH:
            parentDef = json.meshes[context.meshIndexMap.get(parent)];
            break;
          case PropertyType.MATERIAL:
            parentDef = json.materials[context.materialIndexMap.get(parent)];
            break;
          case PropertyType.TEXTURE:
            parentDef = json.images[context.imageIndexMap.get(parent)];
            break;
          case PropertyType.ANIMATION:
            parentDef = json.animations[context.animationIndexMap.get(parent)];
            break;
          default:
            parentDef = null;
            this.document.getLogger().warn(`[${NAME}]: Unsupported parent property, "${parent.propertyType}"`);
            break;
        }
        if (!parentDef) continue;
        parentDef.extensions = parentDef.extensions || {};
        parentDef.extensions[NAME] = {
          packet: packetDefs.length - 1
        };
      }
    }
    if (packetDefs.length > 0) {
      json.extensions = json.extensions || {};
      json.extensions[NAME] = {
        packets: packetDefs
      };
    }
    return this;
  }
}
KHRXMP.EXTENSION_NAME = NAME;

const KHRONOS_EXTENSIONS = [KHRDracoMeshCompression, KHRLightsPunctual, KHRMaterialsAnisotropy, KHRMaterialsClearcoat, KHRMaterialsDiffuseTransmission, KHRMaterialsDispersion, KHRMaterialsEmissiveStrength, KHRMaterialsIOR, KHRMaterialsIridescence, KHRMaterialsPBRSpecularGlossiness, KHRMaterialsSpecular, KHRMaterialsSheen, KHRMaterialsTransmission, KHRMaterialsUnlit, KHRMaterialsVariants, KHRMaterialsVolume, KHRMeshQuantization, KHRTextureBasisu, KHRTextureTransform, KHRXMP];
const ALL_EXTENSIONS = [EXTMeshGPUInstancing, EXTMeshoptCompression, EXTTextureAVIF, EXTTextureWebP, ...KHRONOS_EXTENSIONS];

var DracoDecoderModule = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(DracoDecoderModule = {})  {

var Module=typeof DracoDecoderModule!="undefined"?DracoDecoderModule:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject;});var isRuntimeInitialized=false;var isModuleParsed=false;Module["onRuntimeInitialized"]=function(){isRuntimeInitialized=true;if(isModuleParsed){if(typeof Module["onModuleLoaded"]==="function"){Module["onModuleLoaded"](Module);}}};Module["onModuleParsed"]=function(){isModuleParsed=true;if(isRuntimeInitialized){if(typeof Module["onModuleLoaded"]==="function"){Module["onModuleLoaded"](Module);}}};function isVersionSupported(versionString){if(typeof versionString!=="string")return false;const version=versionString.split(".");if(version.length<2||version.length>3)return false;if(version[0]==1&&version[1]>=0&&version[1]<=5)return true;if(version[0]!=0||version[1]>10)return false;return true}Module["isVersionSupported"]=isVersionSupported;var moduleOverrides=Object.assign({},Module);var ENVIRONMENT_IS_WEB=true;var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=false;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var readAsync,readBinary;{if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href;}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src;}if(_scriptDir){scriptDirectory=_scriptDir;}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1);}else {scriptDirectory="";}{if(ENVIRONMENT_IS_WORKER){readBinary=url=>{try{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}catch(err){var data=tryParseAsDataURI(url);if(data){return data}throw err}};}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}var data=tryParseAsDataURI(url);if(data){onload(data.buffer);return}onerror();};xhr.onerror=onerror;xhr.send(null);};}}Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])Module["arguments"];if(Module["thisProgram"])Module["thisProgram"];if(Module["quit"])Module["quit"];var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];Module["noExitRuntime"]||true;var WebAssembly={Memory:function(opts){this.buffer=new ArrayBuffer(opts["initial"]*65536);},Module:function(binary){},Instance:function(module,info){this.exports=(
// EMSCRIPTEN_START_ASM
function instantiate(ia){function c(d){d.set=function(a,b){this[a]=b;};d.get=function(a){return this[a]};return d}var e;var f=new Uint8Array(123);for(var a=25;a>=0;--a){f[48+a]=52+a;f[65+a]=a;f[97+a]=26+a;}f[43]=62;f[47]=63;function l(m,n,o){var g,h,a=0,i=n,j=o.length,k=n+(j*3>>2)-(o[j-2]=="=")-(o[j-1]=="=");for(;a<j;a+=4){g=f[o.charCodeAt(a+1)];h=f[o.charCodeAt(a+2)];m[i++]=f[o.charCodeAt(a)]<<2|g>>4;if(i<k)m[i++]=g<<4|h>>2;if(i<k)m[i++]=h<<6|f[o.charCodeAt(a+3)];}}function p(q){l(e,1028,"YAQAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAE41ZHJhY28yOEF0dHJpYnV0ZU9jdGFoZWRyb25UcmFuc2Zvcm1FAADYKwAAOAQAAOAGAABfX25leHRfcHJpbWUgb3ZlcmZsb3cAdmVjdG9yAHN0ZDo6ZXhjZXB0aW9uAHNraXBfYXR0cmlidXRlX3RyYW5zZm9ybQBiYWRfYXJyYXlfbmV3X2xlbmd0aABiYXNpY19zdHJpbmcAc3RkOjpiYWRfYWxsb2MARFJBQ08AVXNpbmcgaW5jb21wYXRpYmxlIGRlY29kZXIgZm9yIHRoZSBpbnB1dCBnZW9tZXRyeS4ARmFpbGVkIHRvIGRlY29kZSBwb2ludCBhdHRyaWJ1dGVzLgBGYWlsZWQgdG8gaW5pdGlhbGl6ZSB0aGUgZGVjb2Rlci4AVW5zdXBwb3J0ZWQgbWlub3IgdmVyc2lvbi4AVW5zdXBwb3J0ZWQgbWFqb3IgdmVyc2lvbi4ASW5wdXQgaXMgbm90IGEgbWVzaC4AVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZS4ATm90IGEgRHJhY28gZmlsZS4AVW5zdXBwb3J0ZWQgZW5jb2RpbmcgbWV0aG9kLgBGYWlsZWQgdG8gZGVjb2RlIG1ldGFkYXRhLgBGYWlsZWQgdG8gZGVjb2RlIGdlb21ldHJ5IGRhdGEuAFB1cmUgdmlydHVhbCBmdW5jdGlvbiBjYWxsZWQhAAAAAAAAALQGAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAALAAAAGAAAABkAAABONWRyYWNvMzBBdHRyaWJ1dGVRdWFudGl6YXRpb25UcmFuc2Zvcm1FAAAAANgrAACIBgAA4AYAAE41ZHJhY28xOEF0dHJpYnV0ZVRyYW5zZm9ybUUAAAAAsCsAAMAGAAAAAAAAbAcAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAAE41ZHJhY28xN0F0dHJpYnV0ZXNEZWNvZGVyRQBONWRyYWNvMjZBdHRyaWJ1dGVzRGVjb2RlckludGVyZmFjZUUAAAAAsCsAADwHAADYKwAAIAcAAGQHAAAAAAAAzAcAACYAAAAnAAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAE41ZHJhY28yNlNlcXVlbnRpYWxBdHRyaWJ1dGVEZWNvZGVyRQAAAACwKwAApAcAAP////8AAAAARAgAAC8AAAAwAAAAHAAAADEAAAAyAAAAHwAAACAAAAAhAAAAMwAAADQAAAA1AAAANgAAADcAAABONWRyYWNvMzdTZXF1ZW50aWFsQXR0cmlidXRlRGVjb2RlcnNDb250cm9sbGVyRQDYKwAAFAgAAGwHAAAAAAAAuAgAADgAAAA5AAAAOgAAACkAAAAqAAAAKwAAADsAAAAtAAAAPAAAAD0AAAA+AAAAPwAAAEAAAABONWRyYWNvMzNTZXF1ZW50aWFsSW50ZWdlckF0dHJpYnV0ZURlY29kZXJFANgrAACMCAAAzAcAAAAAAABECwAAQQAAAEIAAABDAAAARAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATjVkcmFjbzQwTWVzaFByZWRpY3Rpb25TY2hlbWVQYXJhbGxlbG9ncmFtRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY28yN01lc2hQcmVkaWN0aW9uU2NoZW1lRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY28yM1ByZWRpY3Rpb25TY2hlbWVEZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRUVFAE41ZHJhY28zN1ByZWRpY3Rpb25TY2hlbWVUeXBlZERlY29kZXJJbnRlcmZhY2VJaWlFRQBONWRyYWNvMzJQcmVkaWN0aW9uU2NoZW1lRGVjb2RlckludGVyZmFjZUUATjVkcmFjbzI1UHJlZGljdGlvblNjaGVtZUludGVyZmFjZUUAsCsAAOgKAADYKwAAvQoAAAwLAADYKwAAiQoAABQLAADYKwAANQoAACALAADYKwAAnwkAACwLAADYKwAA/AgAADgLAAAAAAAAOAsAAEEAAABNAAAAIwAAAEQAAAAjAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAAIwAAAAAAAAAsCwAAQQAAAE4AAAAjAAAARAAAACMAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAAAjAAAAAAAAAKwMAABPAAAAUAAAAFEAAABEAAAAUgAAAEYAAABHAAAASAAAAEkAAABKAAAAUwAAAFQAAABONWRyYWNvNTZNZXNoUHJlZGljdGlvblNjaGVtZUNvbnN0cmFpbmVkTXVsdGlQYXJhbGxlbG9ncmFtRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAADYKwAA+AsAADgLAAAAAAAAmA0AAFUAAABWAAAAVwAAAEQAAABYAAAAWQAAAFoAAABbAAAASQAAAEoAAABcAAAAXQAAAE41ZHJhY280NE1lc2hQcmVkaWN0aW9uU2NoZW1lVGV4Q29vcmRzUG9ydGFibGVEZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUAANgrAADwDAAAOAsAAAAAAACEDgAAXgAAAF8AAABgAAAARAAAAGEAAABiAAAAYwAAAGQAAABJAAAASgAAAGUAAABmAAAATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxEZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUAAAAA2CsAANwNAAA4CwAAAAAAAAwQAABnAAAAaAAAAGkAAABqAAAAawAAAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQXJlYUlpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQmFzZUlpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAAAAsCsAAFcPAADYKwAArA4AAAQQAAAAAAAABBAAAGcAAABsAAAAIwAAAGoAAAAjAAAAAAAAAJgRAABBAAAAbQAAAG4AAABEAAAAbwAAAEYAAABHAAAASAAAAEkAAABKAAAASwAAAHAAAABONWRyYWNvNDBNZXNoUHJlZGljdGlvblNjaGVtZVBhcmFsbGVsb2dyYW1EZWNvZGVySWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMjdNZXNoUHJlZGljdGlvblNjaGVtZURlY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBEZWNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAADYKwAAAhEAACwLAADYKwAAbBAAAIwRAAAAAAAAjBEAAEEAAABxAAAAIwAAAEQAAAAjAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAAIwAAAAAAAAC8EgAAcgAAAHMAAAB0AAAARAAAAHUAAABGAAAARwAAAEgAAABJAAAASgAAAHYAAAB3AAAATjVkcmFjbzU2TWVzaFByZWRpY3Rpb25TY2hlbWVDb25zdHJhaW5lZE11bHRpUGFyYWxsZWxvZ3JhbURlY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBEZWNvZGluZ1RyYW5zZm9ybUlpaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAAAA2CsAABQSAACMEQAAAAAAAJwTAAB4AAAAeQAAAHoAAABEAAAAewAAAHwAAAB9AAAAfgAAAEkAAABKAAAAfwAAAIAAAABONWRyYWNvNDRNZXNoUHJlZGljdGlvblNjaGVtZVRleENvb3Jkc1BvcnRhYmxlRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUAAADYKwAAABMAAIwRAAAAAAAAeBQAAIEAAACCAAAAgwAAAEQAAACEAAAAhQAAAIYAAACHAAAASQAAAEoAAACIAAAAiQAAAE41ZHJhY280Mk1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsRGVjb2RlcklpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUA2CsAAOATAACMEQAAAAAAAOQVAACKAAAAiwAAAIwAAACNAAAAjgAAAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQXJlYUlpTlNfMzdQcmVkaWN0aW9uU2NoZW1lV3JhcERlY29kaW5nVHJhbnNmb3JtSWlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JCYXNlSWlOU18zN1ByZWRpY3Rpb25TY2hlbWVXcmFwRGVjb2RpbmdUcmFuc2Zvcm1JaWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQCwKwAAPhUAANgrAACgFAAA3BUAAAAAAADcFQAAigAAAI8AAAAjAAAAjQAAACMAAAAAAAAAoBYAAEEAAACQAAAAkQAAAEQAAACSAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAAkwAAAE41ZHJhY28yOFByZWRpY3Rpb25TY2hlbWVEZWx0YURlY29kZXJJaU5TXzM3UHJlZGljdGlvblNjaGVtZVdyYXBEZWNvZGluZ1RyYW5zZm9ybUlpaUVFRUUAAAAA2CsAAEQWAAAsCwAAAAAAABQXAACUAAAAlQAAAJYAAAApAAAAKgAAAJcAAAA7AAAALQAAADwAAACYAAAAmQAAAJoAAACbAAAATjVkcmFjbzMyU2VxdWVudGlhbE5vcm1hbEF0dHJpYnV0ZURlY29kZXJFAADYKwAA6BYAALgIAAAAAAAASBkAAJwAAACdAAAAngAAAJ8AAACgAAAAoQAAAKIAAACjAAAApAAAAKUAAACmAAAApwAAAE41ZHJhY280Mk1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsRGVjb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWREZWNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY28yN01lc2hQcmVkaWN0aW9uU2NoZW1lRGVjb2RlcklpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWREZWNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY28yM1ByZWRpY3Rpb25TY2hlbWVEZWNvZGVySWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZERlY29kaW5nVHJhbnNmb3JtSWlFRUVFAADYKwAAwxgAACALAADYKwAAFRgAADAZAADYKwAAWBcAADwZAAAAAAAAABsAAKgAAACpAAAAqgAAAKsAAACsAAAATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JBcmVhSWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZERlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUATjVkcmFjbzQ4TWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxQcmVkaWN0b3JCYXNlSWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZERlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzI0TWVzaEF0dHJpYnV0ZUNvcm5lclRhYmxlRUVFRUUAAACwKwAAMxoAANgrAABwGQAA+BoAAAAAAACkHAAArQAAAK4AAACvAAAAnwAAALAAAACxAAAAsgAAALMAAACkAAAApQAAALQAAAC1AAAATjVkcmFjbzQyTWVzaFByZWRpY3Rpb25TY2hlbWVHZW9tZXRyaWNOb3JtYWxEZWNvZGVySWlOU182MlByZWRpY3Rpb25TY2hlbWVOb3JtYWxPY3RhaGVkcm9uQ2Fub25pY2FsaXplZERlY29kaW5nVHJhbnNmb3JtSWlFRU5TXzI0TWVzaFByZWRpY3Rpb25TY2hlbWVEYXRhSU5TXzExQ29ybmVyVGFibGVFRUVFRQBONWRyYWNvMjdNZXNoUHJlZGljdGlvblNjaGVtZURlY29kZXJJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRGVjb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAAAAANgrAAD0GwAAMBkAANgrAABEGwAAmBwAAAAAAABAHgAAtgAAALcAAAC4AAAAuQAAALoAAABONWRyYWNvNDhNZXNoUHJlZGljdGlvblNjaGVtZUdlb21ldHJpY05vcm1hbFByZWRpY3RvckFyZWFJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRGVjb2RpbmdUcmFuc2Zvcm1JaUVFTlNfMjRNZXNoUHJlZGljdGlvblNjaGVtZURhdGFJTlNfMTFDb3JuZXJUYWJsZUVFRUVFAE41ZHJhY280OE1lc2hQcmVkaWN0aW9uU2NoZW1lR2VvbWV0cmljTm9ybWFsUHJlZGljdG9yQmFzZUlpTlNfNjJQcmVkaWN0aW9uU2NoZW1lTm9ybWFsT2N0YWhlZHJvbkNhbm9uaWNhbGl6ZWREZWNvZGluZ1RyYW5zZm9ybUlpRUVOU18yNE1lc2hQcmVkaWN0aW9uU2NoZW1lRGF0YUlOU18xMUNvcm5lclRhYmxlRUVFRUUAsCsAAIIdAADYKwAAzBwAADgeAAAAAAAA+B4AALsAAAC8AAAAvQAAAJ8AAAC+AAAAvwAAAMAAAADBAAAApAAAAKUAAADCAAAAwwAAAE41ZHJhY28yOFByZWRpY3Rpb25TY2hlbWVEZWx0YURlY29kZXJJaU5TXzYyUHJlZGljdGlvblNjaGVtZU5vcm1hbE9jdGFoZWRyb25DYW5vbmljYWxpemVkRGVjb2RpbmdUcmFuc2Zvcm1JaUVFRUUAAAAA2CsAAIQeAAAwGQAAAAAAAHwfAADEAAAAxQAAAMYAAAApAAAAKgAAAMcAAAA7AAAALQAAADwAAADIAAAAPgAAAD8AAADJAAAAygAAAMsAAABONWRyYWNvMzhTZXF1ZW50aWFsUXVhbnRpemF0aW9uQXR0cmlidXRlRGVjb2RlckUAAAAA2CsAAEgfAAC4CAAAAAAAANwfAADMAAAAzQAAAM4AAADPAAAAIwAAANAAAADRAAAA0gAAANMAAADUAAAA1QAAANYAAAAjAAAATjVkcmFjbzExTWVzaERlY29kZXJFAAAA2CsAAMQfAACcJwAAAAAAAEggAADXAAAA2AAAAM4AAADZAAAA2gAAANAAAADRAAAA0gAAANsAAADcAAAA3QAAAN4AAADfAAAATjVkcmFjbzIyTWVzaEVkZ2VicmVha2VyRGVjb2RlckUAAAAA2CsAACQgAADcHwAAAAAAADwhAADgAAAA4QAAAOIAAADjAAAA5AAAAOUAAADmAAAA5wAAAOgAAADpAAAA/////wAAAACcIQAA6gAAAOsAAADsAAAA7QAAAO4AAADvAAAA8AAAAPEAAADyAAAA8wAAAE41ZHJhY28yNk1lc2hFZGdlYnJlYWtlckRlY29kZXJJbXBsSU5TXzMxTWVzaEVkZ2VicmVha2VyVHJhdmVyc2FsRGVjb2RlckVFRQBONWRyYWNvMzVNZXNoRWRnZWJyZWFrZXJEZWNvZGVySW1wbEludGVyZmFjZUUAAACwKwAABCEAANgrAAC4IAAANCEAAE41ZHJhY28yNk1lc2hFZGdlYnJlYWtlckRlY29kZXJJbXBsSU5TXzM4TWVzaEVkZ2VicmVha2VyVHJhdmVyc2FsVmFsZW5jZURlY29kZXJFRUUAANgrAABIIQAANCEAAAAAAACYIgAA9AAAAPUAAAD2AAAATjVkcmFjbzE5RGVwdGhGaXJzdFRyYXZlcnNlcklOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVOU18zNk1lc2hBdHRyaWJ1dGVJbmRpY2VzRW5jb2RpbmdPYnNlcnZlcklTMV9FRUVFAE41ZHJhY28xM1RyYXZlcnNlckJhc2VJTlNfMjRNZXNoQXR0cmlidXRlQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzFfRUVFRQCwKwAAKSIAANgrAAC8IQAAkCIAAAAAAACQIgAA9wAAAPgAAAD2");l(e,8900,"AQAAAAMAAAAFAAAABwAAAAAAAACYIwAA+QAAAPoAAAD7AAAA/AAAAE41ZHJhY28yMk1lc2hUcmF2ZXJzYWxTZXF1ZW5jZXJJTlNfMjhNYXhQcmVkaWN0aW9uRGVncmVlVHJhdmVyc2VySU5TXzExQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzJfRUVFRUVFAE41ZHJhY28xNVBvaW50c1NlcXVlbmNlckUAAAAAsCsAAHMjAADYKwAA7CIAAJAjAAD/////AAAAAIgkAAD9AAAA/gAAAP8AAABONWRyYWNvMjhNYXhQcmVkaWN0aW9uRGVncmVlVHJhdmVyc2VySU5TXzExQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzFfRUVFRQBONWRyYWNvMTNUcmF2ZXJzZXJCYXNlSU5TXzExQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzFfRUVFRQAAsCsAACUkAADYKwAAvCMAAIAkAAAAAAAAgCQAAAABAAABAQAA/wAAAAAAAABAJQAAAgEAAAMBAAAEAQAABQEAAE41ZHJhY28yMk1lc2hUcmF2ZXJzYWxTZXF1ZW5jZXJJTlNfMTlEZXB0aEZpcnN0VHJhdmVyc2VySU5TXzExQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzJfRUVFRUVFAAAA2CsAAMAkAACQIwAAAAAAAMAlAAAGAQAABwEAAP8AAABONWRyYWNvMTlEZXB0aEZpcnN0VHJhdmVyc2VySU5TXzExQ29ybmVyVGFibGVFTlNfMzZNZXNoQXR0cmlidXRlSW5kaWNlc0VuY29kaW5nT2JzZXJ2ZXJJUzFfRUVFRQDYKwAAYCUAAIAkAAAAAAAAcCYAAAgBAAAJAQAACgEAAAsBAABONWRyYWNvMjJNZXNoVHJhdmVyc2FsU2VxdWVuY2VySU5TXzE5RGVwdGhGaXJzdFRyYXZlcnNlcklOU18yNE1lc2hBdHRyaWJ1dGVDb3JuZXJUYWJsZUVOU18zNk1lc2hBdHRyaWJ1dGVJbmRpY2VzRW5jb2RpbmdPYnNlcnZlcklTMl9FRUVFRUUAANgrAADkJQAAkCM=");l(e,9860,"3CYAAMwAAAAMAQAAzgAAAM8AAAANAQAA0AAAANEAAADSAAAA0wAAANQAAADVAAAA1gAAAA4BAABONWRyYWNvMjFNZXNoU2VxdWVudGlhbERlY29kZXJFANgrAAC8JgAA3B8AAAAAAAAcJwAADwEAABABAAARAQAAEgEAAE41ZHJhY28xNUxpbmVhclNlcXVlbmNlckUAAADYKwAAACcAAJAjAAAAAAAAnCcAAMwAAAATAQAAFAEAAM8AAAAjAAAAFQEAANEAAADSAAAA0w==");l(e,10080,"RmFpbGVkIHRvIHBhcnNlIERyYWNvIGhlYWRlci4ATjVkcmFjbzE3UG9pbnRDbG91ZERlY29kZXJFAAAAsCsAAH4nAAABAAAAAQAAAAIAAAACAAAABAAAAAQAAAAIAAAACAAAAAQAAAAIAAAAAQ==");l(e,10211,"wAAAAMAAAADAAAAAwP//////////AAAAACAoAAAWAQAAFwEAABgBAAAZAQAATjVkcmFjbzRNZXNoRQAAANgrAAAQKAAAZCgAAP////8AAAAAAAAAAGQoAAAaAQAAGwEAABwBAAAdAQAATjVkcmFjbzEwUG9pbnRDbG91ZEUAAAAAsCsAAEwo");l(e,10356,"AgAAAAMAAAAFAAAABwAAAAsAAAANAAAAEQAAABMAAAAXAAAAHQAAAB8AAAAlAAAAKQAAACsAAAAvAAAANQAAADsAAAA9AAAAQwAAAEcAAABJAAAATwAAAFMAAABZAAAAYQAAAGUAAABnAAAAawAAAG0AAABxAAAAfwAAAIMAAACJAAAAiwAAAJUAAACXAAAAnQAAAKMAAACnAAAArQAAALMAAAC1AAAAvwAAAMEAAADFAAAAxwAAANMAAAABAAAACwAAAA0AAAARAAAAEwAAABcAAAAdAAAAHwAAACUAAAApAAAAKwAAAC8AAAA1AAAAOwAAAD0AAABDAAAARwAAAEkAAABPAAAAUwAAAFkAAABhAAAAZQAAAGcAAABrAAAAbQAAAHEAAAB5AAAAfwAAAIMAAACJAAAAiwAAAI8AAACVAAAAlwAAAJ0AAACjAAAApwAAAKkAAACtAAAAswAAALUAAAC7AAAAvwAAAMEAAADFAAAAxwAAANEAAAAAAAAACgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUAypo7AAAAAAAAAAAwMDAxMDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMDMxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4ODk5MDkxOTI5Mzk0OTU5Njk3OTg5OU4xMF9fY3h4YWJpdjExNl9fc2hpbV90eXBlX2luZm9FAAAAANgrAADoKgAAbC0AAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQAAANgrAAAYKwAADCsAAE4xMF9fY3h4YWJpdjExN19fcGJhc2VfdHlwZV9pbmZvRQAAANgrAABIKwAADCsAAE4xMF9fY3h4YWJpdjExOV9fcG9pbnRlcl90eXBlX2luZm9FANgrAAB4KwAAbCsAAAAAAAA8KwAAHgEAAB8BAAAgAQAAIQEAACIBAAAjAQAAJAEAACUBAAAAAAAAICwAAB4BAAAmAQAAIAEAACEBAAAiAQAAJwEAACgBAAApAQAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAANgrAAD4KwAAPCsAAAAAAACQLAAADgAAACoBAAArAQAAAAAAALgsAAAOAAAALAEAAC0BAAAAAAAAeCwAAA4AAAAuAQAALwEAAFN0OWV4Y2VwdGlvbgAAAACwKwAAaCwAAFN0OWJhZF9hbGxvYwAAAADYKwAAgCwAAHgsAABTdDIwYmFkX2FycmF5X25ld19sZW5ndGgAAAAA2CsAAJwsAACQLAAAAAAAAOgsAAABAAAAMAEAADEBAABTdDExbG9naWNfZXJyb3IA2CsAANgsAAB4LAAAAAAAABwtAAABAAAAMgEAADEBAABTdDEybGVuZ3RoX2Vycm9yAAAAANgrAAAILQAA6CwAAAAAAABQLQAAAQAAADMBAAAxAQAAU3QxMm91dF9vZl9yYW5nZQAAAADYKwAAPC0AAOgsAABTdDl0eXBlX2luZm8AAAAAsCsAAFwt");l(e,11636,"8C8B");}var r=new ArrayBuffer(16);var s=new Int32Array(r);var t=new Float32Array(r);function v(){throw new Error("abort")}function w(x){t[2]=x;}function y(z){return s[z]}function ha(q){var A=q.a;var B=A.a;var C=B.buffer;B.grow=fa;var D=new Int8Array(C);var E=new Int16Array(C);var F=new Int32Array(C);var G=new Uint8Array(C);var H=new Uint16Array(C);var I=new Uint32Array(C);var J=new Float32Array(C);var K=new Float64Array(C);var L=Math.imul;var M=Math.fround;var N=Math.abs;var O=Math.clz32;var P=Math.min;var Q=Math.max;var R=Math.floor;var S=Math.ceil;var U=Math.sqrt;var V=A.b;var W=A.c;var X=A.d;var Y=A.e;var Z=77808;var _=0;
// EMSCRIPTEN_START_FUNCS
function mc(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;if(!a){return 1}e=F[c+20>>2];o=F[c+12>>2];g=F[c+16>>2];a:{if((e|0)>=(o|0)&g>>>0>=I[c+8>>2]|(e|0)>(o|0)){break a}o=G[g+F[c>>2]|0];g=g+1|0;e=g?e:e+1|0;F[c+16>>2]=g;F[c+20>>2]=e;b:{switch(o|0){case 0:e=a;f=b;g=d;a=0;d=0;j=Z+-64|0;Z=j;F[j+56>>2]=0;F[j+48>>2]=0;F[j+52>>2]=0;F[j+40>>2]=0;F[j+44>>2]=0;F[j+32>>2]=0;F[j+36>>2]=0;F[j+24>>2]=0;F[j+28>>2]=0;F[j+16>>2]=0;F[j+20>>2]=0;F[j+8>>2]=0;F[j+12>>2]=0;c:{if(!Nd(j+8|0,c)){break c}if(!Md(j+8|0,c)|(F[j+20>>2]?0:e)){break c}hc(c,0,0);if(e){s=f<<2;t=F[j+36>>2];u=F[j+48>>2];x=F[j+24>>2];l=F[j+56>>2];i=F[j+52>>2];while(1){d:{if(l>>>0>16383){break d}while(1){if((i|0)<=0){break d}i=i-1|0;F[j+52>>2]=i;l=G[i+u|0]|l<<8;F[j+56>>2]=l;if(l>>>0<16384){continue}break}}a=l&4095;r=F[(a<<2)+x>>2];b=(r<<3)+t|0;l=(L(F[b>>2],l>>>12|0)+a|0)-F[b+4>>2]|0;F[j+56>>2]=l;if((f|0)>0){a=0;if(!G[c+36|0]|r>>>0>32){break c}o=d+f|0;e:{if(!r){ma(g+(d<<2)|0,0,s);break e}y=r&-2;z=r&1;b=F[c+32>>2];h=F[c+28>>2];q=F[c+24>>2];while(1){k=0;a=b;m=0;n=0;if((r|0)!=1){while(1){p=q+(a>>>3|0)|0;f:{if(p>>>0>=h>>>0){p=0;break f}p=G[p|0];b=a+1|0;F[c+32>>2]=b;p=p>>>(a&7)&1;a=b;}p=p<<k|m;m=0;v=q+(a>>>3|0)|0;if(v>>>0<h>>>0){m=G[v|0];b=a+1|0;F[c+32>>2]=b;m=m>>>(a&7)&1;a=b;}v=k|1;k=k+2|0;m=p|m<<v;n=n+2|0;if((y|0)!=(n|0)){continue}break}}n=g+(d<<2)|0;if(z){p=q+(a>>>3|0)|0;if(p>>>0<h>>>0){p=G[p|0];b=a+1|0;F[c+32>>2]=b;a=p>>>(a&7)&1;}else {a=0;}m=a<<k|m;}F[n>>2]=m;d=d+1|0;if((o|0)!=(d|0)){continue}break}}d=o;}w=f+w|0;if(e>>>0>w>>>0){continue}break}}D[c+36|0]=0;f=F[c+20>>2];a=0;m=F[c+32>>2]+7|0;a=m>>>0<7?1:a;m=a<<29|m>>>3;b=m+F[c+16>>2]|0;a=(a>>>3|0)+f|0;F[c+16>>2]=b;F[c+20>>2]=b>>>0<m>>>0?a+1|0:a;a=1;}b=F[j+36>>2];if(b){F[j+40>>2]=b;ja(b);}b=F[j+24>>2];if(b){F[j+28>>2]=b;ja(b);}b=F[j+8>>2];if(b){F[j+12>>2]=b;ja(b);}Z=j- -64|0;return a;case 1:break b;default:break a}}b=0;e=F[c+20>>2];o=F[c+12>>2];g=F[c+16>>2];g:{if((e|0)>=(o|0)&g>>>0>=I[c+8>>2]|(e|0)>(o|0)){break g}o=G[g+F[c>>2]|0];g=g+1|0;e=g?e:e+1|0;F[c+16>>2]=g;F[c+20>>2]=e;h:{switch(o-1|0){case 8:o=a;r=d;e=Z+-64|0;Z=e;F[e+56>>2]=0;F[e+48>>2]=0;F[e+52>>2]=0;F[e+40>>2]=0;F[e+44>>2]=0;F[e+32>>2]=0;F[e+36>>2]=0;F[e+24>>2]=0;F[e+28>>2]=0;F[e+16>>2]=0;F[e+20>>2]=0;F[e+8>>2]=0;F[e+12>>2]=0;h=e+8|0;i:{j:{if(!H[c+38>>1]){break j}if(!Ta(1,h+12|0,c)){break j}b=F[c+8>>2];d=F[c+16>>2];f=b-d|0;i=F[h+12>>2];b=F[c+12>>2]-(F[c+20>>2]+(b>>>0<d>>>0)|0)|0;if(f>>>0<i>>>6>>>0&(b|0)<=0|(b|0)<0){break j}b=F[h>>2];a=F[h+4>>2]-b>>2;k:{if(a>>>0<i>>>0){qa(h,i-a|0);i=F[h+12>>2];break k}if(a>>>0<=i>>>0){break k}F[h+4>>2]=b+(i<<2);}g=1;if(!i){break i}f=F[c+16>>2];d=F[c+20>>2];s=F[h>>2];j=F[c+8>>2];n=F[c+12>>2];b=0;while(1){g=0;if((d|0)>=(n|0)&f>>>0>=j>>>0|(d|0)>(n|0)){break i}g=F[c>>2];p=G[g+f|0];a=d;f=f+1|0;a=f?a:a+1|0;F[c+16>>2]=f;d=a;F[c+20>>2]=a;a=p>>>2|0;l=0;l:{m:{n:{o:{t=p&3;switch(t|0){case 0:break m;case 3:break o;default:break n}}a=a+b|0;g=0;if(a>>>0>=i>>>0){break i}ma(s+(b<<2)|0,0,(p&252)+4|0);b=a;break l}while(1){if((f|0)==(j|0)&(d|0)==(n|0)){break j}i=G[f+g|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;a=i<<(l<<3|6)|a;l=l+1|0;if((t|0)!=(l|0)){continue}break}}F[s+(b<<2)>>2]=a;}b=b+1|0;i=F[h+12>>2];if(b>>>0<i>>>0){continue}break}a=h+16|0;n=F[h>>2];d=F[h+16>>2];b=F[h+20>>2]-d|0;p:{if(b>>>0<=32767){qa(a,8192-(b>>>2|0)|0);break p}if((b|0)==32768){break p}F[h+20>>2]=d+32768;}d=h+28|0;b=F[d>>2];f=F[h+32>>2]-b>>3;q:{if(f>>>0<i>>>0){_a(d,i-f|0);b=F[d>>2];break q}if(f>>>0>i>>>0){F[h+32>>2]=(i<<3)+b;}if(!i){break j}}j=F[a>>2];f=0;d=0;while(1){g=n+(f<<2)|0;l=F[g>>2];h=(f<<3)+b|0;a=d;F[h+4>>2]=a;F[h>>2]=l;g=F[g>>2];d=g+a|0;if(d>>>0>8192){break j}r:{if(a>>>0>=d>>>0){break r}l=0;h=g&7;if(h){while(1){F[j+(a<<2)>>2]=f;a=a+1|0;l=l+1|0;if((h|0)!=(l|0)){continue}break}}if(g-1>>>0<=6){break r}while(1){g=j+(a<<2)|0;F[g>>2]=f;F[g+28>>2]=f;F[g+24>>2]=f;F[g+20>>2]=f;F[g+16>>2]=f;F[g+12>>2]=f;F[g+8>>2]=f;F[g+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((i|0)!=(f|0)){continue}break}k=(d|0)==8192;}g=k;}s:{if(!g|(F[e+20>>2]?0:o)){break s}d=0;k=Z-16|0;Z=k;t:{if(!Sa(1,k+8|0,c)){break t}a=F[c+8>>2];f=F[c+16>>2];g=a-f|0;j=F[k+12>>2];i=F[c+20>>2];a=F[c+12>>2]-(i+(a>>>0<f>>>0)|0)|0;b=F[k+8>>2];if((j|0)==(a|0)&g>>>0<b>>>0|a>>>0<j>>>0){break t}a=i+j|0;g=b+f|0;a=g>>>0<f>>>0?a+1|0:a;F[c+16>>2]=g;F[c+20>>2]=a;if((b|0)<=0){break t}a=f+F[c>>2]|0;F[e+48>>2]=a;c=b-1|0;f=c+a|0;g=G[f|0];u:{if(g>>>0<=63){F[e+52>>2]=c;a=G[f|0]&63;break u}v:{switch((g>>>6|0)-1|0){case 0:if(b>>>0<2){break t}b=b-2|0;F[e+52>>2]=b;a=a+b|0;a=G[a+1|0]<<8&16128|G[a|0];break u;case 1:if(b>>>0<3){break t}b=b-3|0;F[e+52>>2]=b;a=a+b|0;a=G[a+1|0]<<8|G[a+2|0]<<16&4128768|G[a|0];break u;default:break v}}b=b-4|0;F[e+52>>2]=b;a=a+b|0;a=(G[a|0]|G[a+1|0]<<8|(G[a+2|0]<<16|G[a+3|0]<<24))&1073741823;}F[e+56>>2]=a+32768;d=a>>>0<8355840;}Z=k+16|0;if(!d){break s}if(!o){m=1;break s}b=F[e+52>>2];a=F[e+56>>2];c=F[e+36>>2];d=F[e+48>>2];f=F[e+24>>2];while(1){w:{if(a>>>0>32767){break w}while(1){if((b|0)<=0){break w}b=b-1|0;F[e+52>>2]=b;a=G[b+d|0]|a<<8;F[e+56>>2]=a;if(a>>>0<32768){continue}break}}m=a&8191;k=F[f+(m<<2)>>2];g=c+(k<<3)|0;a=(L(F[g>>2],a>>>13|0)+m|0)-F[g+4>>2]|0;F[e+56>>2]=a;F[r+(q<<2)>>2]=k;m=1;q=q+1|0;if((o|0)!=(q|0)){continue}break}}a=F[e+36>>2];if(a){F[e+40>>2]=a;ja(a);}a=F[e+24>>2];if(a){F[e+28>>2]=a;ja(a);}a=F[e+8>>2];if(a){F[e+12>>2]=a;ja(a);}Z=e- -64|0;b=m;break g;case 9:o=a;r=d;g=Z+-64|0;Z=g;F[g+56>>2]=0;F[g+48>>2]=0;F[g+52>>2]=0;F[g+40>>2]=0;F[g+44>>2]=0;F[g+32>>2]=0;F[g+36>>2]=0;F[g+24>>2]=0;F[g+28>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;F[g+8>>2]=0;F[g+12>>2]=0;h=g+8|0;x:{y:{if(!H[c+38>>1]){break y}if(!Ta(1,h+12|0,c)){break y}b=F[c+8>>2];d=F[c+16>>2];f=b-d|0;i=F[h+12>>2];b=F[c+12>>2]-(F[c+20>>2]+(b>>>0<d>>>0)|0)|0;if(f>>>0<i>>>6>>>0&(b|0)<=0|(b|0)<0){break y}b=F[h>>2];a=F[h+4>>2]-b>>2;z:{if(a>>>0<i>>>0){qa(h,i-a|0);i=F[h+12>>2];break z}if(a>>>0<=i>>>0){break z}F[h+4>>2]=b+(i<<2);}e=1;if(!i){break x}f=F[c+16>>2];d=F[c+20>>2];s=F[h>>2];j=F[c+8>>2];n=F[c+12>>2];b=0;while(1){e=0;if((d|0)>=(n|0)&f>>>0>=j>>>0|(d|0)>(n|0)){break x}t=F[c>>2];p=G[t+f|0];e=d;f=f+1|0;e=f?e:e+1|0;F[c+16>>2]=f;d=e;F[c+20>>2]=e;a=p>>>2|0;l=0;A:{B:{C:{D:{e=p&3;switch(e|0){case 0:break B;case 3:break D;default:break C}}a=a+b|0;e=0;if(a>>>0>=i>>>0){break x}ma(s+(b<<2)|0,0,(p&252)+4|0);b=a;break A}while(1){if((f|0)==(j|0)&(d|0)==(n|0)){break y}i=G[f+t|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;a=i<<(l<<3|6)|a;l=l+1|0;if((e|0)!=(l|0)){continue}break}}F[s+(b<<2)>>2]=a;}b=b+1|0;i=F[h+12>>2];if(b>>>0<i>>>0){continue}break}a=h+16|0;n=F[h>>2];d=F[h+16>>2];b=F[h+20>>2]-d|0;E:{if(b>>>0<=131071){qa(a,32768-(b>>>2|0)|0);break E}if((b|0)==131072){break E}F[h+20>>2]=d+131072;}d=h+28|0;b=F[d>>2];f=F[h+32>>2]-b>>3;F:{if(f>>>0<i>>>0){_a(d,i-f|0);b=F[d>>2];break F}if(f>>>0>i>>>0){F[h+32>>2]=(i<<3)+b;}if(!i){break y}}j=F[a>>2];f=0;d=0;while(1){e=n+(f<<2)|0;l=F[e>>2];h=(f<<3)+b|0;a=d;F[h+4>>2]=a;F[h>>2]=l;e=F[e>>2];d=e+a|0;if(d>>>0>32768){break y}G:{if(a>>>0>=d>>>0){break G}l=0;h=e&7;if(h){while(1){F[j+(a<<2)>>2]=f;a=a+1|0;l=l+1|0;if((h|0)!=(l|0)){continue}break}}if(e-1>>>0<=6){break G}while(1){e=j+(a<<2)|0;F[e>>2]=f;F[e+28>>2]=f;F[e+24>>2]=f;F[e+20>>2]=f;F[e+16>>2]=f;F[e+12>>2]=f;F[e+8>>2]=f;F[e+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((i|0)!=(f|0)){continue}break}k=(d|0)==32768;}e=k;}H:{if(!e|(F[g+20>>2]?0:o)){break H}d=0;f=Z-16|0;Z=f;I:{if(!Sa(1,f+8|0,c)){break I}e=F[c+8>>2];b=F[c+16>>2];k=e-b|0;j=F[f+12>>2];i=F[c+20>>2];e=F[c+12>>2]-(i+(b>>>0>e>>>0)|0)|0;a=F[f+8>>2];if((j|0)==(e|0)&k>>>0<a>>>0|e>>>0<j>>>0){break I}e=i+j|0;k=a+b|0;e=k>>>0<b>>>0?e+1|0:e;F[c+16>>2]=k;F[c+20>>2]=e;if((a|0)<=0){break I}b=b+F[c>>2]|0;F[g+48>>2]=b;c=a-1|0;e=c+b|0;k=G[e|0];J:{if(k>>>0<=63){F[g+52>>2]=c;a=G[e|0]&63;break J}K:{switch((k>>>6|0)-1|0){case 0:if(a>>>0<2){break I}a=a-2|0;F[g+52>>2]=a;a=a+b|0;a=G[a+1|0]<<8&16128|G[a|0];break J;case 1:if(a>>>0<3){break I}a=a-3|0;F[g+52>>2]=a;a=a+b|0;a=G[a+1|0]<<8|G[a+2|0]<<16&4128768|G[a|0];break J;default:break K}}a=a-4|0;F[g+52>>2]=a;a=a+b|0;a=(G[a|0]|G[a+1|0]<<8|(G[a+2|0]<<16|G[a+3|0]<<24))&1073741823;}F[g+56>>2]=a+131072;d=a>>>0<33423360;}Z=f+16|0;if(!d){break H}if(!o){m=1;break H}b=F[g+52>>2];a=F[g+56>>2];c=F[g+36>>2];d=F[g+48>>2];f=F[g+24>>2];while(1){L:{if(a>>>0>131071){break L}while(1){if((b|0)<=0){break L}b=b-1|0;F[g+52>>2]=b;a=G[b+d|0]|a<<8;F[g+56>>2]=a;if(a>>>0<131072){continue}break}}m=a&32767;e=F[f+(m<<2)>>2];k=c+(e<<3)|0;a=(L(F[k>>2],a>>>15|0)+m|0)-F[k+4>>2]|0;F[g+56>>2]=a;F[r+(q<<2)>>2]=e;m=1;q=q+1|0;if((o|0)!=(q|0)){continue}break}}a=F[g+36>>2];if(a){F[g+40>>2]=a;ja(a);}a=F[g+24>>2];if(a){F[g+28>>2]=a;ja(a);}a=F[g+8>>2];if(a){F[g+12>>2]=a;ja(a);}Z=g- -64|0;b=m;break g;case 10:o=a;r=d;g=Z+-64|0;Z=g;F[g+56>>2]=0;F[g+48>>2]=0;F[g+52>>2]=0;F[g+40>>2]=0;F[g+44>>2]=0;F[g+32>>2]=0;F[g+36>>2]=0;F[g+24>>2]=0;F[g+28>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;F[g+8>>2]=0;F[g+12>>2]=0;h=g+8|0;M:{N:{if(!H[c+38>>1]){break N}if(!Ta(1,h+12|0,c)){break N}b=F[c+8>>2];d=F[c+16>>2];f=b-d|0;i=F[h+12>>2];b=F[c+12>>2]-(F[c+20>>2]+(b>>>0<d>>>0)|0)|0;if(f>>>0<i>>>6>>>0&(b|0)<=0|(b|0)<0){break N}b=F[h>>2];a=F[h+4>>2]-b>>2;O:{if(a>>>0<i>>>0){qa(h,i-a|0);i=F[h+12>>2];break O}if(a>>>0<=i>>>0){break O}F[h+4>>2]=b+(i<<2);}e=1;if(!i){break M}f=F[c+16>>2];d=F[c+20>>2];s=F[h>>2];j=F[c+8>>2];n=F[c+12>>2];b=0;while(1){e=0;if((d|0)>=(n|0)&f>>>0>=j>>>0|(d|0)>(n|0)){break M}t=F[c>>2];p=G[t+f|0];a=d;f=f+1|0;a=f?a:a+1|0;F[c+16>>2]=f;d=a;F[c+20>>2]=a;a=p>>>2|0;l=0;P:{Q:{R:{S:{u=p&3;switch(u|0){case 0:break Q;case 3:break S;default:break R}}a=a+b|0;e=0;if(a>>>0>=i>>>0){break M}ma(s+(b<<2)|0,0,(p&252)+4|0);b=a;break P}while(1){if((f|0)==(j|0)&(d|0)==(n|0)){break N}i=G[f+t|0];e=d;f=f+1|0;e=f?e:e+1|0;F[c+16>>2]=f;d=e;F[c+20>>2]=e;a=i<<(l<<3|6)|a;l=l+1|0;if((u|0)!=(l|0)){continue}break}}F[s+(b<<2)>>2]=a;}b=b+1|0;i=F[h+12>>2];if(b>>>0<i>>>0){continue}break}a=h+16|0;n=F[h>>2];d=F[h+16>>2];b=F[h+20>>2]-d|0;T:{if(b>>>0<=262143){qa(a,65536-(b>>>2|0)|0);break T}if((b|0)==262144){break T}F[h+20>>2]=d+262144;}d=h+28|0;b=F[d>>2];f=F[h+32>>2]-b>>3;U:{if(f>>>0<i>>>0){_a(d,i-f|0);b=F[d>>2];break U}if(f>>>0>i>>>0){F[h+32>>2]=(i<<3)+b;}if(!i){break N}}j=F[a>>2];f=0;d=0;while(1){e=n+(f<<2)|0;l=F[e>>2];h=(f<<3)+b|0;a=d;F[h+4>>2]=a;F[h>>2]=l;e=F[e>>2];d=e+a|0;if(d>>>0>65536){break N}V:{if(a>>>0>=d>>>0){break V}l=0;h=e&7;if(h){while(1){F[j+(a<<2)>>2]=f;a=a+1|0;l=l+1|0;if((h|0)!=(l|0)){continue}break}}if(e-1>>>0<=6){break V}while(1){e=j+(a<<2)|0;F[e>>2]=f;F[e+28>>2]=f;F[e+24>>2]=f;F[e+20>>2]=f;F[e+16>>2]=f;F[e+12>>2]=f;F[e+8>>2]=f;F[e+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((i|0)!=(f|0)){continue}break}k=(d|0)==65536;}e=k;}W:{if(!e|(F[g+20>>2]?0:o)){break W}d=0;e=Z-16|0;Z=e;X:{if(!Sa(1,e+8|0,c)){break X}a=F[c+8>>2];f=F[c+16>>2];k=a-f|0;j=F[e+12>>2];i=F[c+20>>2];a=F[c+12>>2]-(i+(a>>>0<f>>>0)|0)|0;b=F[e+8>>2];if((j|0)==(a|0)&k>>>0<b>>>0|a>>>0<j>>>0){break X}a=i+j|0;k=b+f|0;a=k>>>0<f>>>0?a+1|0:a;F[c+16>>2]=k;F[c+20>>2]=a;if((b|0)<=0){break X}a=f+F[c>>2]|0;F[g+48>>2]=a;c=b-1|0;f=c+a|0;k=G[f|0];Y:{if(k>>>0<=63){F[g+52>>2]=c;a=G[f|0]&63;break Y}Z:{switch((k>>>6|0)-1|0){case 0:if(b>>>0<2){break X}b=b-2|0;F[g+52>>2]=b;a=a+b|0;a=G[a+1|0]<<8&16128|G[a|0];break Y;case 1:if(b>>>0<3){break X}b=b-3|0;F[g+52>>2]=b;a=a+b|0;a=G[a+1|0]<<8|G[a+2|0]<<16&4128768|G[a|0];break Y;default:break Z}}b=b-4|0;F[g+52>>2]=b;a=a+b|0;a=(G[a|0]|G[a+1|0]<<8|(G[a+2|0]<<16|G[a+3|0]<<24))&1073741823;}F[g+56>>2]=a+262144;d=a>>>0<66846720;}Z=e+16|0;if(!d){break W}if(!o){m=1;break W}b=F[g+52>>2];a=F[g+56>>2];c=F[g+36>>2];d=F[g+48>>2];f=F[g+24>>2];while(1){_:{if(a>>>0>262143){break _}while(1){if((b|0)<=0){break _}b=b-1|0;F[g+52>>2]=b;a=G[b+d|0]|a<<8;F[g+56>>2]=a;if(a>>>0<262144){continue}break}}m=a&65535;e=F[f+(m<<2)>>2];k=c+(e<<3)|0;a=(L(F[k>>2],a>>>16|0)+m|0)-F[k+4>>2]|0;F[g+56>>2]=a;F[r+(q<<2)>>2]=e;m=1;q=q+1|0;if((o|0)!=(q|0)){continue}break}}a=F[g+36>>2];if(a){F[g+40>>2]=a;ja(a);}a=F[g+24>>2];if(a){F[g+28>>2]=a;ja(a);}a=F[g+8>>2];if(a){F[g+12>>2]=a;ja(a);}Z=g- -64|0;b=m;break g;case 11:o=a;r=d;g=Z+-64|0;Z=g;F[g+56>>2]=0;F[g+48>>2]=0;F[g+52>>2]=0;F[g+40>>2]=0;F[g+44>>2]=0;F[g+32>>2]=0;F[g+36>>2]=0;F[g+24>>2]=0;F[g+28>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;F[g+8>>2]=0;F[g+12>>2]=0;h=g+8|0;$:{aa:{if(!H[c+38>>1]){break aa}if(!Ta(1,h+12|0,c)){break aa}b=F[c+8>>2];d=F[c+16>>2];f=b-d|0;i=F[h+12>>2];b=F[c+12>>2]-(F[c+20>>2]+(b>>>0<d>>>0)|0)|0;if(f>>>0<i>>>6>>>0&(b|0)<=0|(b|0)<0){break aa}b=F[h>>2];a=F[h+4>>2]-b>>2;ba:{if(a>>>0<i>>>0){qa(h,i-a|0);i=F[h+12>>2];break ba}if(a>>>0<=i>>>0){break ba}F[h+4>>2]=b+(i<<2);}e=1;if(!i){break $}f=F[c+16>>2];d=F[c+20>>2];s=F[h>>2];j=F[c+8>>2];n=F[c+12>>2];b=0;while(1){e=0;if((d|0)>=(n|0)&f>>>0>=j>>>0|(d|0)>(n|0)){break $}t=F[c>>2];p=G[t+f|0];e=d;f=f+1|0;e=f?e:e+1|0;F[c+16>>2]=f;d=e;F[c+20>>2]=e;a=p>>>2|0;l=0;ca:{da:{ea:{fa:{e=p&3;switch(e|0){case 0:break da;case 3:break fa;default:break ea}}a=a+b|0;e=0;if(a>>>0>=i>>>0){break $}ma(s+(b<<2)|0,0,(p&252)+4|0);b=a;break ca}while(1){if((f|0)==(j|0)&(d|0)==(n|0)){break aa}i=G[f+t|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;a=i<<(l<<3|6)|a;l=l+1|0;if((e|0)!=(l|0)){continue}break}}F[s+(b<<2)>>2]=a;}b=b+1|0;i=F[h+12>>2];if(b>>>0<i>>>0){continue}break}a=h+16|0;n=F[h>>2];d=F[h+16>>2];b=F[h+20>>2]-d|0;ga:{if(b>>>0<=1048575){qa(a,262144-(b>>>2|0)|0);break ga}if((b|0)==1048576){break ga}F[h+20>>2]=d- -1048576;}d=h+28|0;b=F[d>>2];f=F[h+32>>2]-b>>3;ha:{if(f>>>0<i>>>0){_a(d,i-f|0);b=F[d>>2];break ha}if(f>>>0>i>>>0){F[h+32>>2]=(i<<3)+b;}if(!i){break aa}}j=F[a>>2];f=0;d=0;while(1){e=n+(f<<2)|0;l=F[e>>2];h=(f<<3)+b|0;a=d;F[h+4>>2]=a;F[h>>2]=l;e=F[e>>2];d=e+a|0;if(d>>>0>262144){break aa}ia:{if(a>>>0>=d>>>0){break ia}l=0;h=e&7;if(h){while(1){F[j+(a<<2)>>2]=f;a=a+1|0;l=l+1|0;if((h|0)!=(l|0)){continue}break}}if(e-1>>>0<=6){break ia}while(1){e=j+(a<<2)|0;F[e>>2]=f;F[e+28>>2]=f;F[e+24>>2]=f;F[e+20>>2]=f;F[e+16>>2]=f;F[e+12>>2]=f;F[e+8>>2]=f;F[e+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((i|0)!=(f|0)){continue}break}k=(d|0)==262144;}e=k;}ja:{if(!e|(F[g+20>>2]?0:o)){break ja}d=0;f=Z-16|0;Z=f;ka:{if(!Sa(1,f+8|0,c)){break ka}e=F[c+8>>2];b=F[c+16>>2];k=e-b|0;j=F[f+12>>2];i=F[c+20>>2];e=F[c+12>>2]-(i+(b>>>0>e>>>0)|0)|0;a=F[f+8>>2];if((j|0)==(e|0)&k>>>0<a>>>0|e>>>0<j>>>0){break ka}e=i+j|0;k=a+b|0;e=k>>>0<b>>>0?e+1|0:e;F[c+16>>2]=k;F[c+20>>2]=e;if((a|0)<=0){break ka}b=b+F[c>>2]|0;F[g+48>>2]=b;c=a-1|0;e=c+b|0;k=G[e|0];la:{if(k>>>0<=63){F[g+52>>2]=c;a=G[e|0]&63;break la}ma:{switch((k>>>6|0)-1|0){case 0:if(a>>>0<2){break ka}a=a-2|0;F[g+52>>2]=a;a=a+b|0;a=G[a+1|0]<<8&16128|G[a|0];break la;case 1:if(a>>>0<3){break ka}a=a-3|0;F[g+52>>2]=a;a=a+b|0;a=G[a+1|0]<<8|G[a+2|0]<<16&4128768|G[a|0];break la;default:break ma}}a=a-4|0;F[g+52>>2]=a;a=a+b|0;a=(G[a|0]|G[a+1|0]<<8|(G[a+2|0]<<16|G[a+3|0]<<24))&1073741823;}F[g+56>>2]=a- -1048576;d=a>>>0<267386880;}Z=f+16|0;if(!d){break ja}if(!o){m=1;break ja}b=F[g+52>>2];a=F[g+56>>2];c=F[g+36>>2];d=F[g+48>>2];f=F[g+24>>2];while(1){na:{if(a>>>0>1048575){break na}while(1){if((b|0)<=0){break na}b=b-1|0;F[g+52>>2]=b;a=G[b+d|0]|a<<8;F[g+56>>2]=a;if(a>>>0<1048576){continue}break}}m=a&262143;e=F[f+(m<<2)>>2];k=c+(e<<3)|0;a=(L(F[k>>2],a>>>18|0)+m|0)-F[k+4>>2]|0;F[g+56>>2]=a;F[r+(q<<2)>>2]=e;m=1;q=q+1|0;if((o|0)!=(q|0)){continue}break}}a=F[g+36>>2];if(a){F[g+40>>2]=a;ja(a);}a=F[g+24>>2];if(a){F[g+28>>2]=a;ja(a);}a=F[g+8>>2];if(a){F[g+12>>2]=a;ja(a);}Z=g- -64|0;b=m;break g;case 12:o=a;r=d;e=Z+-64|0;Z=e;F[e+56>>2]=0;F[e+48>>2]=0;F[e+52>>2]=0;F[e+40>>2]=0;F[e+44>>2]=0;F[e+32>>2]=0;F[e+36>>2]=0;F[e+24>>2]=0;F[e+28>>2]=0;F[e+16>>2]=0;F[e+20>>2]=0;F[e+8>>2]=0;F[e+12>>2]=0;h=e+8|0;oa:{pa:{if(!H[c+38>>1]){break pa}if(!Ta(1,h+12|0,c)){break pa}b=F[c+8>>2];d=F[c+16>>2];f=b-d|0;i=F[h+12>>2];b=F[c+12>>2]-(F[c+20>>2]+(b>>>0<d>>>0)|0)|0;if(f>>>0<i>>>6>>>0&(b|0)<=0|(b|0)<0){break pa}b=F[h>>2];a=F[h+4>>2]-b>>2;qa:{if(a>>>0<i>>>0){qa(h,i-a|0);i=F[h+12>>2];break qa}if(a>>>0<=i>>>0){break qa}F[h+4>>2]=b+(i<<2);}g=1;if(!i){break oa}f=F[c+16>>2];d=F[c+20>>2];s=F[h>>2];j=F[c+8>>2];n=F[c+12>>2];b=0;while(1){g=0;if((d|0)>=(n|0)&f>>>0>=j>>>0|(d|0)>(n|0)){break oa}g=F[c>>2];p=G[g+f|0];a=d;f=f+1|0;a=f?a:a+1|0;F[c+16>>2]=f;d=a;F[c+20>>2]=a;a=p>>>2|0;l=0;ra:{sa:{ta:{ua:{t=p&3;switch(t|0){case 0:break sa;case 3:break ua;default:break ta}}a=a+b|0;g=0;if(a>>>0>=i>>>0){break oa}ma(s+(b<<2)|0,0,(p&252)+4|0);b=a;break ra}while(1){if((f|0)==(j|0)&(d|0)==(n|0)){break pa}i=G[f+g|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;a=i<<(l<<3|6)|a;l=l+1|0;if((t|0)!=(l|0)){continue}break}}F[s+(b<<2)>>2]=a;}b=b+1|0;i=F[h+12>>2];if(b>>>0<i>>>0){continue}break}a=h+16|0;n=F[h>>2];d=F[h+16>>2];b=F[h+20>>2]-d|0;va:{if(b>>>0<=2097151){qa(a,524288-(b>>>2|0)|0);break va}if((b|0)==2097152){break va}F[h+20>>2]=d+2097152;}d=h+28|0;b=F[d>>2];f=F[h+32>>2]-b>>3;wa:{if(f>>>0<i>>>0){_a(d,i-f|0);b=F[d>>2];break wa}if(f>>>0>i>>>0){F[h+32>>2]=(i<<3)+b;}if(!i){break pa}}j=F[a>>2];f=0;d=0;while(1){g=n+(f<<2)|0;l=F[g>>2];h=(f<<3)+b|0;a=d;F[h+4>>2]=a;F[h>>2]=l;g=F[g>>2];d=g+a|0;if(d>>>0>524288){break pa}xa:{if(a>>>0>=d>>>0){break xa}l=0;h=g&7;if(h){while(1){F[j+(a<<2)>>2]=f;a=a+1|0;l=l+1|0;if((h|0)!=(l|0)){continue}break}}if(g-1>>>0<=6){break xa}while(1){g=j+(a<<2)|0;F[g>>2]=f;F[g+28>>2]=f;F[g+24>>2]=f;F[g+20>>2]=f;F[g+16>>2]=f;F[g+12>>2]=f;F[g+8>>2]=f;F[g+4>>2]=f;a=a+8|0;if((d|0)!=(a|0)){continue}break}}f=f+1|0;if((i|0)!=(f|0)){continue}break}k=(d|0)==524288;}g=k;}ya:{if(!g|(F[e+20>>2]?0:o)){break ya}d=0;k=Z-16|0;Z=k;za:{if(!Sa(1,k+8|0,c)){break za}a=F[c+8>>2];f=F[c+16>>2];g=a-f|0;j=F[k+12>>2];i=F[c+20>>2];a=F[c+12>>2]-(i+(a>>>0<f>>>0)|0)|0;b=F[k+8>>2];if((j|0)==(a|0)&g>>>0<b>>>0|a>>>0<j>>>0){break za}a=i+j|0;g=b+f|0;a=g>>>0<f>>>0?a+1|0:a;F[c+16>>2]=g;F[c+20>>2]=a;if((b|0)<=0){break za}a=f+F[c>>2]|0;F[e+48>>2]=a;c=b-1|0;f=c+a|0;g=G[f|0];Aa:{if(g>>>0<=63){F[e+52>>2]=c;a=G[f|0]&63;break Aa}Ba:{switch((g>>>6|0)-1|0){case 0:if(b>>>0<2){break za}b=b-2|0;F[e+52>>2]=b;a=a+b|0;a=G[a+1|0]<<8&16128|G[a|0];break Aa;case 1:if(b>>>0<3){break za}b=b-3|0;F[e+52>>2]=b;a=a+b|0;a=G[a+1|0]<<8|G[a+2|0]<<16&4128768|G[a|0];break Aa;default:break Ba}}b=b-4|0;F[e+52>>2]=b;a=a+b|0;a=(G[a|0]|G[a+1|0]<<8|(G[a+2|0]<<16|G[a+3|0]<<24))&1073741823;}F[e+56>>2]=a+2097152;d=a>>>0<534773760;}Z=k+16|0;if(!d){break ya}if(!o){m=1;break ya}b=F[e+52>>2];a=F[e+56>>2];c=F[e+36>>2];d=F[e+48>>2];f=F[e+24>>2];while(1){Ca:{if(a>>>0>2097151){break Ca}while(1){if((b|0)<=0){break Ca}b=b-1|0;F[e+52>>2]=b;a=G[b+d|0]|a<<8;F[e+56>>2]=a;if(a>>>0<2097152){continue}break}}m=a&524287;k=F[f+(m<<2)>>2];g=c+(k<<3)|0;a=(L(F[g>>2],a>>>19|0)+m|0)-F[g+4>>2]|0;F[e+56>>2]=a;F[r+(q<<2)>>2]=k;m=1;q=q+1|0;if((o|0)!=(q|0)){continue}break}}a=F[e+36>>2];if(a){F[e+40>>2]=a;ja(a);}a=F[e+24>>2];if(a){F[e+28>>2]=a;ja(a);}a=F[e+8>>2];if(a){F[e+12>>2]=a;ja(a);}Z=e- -64|0;b=m;break g;case 17:b=Ld(a,c,d);break g;case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:b=Z+-64|0;Z=b;F[b+56>>2]=0;F[b+48>>2]=0;F[b+52>>2]=0;F[b+40>>2]=0;F[b+44>>2]=0;F[b+32>>2]=0;F[b+36>>2]=0;F[b+24>>2]=0;F[b+28>>2]=0;F[b+16>>2]=0;F[b+20>>2]=0;F[b+8>>2]=0;F[b+12>>2]=0;Da:{if(!Nd(b+8|0,c)|(F[b+20>>2]?0:a)){break Da}if(!Md(b+8|0,c)){break Da}if(!a){f=1;break Da}m=F[b+52>>2];c=F[b+56>>2];e=F[b+36>>2];g=F[b+48>>2];o=F[b+24>>2];while(1){Ea:{if(c>>>0>16383){break Ea}while(1){if((m|0)<=0){break Ea}m=m-1|0;F[b+52>>2]=m;c=G[g+m|0]|c<<8;F[b+56>>2]=c;if(c>>>0<16384){continue}break}}f=c&4095;j=F[o+(f<<2)>>2];r=e+(j<<3)|0;c=(L(F[r>>2],c>>>12|0)+f|0)-F[r+4>>2]|0;F[b+56>>2]=c;F[(k<<2)+d>>2]=j;f=1;k=k+1|0;if((k|0)!=(a|0)){continue}break}}a=F[b+36>>2];if(a){F[b+40>>2]=a;ja(a);}a=F[b+24>>2];if(a){F[b+28>>2]=a;ja(a);}a=F[b+8>>2];if(a){F[b+12>>2]=a;ja(a);}Z=b- -64|0;b=f;break g;case 13:case 14:case 15:case 16:break h;default:break g}}b=Ld(a,c,d);}f=b;}return f}function ih(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,I=0,J=0,K=0,M=0,N=0,O=0;u=Z+-64|0;Z=u;F[a+132>>2]=0;if(F[a+148>>2]){b=F[a+144>>2];if(b){while(1){f=F[b>>2];ja(b);b=f;if(b){continue}break}}b=0;F[a+144>>2]=0;f=F[a+140>>2];a:{if(!f){break a}if(f>>>0>=4){c=f&-4;while(1){e=b<<2;F[e+F[a+136>>2]>>2]=0;F[F[a+136>>2]+(e|4)>>2]=0;F[F[a+136>>2]+(e|8)>>2]=0;F[F[a+136>>2]+(e|12)>>2]=0;b=b+4|0;d=d+4|0;if((c|0)!=(d|0)){continue}break}}f=f&3;if(!f){break a}d=0;while(1){F[F[a+136>>2]+(b<<2)>>2]=0;b=b+1|0;d=d+1|0;if((f|0)!=(d|0)){continue}break}}F[a+148>>2]=0;}b:{c:{if(!Da(1,u+60|0,F[F[a+4>>2]+32>>2])){break c}F[a+156>>2]=F[u+60>>2];if(!Da(1,u+56|0,F[F[a+4>>2]+32>>2])){break c}e=F[u+56>>2];if(e>>>0>1431655765){break c}b=F[a+156>>2];d=L(e,3);if(b>>>0>d>>>0){break c}f=b>>31;f=ki(b-1|0,f-!b|0,b,f);b=_;c=b>>>1|0;b=(b&1)<<31|f>>>1;if(!c&b>>>0<d>>>1>>>0){break c}b=F[F[a+4>>2]+32>>2];c=F[b+8>>2];k=F[b+12>>2];d=F[b+20>>2];f=F[b+16>>2];if((k|0)<=(d|0)&f>>>0>=c>>>0|(d|0)>(k|0)){break c}k=G[f+F[b>>2]|0];f=f+1|0;d=f?d:d+1|0;F[b+16>>2]=f;F[b+20>>2]=d;if(!Da(1,u+52|0,b)){break c}q=F[u+52>>2];if(q>>>0>e>>>0|e>>>0>q+((q>>>0)/3|0)>>>0){break c}if(!Da(1,u+48|0,F[F[a+4>>2]+32>>2])){break c}d=F[u+48>>2];if(d>>>0>q>>>0){break c}F[a+28>>2]=F[a+24>>2];f=Zb(ka(88));b=F[a+8>>2];F[a+8>>2]=f;if(b){Za(b);if(!F[a+8>>2]){break c}}F[a+164>>2]=F[a+160>>2];Ib(a+160|0,e);F[a+176>>2]=F[a+172>>2];Ib(a+172|0,e);F[a- -64>>2]=0;F[a+92>>2]=-1;F[a+84>>2]=-1;F[a+88>>2]=-1;F[a+40>>2]=F[a+36>>2];F[a+52>>2]=F[a+48>>2];F[a+76>>2]=F[a+72>>2];A=a+216|0;Dd(A);Cd(A,k);if(!_c(F[a+8>>2],e,d+F[a+156>>2]|0)){break c}b=F[a+156>>2];D[u+8|0]=1;Ea(a+120|0,b+d|0,u+8|0);if((Bd(a,F[F[a+4>>2]+32>>2])|0)==-1){break c}c=a+232|0;b=c;F[b+144>>2]=a;f=F[($[F[F[a>>2]+32>>2]](a)|0)+32>>2];f=F[f>>2]+F[f+16>>2]|0;e=F[($[F[F[a>>2]+32>>2]](a)|0)+32>>2];e=F[e+8>>2]-F[e+16>>2]|0;N=b,O=H[F[($[F[F[a>>2]+32>>2]](a)|0)+32>>2]+38>>1],E[N+38>>1]=O;F[b>>2]=f;F[b+16>>2]=0;F[b+20>>2]=0;F[b+8>>2]=e;F[b+12>>2]=0;N=b,O=$[F[F[a>>2]+36>>2]](a)|0,F[N+148>>2]=O;F[a+372>>2]=k;F[a+384>>2]=d+F[a+156>>2];J=Ja(u+8|0);k=J;f=0;j=Z-16|0;Z=j;d:{if(!Aa(b+80|0,b)){break d}if(!yd(c)){break d}b=F[c+4>>2];F[k>>2]=F[c>>2];F[k+4>>2]=b;b=F[c+36>>2];F[k+32>>2]=F[c+32>>2];F[k+36>>2]=b;b=F[c+28>>2];F[k+24>>2]=F[c+24>>2];F[k+28>>2]=b;b=F[c+20>>2];F[k+16>>2]=F[c+16>>2];F[k+20>>2]=b;b=F[c+12>>2];F[k+8>>2]=F[c+8>>2];F[k+12>>2]=b;F[c+176>>2]=2;F[c+180>>2]=7;b=F[c+152>>2];if((b|0)<0){break d}F[j+12>>2]=0;f=2;h=F[c+156>>2];e=F[c+160>>2]-h>>2;e:{if(e>>>0<b>>>0){Fa(c+156|0,b-e|0,j+12|0);f=F[c+176>>2];d=F[c+180>>2];break e}d=7;if(b>>>0>=e>>>0){break e}F[c+160>>2]=h+(b<<2);}e=c+184|0;d=(d-f|0)+1|0;b=F[c+188>>2];f=F[c+184>>2];s=(b-f|0)/12|0;f:{if(d>>>0>s>>>0){h=0;b=d-s|0;o=F[e+8>>2];f=F[e+4>>2];g:{if(b>>>0<=(o-f|0)/12>>>0){if(b){b=L(b,12)-12|0;b=(b-((b>>>0)%12|0)|0)+12|0;f=ma(f,0,b)+b|0;}F[e+4>>2]=f;break g}h:{i:{j:{s=F[e>>2];g=(f-s|0)/12|0;d=g+b|0;if(d>>>0<357913942){o=(o-s|0)/12|0;i=o<<1;o=o>>>0>=178956970?357913941:d>>>0<i>>>0?i:d;if(o){if(o>>>0>=357913942){break j}h=ka(L(o,12));}d=L(g,12)+h|0;b=L(b,12)-12|0;g=(b-((b>>>0)%12|0)|0)+12|0;b=ma(d,0,g);g=b+g|0;h=L(o,12)+h|0;if((f|0)==(s|0)){break i}while(1){d=d-12|0;f=f-12|0;F[d>>2]=F[f>>2];F[d+4>>2]=F[f+4>>2];F[d+8>>2]=F[f+8>>2];F[f+8>>2]=0;F[f>>2]=0;F[f+4>>2]=0;if((f|0)!=(s|0)){continue}break}F[e+8>>2]=h;b=F[e+4>>2];F[e+4>>2]=g;f=F[e>>2];F[e>>2]=d;if((b|0)==(f|0)){break h}while(1){d=b-12|0;h=F[d>>2];if(h){F[b-8>>2]=h;ja(h);}b=d;if((f|0)!=(b|0)){continue}break}break h}break b}oa();v();}F[e+8>>2]=h;F[e+4>>2]=g;F[e>>2]=b;}if(f){ja(f);}}d=F[c+188>>2];break f}if(d>>>0>=s>>>0){d=b;break f}d=f+L(d,12)|0;if((d|0)!=(b|0)){while(1){f=b-12|0;h=F[f>>2];if(h){F[b-8>>2]=h;ja(h);}b=f;if((d|0)!=(b|0)){continue}break}}F[c+188>>2]=d;}s=c+196|0;f=F[c+184>>2];b=(d-f|0)/12|0;o=F[c+196>>2];h=F[c+200>>2]-o>>2;k:{if(b>>>0>h>>>0){qa(s,b-h|0);f=F[c+184>>2];d=F[c+188>>2];break k}if(b>>>0>=h>>>0){break k}F[c+200>>2]=o+(b<<2);}if((d|0)==(f|0)){f=1;break d}b=0;while(1){l:{if(!Da(1,j+8|0,k)){break l}f=F[j+8>>2];d=F[c+148>>2];if(f>>>0>(F[d+4>>2]-F[d>>2]>>2>>>0)/3>>>0){break l}if(f){g=L(b,12);h=g+F[e>>2]|0;d=F[h>>2];o=F[h+4>>2]-d>>2;m:{if(o>>>0<f>>>0){qa(h,f-o|0);d=F[g+F[e>>2]>>2];break m}if(f>>>0>=o>>>0){break m}F[h+4>>2]=(f<<2)+d;}mc(f,1,k,d);F[F[s>>2]+(b<<2)>>2]=f;}f=1;b=b+1|0;if(b>>>0<(F[c+188>>2]-F[c+184>>2]|0)/12>>>0){continue}break d}break}f=0;}Z=j+16|0;n:{if(!f){break n}e=0;c=0;d=0;b=0;k=0;f=0;s=0;o=0;l=Z-96|0;Z=l;F[l+72>>2]=0;F[l+64>>2]=0;F[l+68>>2]=0;F[l+48>>2]=0;F[l+52>>2]=0;F[l+40>>2]=0;F[l+44>>2]=0;F[l+56>>2]=1065353216;F[l+32>>2]=0;F[l+24>>2]=0;F[l+28>>2]=0;j=a;C=F[a+124>>2];o:{p:{q:{r:{s:{if((q|0)<=0){break s}I=j+232|0;K=F[j+216>>2]!=F[j+220>>2];B=1;t:{while(1){h=s;s=h+1|0;u:{v:{w:{g=F[j+404>>2];if((g|0)==-1){F[j+400>>2]=7;break w}a=-1;i=F[j+428>>2]+(g<<2)|0;m=F[i>>2];g=m-1|0;F[i>>2]=g;if((m|0)<=0){break r}g=F[F[F[j+416>>2]+L(F[j+404>>2],12)>>2]+(g<<2)>>2];if(g>>>0>4){break r}i=F[(g<<2)+8896>>2];F[j+400>>2]=i;if(!g){if((b|0)==(c|0)){break r}i=-1;m=F[j+8>>2];B=F[m+24>>2];t=c-4|0;e=F[t>>2];g=-1;x:{if((e|0)==-1){break x}p=e+1|0;p=(p>>>0)%3|0?p:e-2|0;g=-1;if((p|0)==-1){break x}g=F[F[m>>2]+(p<<2)>>2];}n=F[B+(g<<2)>>2];if((n|0)!=-1){i=n+1|0;i=(i>>>0)%3|0?i:n-2|0;}if((e|0)!=-1&F[F[m+12>>2]+(e<<2)>>2]!=-1|(e|0)==(i|0)){break r}n=F[m+12>>2];if((i|0)!=-1&F[n+(i<<2)>>2]!=-1){break r}p=L(h,3);h=p+1|0;F[n+(e<<2)>>2]=h;x=h<<2;F[x+n>>2]=e;r=p+2|0;F[n+(i<<2)>>2]=r;w=r<<2;F[w+n>>2]=i;n=-1;h=-1;y:{if((e|0)==-1){break y}z:{if((e>>>0)%3|0){e=e-1|0;break z}e=e+2|0;h=-1;if((e|0)==-1){break y}}h=F[F[m>>2]+(e<<2)>>2];}e=h;A:{if((i|0)==-1){break A}h=i+1|0;h=(h>>>0)%3|0?h:i-2|0;if((h|0)==-1){break A}n=F[F[m>>2]+(h<<2)>>2];}if((e|0)==(g|0)|(g|0)==(n|0)){break r}a=F[m>>2];F[a+(p<<2)>>2]=g;F[a+x>>2]=n;F[a+w>>2]=e;if((e|0)!=-1){F[B+(e<<2)>>2]=r;}a=F[j+120>>2]+(g>>>3&536870908)|0;e=F[a>>2];N=a,O=oi(g)&e,F[N>>2]=O;F[t>>2]=p;e=b;kc(I,p);break u}B:{switch(i-1|0){case 2:case 4:if((b|0)==(c|0)){break r}r=c-4|0;e=F[r>>2];i=F[j+8>>2];m=F[i+12>>2];if((e|0)!=-1&F[m+(e<<2)>>2]!=-1){break r}c=L(h,3);n=(g|0)==3;g=c+(n?2:1)|0;t=g<<2;F[t+m>>2]=e;F[m+(e<<2)>>2]=g;Ma(i+24|0,8324);p=F[j+8>>2];m=F[p+24>>2];if(F[p+28>>2]-m>>2>(C|0)){break r}a=F[p>>2];w=a+t|0;p=F[i+28>>2];i=F[i+24>>2];t=(p-i>>2)-1|0;F[w>>2]=t;if((i|0)!=(p|0)){F[m+(t<<2)>>2]=g;}g=n?c:c+2|0;w=a+(c+n<<2)|0;C:{if((e|0)==-1){F[a+(g<<2)>>2]=-1;i=-1;break C}D:{E:{F:{if((e>>>0)%3|0){i=e-1|0;break F}i=e+2|0;if((i|0)==-1){break E}}i=F[a+(i<<2)>>2];F[a+(g<<2)>>2]=i;if((i|0)==-1){break D}F[m+(i<<2)>>2]=g;break D}F[a+(g<<2)>>2]=-1;}i=e+1|0;e=(i>>>0)%3|0?i:e-2|0;i=-1;if((e|0)==-1){break C}i=F[a+(e<<2)>>2];}F[w>>2]=i;F[r>>2]=c;e=b;break v;case 6:break w;case 0:break B;default:break r}}if((e|0)==(c|0)){break r}f=c-4|0;m=F[f>>2];F[l+68>>2]=f;n=F[l+44>>2];G:{if(!n){break G}g=F[l+40>>2];p=ni(n)>>>0>1;a=h&n+2147483647;H:{if(!p){break H}a=h;if(a>>>0<n>>>0){break H}a=(h>>>0)%(n>>>0)|0;}i=a;a=F[g+(i<<2)>>2];if(!a){break G}a=F[a>>2];if(!a){break G}I:{if(!p){g=n-1|0;while(1){n=F[a+4>>2];J:{if((n|0)!=(h|0)){if((i|0)==(g&n)){break J}break G}if((h|0)==F[a+8>>2]){break I}}a=F[a>>2];if(a){continue}break}break G}while(1){g=F[a+4>>2];K:{if((g|0)!=(h|0)){if(g>>>0>=n>>>0){g=(g>>>0)%(n>>>0)|0;}if((g|0)==(i|0)){break K}break G}if((h|0)==F[a+8>>2]){break I}}a=F[a>>2];if(a){continue}break}break G}if((f|0)!=(k|0)){F[f>>2]=F[a+12>>2];F[l+68>>2]=c;f=c;break G}b=k-e|0;c=b>>2;d=c+1|0;if(d>>>0>=1073741824){break b}f=b>>>1|0;d=b>>>0>=2147483644?1073741823:d>>>0<f>>>0?f:d;if(d){if(d>>>0>=1073741824){break p}f=ka(d<<2);}else {f=0;}b=f+(c<<2)|0;F[b>>2]=F[a+12>>2];d=f+(d<<2)|0;f=b+4|0;if((e|0)!=(k|0)){while(1){b=b-4|0;k=k-4|0;F[b>>2]=F[k>>2];if((e|0)!=(k|0)){continue}break}}F[l+72>>2]=d;F[l+68>>2]=f;F[l+64>>2]=b;if(e){ja(e);}e=b;k=d;}if((e|0)==(f|0)){break t}x=f-4|0;a=F[x>>2];if((a|0)==(m|0)){break t}i=(a|0)==-1;g=F[j+8>>2];if(!i&F[F[g+12>>2]+(a<<2)>>2]!=-1){break t}n=F[g+12>>2];if((m|0)!=-1&F[n+(m<<2)>>2]!=-1){break t}p=L(h,3);t=p+2|0;F[n+(a<<2)>>2]=t;c=t<<2;F[c+n>>2]=a;h=p+1|0;F[n+(m<<2)>>2]=h;w=h<<2;F[w+n>>2]=m;L:{M:{N:{if(!i){if((a>>>0)%3|0){h=a-1|0;break N}h=a+2|0;if((h|0)!=-1){break N}i=F[g>>2];h=-1;break M}h=-1;i=F[g>>2];F[i+(p<<2)>>2]=-1;r=-1;break L}i=F[g>>2];h=F[i+(h<<2)>>2];}F[(p<<2)+i>>2]=h;r=a+1|0;a=(r>>>0)%3|0?r:a-2|0;r=-1;if((a|0)==-1){break L}r=F[(a<<2)+i>>2];}F[i+w>>2]=r;O:{if((m|0)==-1){F[c+i>>2]=-1;r=-1;c=-1;break O}P:{Q:{R:{if((m>>>0)%3|0){a=m-1|0;break R}a=m+2|0;if((a|0)==-1){break Q}}a=F[(a<<2)+i>>2];F[c+i>>2]=a;if((a|0)==-1){break P}F[F[g+24>>2]+(a<<2)>>2]=t;break P}F[c+i>>2]=-1;}r=-1;a=m+1|0;a=(a>>>0)%3|0?a:m-2|0;c=-1;if((a|0)==-1){break O}r=F[(a<<2)+i>>2];c=a;}a=F[j+388>>2];t=h<<2;m=a+t|0;w=a;a=r<<2;F[m>>2]=F[m>>2]+F[w+a>>2];w=a;a=F[g+24>>2];m=w+a|0;if((h|0)!=-1){F[a+t>>2]=F[m>>2];}a=c;while(1){if((a|0)!=-1){F[(a<<2)+i>>2]=h;t=a+1|0;a=(t>>>0)%3|0?t:a-2|0;g=-1;S:{if((a|0)==-1){break S}a=F[n+(a<<2)>>2];g=-1;if((a|0)==-1){break S}g=a+1|0;g=(g>>>0)%3|0?g:a-2|0;}a=g;if((c|0)!=(a|0)){continue}break t}break}F[m>>2]=-1;T:{U:{if(K){break U}if((y|0)!=(z|0)){F[z>>2]=r;z=z+4|0;F[l+28>>2]=z;break U}a=y-o|0;g=a>>2;c=g+1|0;if(c>>>0>=1073741824){break T}h=a>>>1|0;h=a>>>0>=2147483644?1073741823:c>>>0<h>>>0?h:c;if(h){if(h>>>0>=1073741824){break p}c=ka(h<<2);}else {c=0;}a=c+(g<<2)|0;F[a>>2]=r;z=a+4|0;if((o|0)!=(y|0)){while(1){a=a-4|0;y=y-4|0;F[a>>2]=F[y>>2];if((o|0)!=(y|0)){continue}break}}y=c+(h<<2)|0;F[l+32>>2]=y;F[l+28>>2]=z;F[l+24>>2]=a;if(o){ja(o);}o=a;}F[x>>2]=p;c=f;kc(I,p);break u}break b}g=F[j+8>>2];Ma(g+24|0,8324);a=-1;k=F[j+8>>2];f=L(h,3);i=F[g+28>>2];m=F[g+24>>2];n=i-m|0;g=n>>2;p=g-1|0;F[F[k>>2]+(f<<2)>>2]=p;Ma(k+24|0,8324);r=f+1|0;F[F[k>>2]+(r<<2)>>2]=(F[k+28>>2]-F[k+24>>2]>>2)-1;k=F[j+8>>2];Ma(k+24|0,8324);t=f+2|0;F[F[k>>2]+(t<<2)>>2]=(F[k+28>>2]-F[k+24>>2]>>2)-1;x=F[j+8>>2];k=F[x+24>>2];if(F[x+28>>2]-k>>2>(C|0)){break r}V:{W:{if((i|0)!=(m|0)){F[k+(p<<2)>>2]=f;a=0;if((n|0)==-4){break W}}F[k+(g<<2)>>2]=r;a=g+1|0;if((a|0)==-1){break V}}F[k+(a<<2)>>2]=t;}if((d|0)!=(c|0)){F[c>>2]=f;f=c+4|0;F[l+68>>2]=f;k=d;break v}a=d-b|0;k=a>>2;e=k+1|0;if(e>>>0>=1073741824){break b}c=a>>>1|0;a=a>>>0>=2147483644?1073741823:e>>>0<c>>>0?c:e;if(a){if(a>>>0>=1073741824){break p}c=ka(a<<2);}else {c=0;}e=c+(k<<2)|0;F[e>>2]=f;k=c+(a<<2)|0;f=e+4|0;if((b|0)!=(d|0)){while(1){e=e-4|0;d=d-4|0;F[e>>2]=F[d>>2];if((b|0)!=(d|0)){continue}break}}F[l+72>>2]=k;F[l+68>>2]=f;F[l+64>>2]=e;if(b){ja(b);}d=k;b=e;}kc(I,F[f-4>>2]);a=F[j+40>>2];X:{if((a|0)==F[j+36>>2]){break X}c=a-12|0;g=F[c+4>>2];h=q+(h^-1)|0;if(g>>>0>h>>>0){break t}if((g|0)!=(h|0)){break X}i=G[a-4|0];g=F[c>>2];F[j+40>>2]=c;if((g|0)<0){break t}m=f-4|0;a=F[m>>2];F[l+20>>2]=q+(g^-1);c=l+20|0;F[l+88>>2]=c;Fb(l,l+40|0,c,l+88|0);g=F[l>>2];Y:{if(i&1){c=-1;if((a|0)==-1){break Y}c=a+1|0;c=(c>>>0)%3|0?c:a-2|0;break Y}c=-1;if((a|0)==-1){break Y}c=a-1|0;if((a>>>0)%3|0){break Y}c=a+2|0;}F[g+12>>2]=c;a=F[j+40>>2];if((a|0)==F[j+36>>2]){break X}while(1){c=a-12|0;g=F[c+4>>2];if(g>>>0>h>>>0){break t}if((g|0)!=(h|0)){break X}i=G[a-4|0];g=F[c>>2];F[j+40>>2]=c;if((g|0)<0){break t}a=F[m>>2];F[l+20>>2]=q+(g^-1);c=l+20|0;F[l+88>>2]=c;Fb(l,l+40|0,c,l+88|0);g=F[l>>2];Z:{if(i&1){c=-1;if((a|0)==-1){break Z}c=a+1|0;c=(c>>>0)%3|0?c:a-2|0;break Z}c=-1;if((a|0)==-1){break Z}c=a-1|0;if((a>>>0)%3|0){break Z}c=a+2|0;}F[g+12>>2]=c;a=F[j+40>>2];if((a|0)!=F[j+36>>2]){continue}break}}c=f;}B=(q|0)>(s|0);if((q|0)!=(s|0)){continue}break}s=q;break s}a=-1;if(B){break r}}a=-1;c=F[j+8>>2];if(F[c+28>>2]-F[c+24>>2]>>2>(C|0)){break r}if((b|0)!=(f|0)){m=j+72|0;k=j+60|0;n=j+312|0;while(1){f=f-4|0;q=F[f>>2];F[l+68>>2]=f;_:{if(wa(n)){g=F[j+8>>2];o=F[g>>2];if(((F[g+4>>2]-o>>2>>>0)/3|0)<=(s|0)){a=-1;break r}b=-1;i=F[g+24>>2];a=-1;$:{if((q|0)==-1){break $}e=q+1|0;e=(e>>>0)%3|0?e:q-2|0;a=-1;if((e|0)==-1){break $}a=F[o+(e<<2)>>2];}e=a;a=F[i+(e<<2)>>2];aa:{if((a|0)==-1){h=1;c=-1;break aa}h=1;c=-1;d=a+1|0;a=(d>>>0)%3|0?d:a-2|0;if((a|0)==-1){break aa}h=0;b=a+1|0;b=(b>>>0)%3|0?b:a-2|0;if((b|0)!=-1){c=F[o+(b<<2)>>2];}b=a;}a=-1;d=-1;i=F[i+(c<<2)>>2];if((i|0)!=-1){d=i+1|0;d=(d>>>0)%3|0?d:i-2|0;}if((b|0)==(q|0)|(d|0)==(q|0)|((q|0)!=-1&F[F[g+12>>2]+(q<<2)>>2]!=-1|(b|0)==(d|0))){break r}if(!h&F[F[g+12>>2]+(b<<2)>>2]!=-1){break r}h=-1;g=F[g+12>>2];i=-1;ba:{if((d|0)==-1){break ba}if(F[g+(d<<2)>>2]!=-1){break r}a=d+1|0;a=(a>>>0)%3|0?a:d-2|0;i=-1;if((a|0)==-1){break ba}i=F[o+(a<<2)>>2];}a=L(s,3);F[l>>2]=a;F[g+(a<<2)>>2]=q;F[g+(q<<2)>>2]=a;a=F[l>>2]+1|0;F[g+(a<<2)>>2]=b;F[g+(b<<2)>>2]=a;a=F[l>>2]+2|0;F[g+(a<<2)>>2]=d;F[g+(d<<2)>>2]=a;a=F[l>>2];F[o+(a<<2)>>2]=c;b=a+1|0;d=o+(b<<2)|0;F[d>>2]=i;q=a+2|0;o=o+(q<<2)|0;F[o>>2]=e;a=F[j+120>>2];e=b?c:-1;c=a+(e>>>3&536870908)|0;g=F[c>>2];N=c,O=oi(e)&g,F[N>>2]=O;h=(b|0)!=-1?F[d>>2]:h;b=a+(h>>>3&536870908)|0;d=F[b>>2];N=b,O=oi(h)&d,F[N>>2]=O;d=-1;d=(q|0)!=-1?F[o>>2]:d;a=a+(d>>>3&536870908)|0;b=F[a>>2];N=a,O=oi(d)&b,F[N>>2]=O;D[l+88|0]=1;wd(k,l+88|0);Ma(m,l);s=s+1|0;b=F[l+64>>2];break _}d=F[j+64>>2];a=F[j+68>>2];if((d|0)==a<<5){if((d+1|0)<0){break b}if(d>>>0<=1073741822){a=a<<6;d=(d&-32)+32|0;a=a>>>0>d>>>0?a:d;}else {a=2147483647;}$a(k,a);d=F[j+64>>2];}F[j+64>>2]=d+1;a=F[j+60>>2]+(d>>>3&536870908)|0;e=F[a>>2];N=a,O=oi(d)&e,F[N>>2]=O;d=F[j+76>>2];if((d|0)!=F[j+80>>2]){F[d>>2]=q;F[j+76>>2]=d+4;break _}c=F[m>>2];a=d-c|0;o=a>>2;e=o+1|0;if(e>>>0>=1073741824){break b}h=a>>>1|0;h=a>>>0>=2147483644?1073741823:e>>>0<h>>>0?h:e;if(h){if(h>>>0>=1073741824){break p}a=ka(h<<2);}else {a=0;}e=a+(o<<2)|0;F[e>>2]=q;q=e+4|0;if((d|0)!=(c|0)){while(1){e=e-4|0;d=d-4|0;F[e>>2]=F[d>>2];if((d|0)!=(c|0)){continue}break}}F[j+80>>2]=a+(h<<2);F[j+76>>2]=q;F[j+72>>2]=e;if(!c){break _}ja(c);}if((b|0)!=(f|0)){continue}break}c=F[j+8>>2];}a=-1;if(((F[c+4>>2]-F[c>>2]>>2>>>0)/3|0)!=(s|0)){break r}a=F[c+28>>2]-F[c+24>>2]>>2;f=F[l+24>>2];h=F[l+28>>2];if((f|0)==(h|0)){break q}while(1){b=F[f>>2];k=F[c+24>>2];d=a-1|0;e=k+(d<<2)|0;if(F[e>>2]==-1){while(1){d=a-2|0;a=a-1|0;e=k+(d<<2)|0;if(F[e>>2]==-1){continue}break}}if(b>>>0<=d>>>0){F[l>>2]=c;e=F[e>>2];D[l+12|0]=1;F[l+8>>2]=e;F[l+4>>2]=e;if((e|0)!=-1){while(1){e=F[F[j+8>>2]>>2]+(e<<2)|0;if(F[e>>2]!=(d|0)){a=-1;break r}F[e>>2]=b;nc(l);e=F[l+8>>2];if((e|0)!=-1){continue}break}c=F[j+8>>2];}k=F[c+24>>2];e=k+(d<<2)|0;if((b|0)!=-1){F[k+(b<<2)>>2]=F[e>>2];}F[e>>2]=-1;e=1<<b;k=F[j+120>>2];b=k+(b>>>3&536870908)|0;k=k+(d>>>3&536870908)|0;d=1<<d;if(F[k>>2]&d){e=e|F[b>>2];}else {e=F[b>>2]&(e^-1);}F[b>>2]=e;F[k>>2]=F[k>>2]&(d^-1);a=a-1|0;}f=f+4|0;if((h|0)!=(f|0)){continue}break}}f=F[l+24>>2];}if(f){ja(f);}b=F[l+48>>2];if(b){while(1){d=F[b>>2];ja(b);b=d;if(b){continue}break}}b=F[l+40>>2];F[l+40>>2]=0;if(b){ja(b);}b=F[l+64>>2];if(b){F[l+68>>2]=b;ja(b);}Z=l+96|0;break o}oa();v();}f=a;if((a|0)==-1){break n}a=J;b=F[a+16>>2];d=b+F[a>>2]|0;b=F[a+8>>2]-b|0;a=F[F[j+4>>2]+32>>2];E[a+38>>1]=H[a+38>>1];F[a>>2]=d;F[a+16>>2]=0;F[a+20>>2]=0;F[a+8>>2]=b;F[a+12>>2]=0;ca:{if(F[j+216>>2]==F[j+220>>2]){break ca}a=F[j+8>>2];if(F[a+4>>2]==F[a>>2]){break ca}b=0;while(1){if(Ad(j,b)){b=b+3|0;a=F[j+8>>2];if(b>>>0<F[a+4>>2]-F[a>>2]>>2>>>0){continue}break ca}break}break n}if(G[j+308|0]){D[j+308|0]=0;d=F[j+292>>2];a=0;e=F[j+304>>2]+7|0;a=e>>>0<7?1:a;e=a<<29|e>>>3;b=e+F[j+288>>2]|0;a=(a>>>3|0)+d|0;F[j+288>>2]=b;F[j+292>>2]=b>>>0<e>>>0?a+1|0:a;}b=F[j+216>>2];if((b|0)!=F[j+220>>2]){a=0;while(1){e=L(a,144);Zc((e+b|0)+4|0,F[j+8>>2]);d=F[A>>2];c=d+e|0;b=F[c+132>>2];c=F[c+136>>2];if((b|0)!=(c|0)){while(1){Xc((e+F[A>>2]|0)+4|0,F[b>>2]);b=b+4|0;if((c|0)!=(b|0)){continue}break}d=F[A>>2];}if(!Yc((d+e|0)+4|0)){break n}a=a+1|0;b=F[j+216>>2];if(a>>>0<(F[j+220>>2]-b|0)/144>>>0){continue}break}}a=F[j+8>>2];Hb(j+184|0,F[a+28>>2]-F[a+24>>2]>>2);d=F[j+216>>2];if((d|0)!=F[j+220>>2]){b=0;while(1){a=L(b,144)+d|0;d=F[a+60>>2]-F[a+56>>2]>>2;c=a+104|0;a=F[j+8>>2];a=F[a+28>>2]-F[a+24>>2]>>2;Hb(c,(a|0)<(d|0)?d:a);b=b+1|0;d=F[j+216>>2];if(b>>>0<(F[j+220>>2]-d|0)/144>>>0){continue}break}}M=zd(j,f);}}Z=u- -64|0;return M|0}na();v();}function lh(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,I=0,J=0,K=0,M=0;t=Z+-64|0;Z=t;F[a+132>>2]=0;if(F[a+148>>2]){c=F[a+144>>2];if(c){while(1){b=F[c>>2];ja(c);c=b;if(b){continue}break}}c=0;F[a+144>>2]=0;b=F[a+140>>2];a:{if(!b){break a}if(b>>>0>=4){h=b&-4;while(1){e=c<<2;F[e+F[a+136>>2]>>2]=0;F[F[a+136>>2]+(e|4)>>2]=0;F[F[a+136>>2]+(e|8)>>2]=0;F[F[a+136>>2]+(e|12)>>2]=0;c=c+4|0;f=f+4|0;if((h|0)!=(f|0)){continue}break}}b=b&3;if(!b){break a}f=0;while(1){F[F[a+136>>2]+(c<<2)>>2]=0;c=c+1|0;f=f+1|0;if((b|0)!=(f|0)){continue}break}}F[a+148>>2]=0;}b:{if(!Da(1,t+60|0,F[F[a+4>>2]+32>>2])){break b}F[a+156>>2]=F[t+60>>2];if(!Da(1,t+56|0,F[F[a+4>>2]+32>>2])){break b}e=F[t+56>>2];if(e>>>0>1431655765){break b}c=F[a+156>>2];b=L(e,3);if(c>>>0>b>>>0){break b}f=b>>>1|0;b=c>>31;h=ki(c-1|0,b-!c|0,c,b);b=_;c=b>>>1|0;b=(b&1)<<31|h>>>1;if(!c&b>>>0<f>>>0){break b}c=F[F[a+4>>2]+32>>2];h=F[c+8>>2];m=F[c+12>>2];b=F[c+20>>2];f=F[c+16>>2];if((m|0)<=(b|0)&f>>>0>=h>>>0|(b|0)>(m|0)){break b}h=G[f+F[c>>2]|0];f=f+1|0;b=f?b:b+1|0;F[c+16>>2]=f;F[c+20>>2]=b;if(!Da(1,t+52|0,c)){break b}n=F[t+52>>2];if(n>>>0>e>>>0|e>>>0>n+((n>>>0)/3|0)>>>0){break b}if(!Da(1,t+48|0,F[F[a+4>>2]+32>>2])){break b}c=F[t+48>>2];if(c>>>0>n>>>0){break b}F[a+28>>2]=F[a+24>>2];f=Zb(ka(88));b=F[a+8>>2];F[a+8>>2]=f;if(b){Za(b);if(!F[a+8>>2]){break b}}F[a+164>>2]=F[a+160>>2];Ib(a+160|0,e);F[a+176>>2]=F[a+172>>2];Ib(a+172|0,e);F[a- -64>>2]=0;F[a+92>>2]=-1;F[a+84>>2]=-1;F[a+88>>2]=-1;F[a+40>>2]=F[a+36>>2];F[a+52>>2]=F[a+48>>2];F[a+76>>2]=F[a+72>>2];y=a+216|0;Dd(y);Cd(y,h);if(!_c(F[a+8>>2],e,c+F[a+156>>2]|0)){break b}b=F[a+156>>2];D[t+8|0]=1;Ea(a+120|0,b+c|0,t+8|0);if((Bd(a,F[F[a+4>>2]+32>>2])|0)==-1){break b}c=a+232|0;F[c+144>>2]=a;b=F[($[F[F[a>>2]+32>>2]](a)|0)+32>>2];b=F[b>>2]+F[b+16>>2]|0;f=F[($[F[F[a>>2]+32>>2]](a)|0)+32>>2];f=F[f+8>>2]-F[f+16>>2]|0;K=c,M=H[F[($[F[F[a>>2]+32>>2]](a)|0)+32>>2]+38>>1],E[K+38>>1]=M;F[c>>2]=b;F[c+16>>2]=0;F[c+20>>2]=0;F[c+8>>2]=f;F[c+12>>2]=0;F[a+372>>2]=h;C=Ja(t+8|0);h=C;m=0;d=Z-16|0;Z=d;b=F[c+4>>2];F[c+40>>2]=F[c>>2];F[c+44>>2]=b;b=F[c+36>>2];F[c+72>>2]=F[c+32>>2];F[c+76>>2]=b;f=F[c+28>>2];b=c- -64|0;F[b>>2]=F[c+24>>2];F[b+4>>2]=f;b=F[c+20>>2];F[c+56>>2]=F[c+16>>2];F[c+60>>2]=b;b=F[c+12>>2];F[c+48>>2]=F[c+8>>2];F[c+52>>2]=b;c:{d:{if(hc(c+40|0,1,d+8|0)){b=F[c+44>>2];F[c>>2]=F[c+40>>2];F[c+4>>2]=b;b=F[c+76>>2];F[c+32>>2]=F[c+72>>2];F[c+36>>2]=b;b=F[c+68>>2];F[c+24>>2]=F[c+64>>2];F[c+28>>2]=b;f=F[c+60>>2];g=f;b=F[c+56>>2];F[c+16>>2]=b;F[c+20>>2]=f;e=F[c+52>>2];f=F[c+48>>2];F[c+8>>2]=f;F[c+12>>2]=e;k=F[d+12>>2];i=e-((b>>>0>f>>>0)+g|0)|0;e=f-b|0;f=F[d+8>>2];if((k|0)==(i|0)&e>>>0>=f>>>0|i>>>0>k>>>0){break d}}break c}e=g+k|0;b=b+f|0;e=b>>>0<f>>>0?e+1|0:e;F[c+16>>2]=b;F[c+20>>2]=e;if(!Aa(c+80|0,c)){break c}if(!yd(c)){break c}b=F[c+4>>2];F[h>>2]=F[c>>2];F[h+4>>2]=b;b=F[c+36>>2];F[h+32>>2]=F[c+32>>2];F[h+36>>2]=b;b=F[c+28>>2];F[h+24>>2]=F[c+24>>2];F[h+28>>2]=b;b=F[c+20>>2];F[h+16>>2]=F[c+16>>2];F[h+20>>2]=b;b=F[c+12>>2];F[h+8>>2]=F[c+8>>2];F[h+12>>2]=b;m=1;}Z=d+16|0;e:{if(!m){break e}b=0;c=0;f=0;m=0;j=Z-96|0;Z=j;F[j+72>>2]=0;F[j+64>>2]=0;F[j+68>>2]=0;F[j+48>>2]=0;F[j+52>>2]=0;F[j+40>>2]=0;F[j+44>>2]=0;F[j+56>>2]=1065353216;F[j+32>>2]=0;F[j+24>>2]=0;F[j+28>>2]=0;h=a;B=F[a+124>>2];f:{g:{h:{i:{j:{k:{l:{m:{if((n|0)<=0){break m}I=F[h+216>>2]!=F[h+220>>2];z=1;while(1){e=m;m=e+1|0;n:{o:{p:{q:{r:{s:{t:{u:{v:{w:{x:{y:{z:{A:{B:{if(!G[h+308|0]){break B}k=F[h+296>>2];d=F[h+304>>2];a=k+(d>>>3|0)|0;l=F[h+300>>2];if(a>>>0>=l>>>0){break B}g=G[a|0];a=d+1|0;F[h+304>>2]=a;p=g>>>(d&7)&1;if(!p){break B}i=0;g=a>>>3|0;r=k+g|0;C:{if(r>>>0>=l>>>0){d=a;a=0;break C}r=G[r|0];d=d+2|0;F[h+304>>2]=d;g=d>>>3|0;a=r>>>(a&7)&1;}g=g+k|0;if(g>>>0<l>>>0){g=G[g|0];F[h+304>>2]=d+1;i=g>>>(d&7)<<1&2;}g=-1;i=p|(a|i)<<1;switch(i-1|0){case 6:break y;case 0:break z;case 2:case 4:break A;default:break l}}if((c|0)==(f|0)){g=-1;break l}d=-1;i=F[h+8>>2];z=F[i+24>>2];r=c-4|0;b=F[r>>2];a=-1;D:{if((b|0)==-1){break D}k=b+1|0;k=(k>>>0)%3|0?k:b-2|0;a=-1;if((k|0)==-1){break D}a=F[F[i>>2]+(k<<2)>>2];}g=F[z+(a<<2)>>2];if((g|0)!=-1){d=g+1|0;d=(d>>>0)%3|0?d:g-2|0;}if((b|0)==(d|0)){g=-1;break l}if((b|0)!=-1){g=-1;if(F[F[i+12>>2]+(b<<2)>>2]!=-1){break l}}k=F[i+12>>2];if((d|0)!=-1){g=-1;if(F[k+(d<<2)>>2]!=-1){break l}}l=L(e,3);e=l+1|0;F[k+(b<<2)>>2]=e;s=e<<2;F[s+k>>2]=b;p=l+2|0;F[k+(d<<2)>>2]=p;u=p<<2;F[u+k>>2]=d;k=-1;e=-1;E:{if((b|0)==-1){break E}F:{if((b>>>0)%3|0){b=b-1|0;break F}b=b+2|0;e=-1;if((b|0)==-1){break E}}e=F[F[i>>2]+(b<<2)>>2];}b=e;G:{if((d|0)==-1){break G}e=d+1|0;e=(e>>>0)%3|0?e:d-2|0;if((e|0)==-1){break G}k=F[F[i>>2]+(e<<2)>>2];}g=-1;if((a|0)==(b|0)|(a|0)==(k|0)){break l}e=F[i>>2];F[e+(l<<2)>>2]=a;F[e+s>>2]=k;F[e+u>>2]=b;if((b|0)!=-1){F[z+(b<<2)>>2]=p;}b=F[h+120>>2]+(a>>>3&536870908)|0;e=F[b>>2];K=b,M=oi(a)&e,F[K>>2]=M;F[r>>2]=l;b=f;break n}if((c|0)==(f|0)){break l}r=c-4|0;b=F[r>>2];a=F[h+8>>2];d=F[a+12>>2];if((b|0)!=-1&F[d+(b<<2)>>2]!=-1){break l}l=(i|0)==5;i=L(e,3);p=(l?2:1)+i|0;s=p<<2;F[s+d>>2]=b;F[d+(b<<2)>>2]=p;Ma(a+24|0,8324);d=F[h+8>>2];k=F[d+24>>2];if(F[d+28>>2]-k>>2>(B|0)){break l}d=F[d>>2];u=d+s|0;g=F[a+28>>2];a=F[a+24>>2];s=(g-a>>2)-1|0;F[u>>2]=s;if((a|0)!=(g|0)){F[k+(s<<2)>>2]=p;}g=l?i:i+2|0;l=d+(i+l<<2)|0;H:{if((b|0)==-1){F[d+(g<<2)>>2]=-1;a=-1;break H}I:{J:{K:{if((b>>>0)%3|0){a=b-1|0;break K}a=b+2|0;if((a|0)==-1){break J}}a=F[d+(a<<2)>>2];F[d+(g<<2)>>2]=a;if((a|0)==-1){break I}F[k+(a<<2)>>2]=g;break I}F[d+(g<<2)>>2]=-1;}g=b+1|0;b=(g>>>0)%3|0?g:b-2|0;a=-1;if((b|0)==-1){break H}a=F[d+(b<<2)>>2];}F[l>>2]=a;F[r>>2]=i;b=f;break t}if((b|0)==(c|0)){break l}a=c-4|0;k=F[a>>2];F[j+68>>2]=a;l=F[j+44>>2];L:{if(!l){c=a;break L}g=F[j+40>>2];p=ni(l)>>>0>1;d=e&l+2147483647;M:{if(!p){break M}d=e;if(d>>>0<l>>>0){break M}d=(e>>>0)%(l>>>0)|0;}i=d;d=F[g+(i<<2)>>2];if(!d){c=a;break L}d=F[d>>2];if(!d){c=a;break L}N:{if(!p){g=l-1|0;while(1){l=F[d+4>>2];O:{if((l|0)!=(e|0)){if((i|0)==(g&l)){break O}c=a;break L}if((e|0)==F[d+8>>2]){break N}}d=F[d>>2];if(d){continue}break}c=a;break L}while(1){g=F[d+4>>2];P:{if((g|0)!=(e|0)){if(g>>>0>=l>>>0){g=(g>>>0)%(l>>>0)|0;}if((g|0)==(i|0)){break P}c=a;break L}if((e|0)==F[d+8>>2]){break N}}d=F[d>>2];if(d){continue}break}c=a;break L}if((a|0)!=(q|0)){F[a>>2]=F[d+12>>2];F[j+68>>2]=c;break L}a=q-b|0;f=a>>2;c=f+1|0;if(c>>>0>=1073741824){break x}g=a>>>1|0;g=a>>>0>=2147483644?1073741823:c>>>0<g>>>0?g:c;if(g){if(g>>>0>=1073741824){break j}a=ka(g<<2);}else {a=0;}f=a+(f<<2)|0;F[f>>2]=F[d+12>>2];c=f+4|0;if((b|0)!=(q|0)){while(1){f=f-4|0;q=q-4|0;F[f>>2]=F[q>>2];if((b|0)!=(q|0)){continue}break}}q=a+(g<<2)|0;F[j+72>>2]=q;F[j+68>>2]=c;F[j+64>>2]=f;if(b){ja(b);}}if((c|0)==(f|0)){break p}s=c-4|0;b=F[s>>2];if((b|0)==(k|0)){break p}a=(b|0)==-1;g=F[h+8>>2];if(!a&F[F[g+12>>2]+(b<<2)>>2]!=-1){break p}l=F[g+12>>2];if((k|0)!=-1&F[l+(k<<2)>>2]!=-1){break p}p=L(e,3);r=p+2|0;F[l+(b<<2)>>2]=r;e=r<<2;F[e+l>>2]=b;d=p+1|0;F[l+(k<<2)>>2]=d;u=d<<2;F[u+l>>2]=k;if(a){break w}if((b>>>0)%3|0){d=b-1|0;break s}d=b+2|0;if((d|0)!=-1){break s}a=F[g>>2];d=-1;break r}i=F[h+8>>2];Ma(i+24|0,8324);d=F[h+8>>2];a=L(e,3);k=F[i+28>>2];l=F[i+24>>2];p=k-l|0;i=p>>2;r=i-1|0;F[F[d>>2]+(a<<2)>>2]=r;Ma(d+24|0,8324);s=a+1|0;F[F[d>>2]+(s<<2)>>2]=(F[d+28>>2]-F[d+24>>2]>>2)-1;d=F[h+8>>2];Ma(d+24|0,8324);u=a+2|0;F[F[d>>2]+(u<<2)>>2]=(F[d+28>>2]-F[d+24>>2]>>2)-1;A=F[h+8>>2];d=F[A+24>>2];if(F[A+28>>2]-d>>2>(B|0)){break l}Q:{R:{if((k|0)!=(l|0)){F[d+(r<<2)>>2]=a;g=0;if((p|0)==-4){break R}}F[d+(i<<2)>>2]=s;g=i+1|0;if((g|0)==-1){break Q}}F[d+(g<<2)>>2]=u;}if((c|0)!=(q|0)){F[c>>2]=a;c=c+4|0;F[j+68>>2]=c;break t}f=c-b|0;i=f>>2;d=i+1|0;if(d>>>0>=1073741824){break v}g=f>>>1|0;d=f>>>0>=2147483644?1073741823:d>>>0<g>>>0?g:d;if(d){if(d>>>0>=1073741824){break j}g=ka(d<<2);}else {g=0;}f=g+(i<<2)|0;F[f>>2]=a;q=g+(d<<2)|0;a=f+4|0;if((b|0)!=(c|0)){while(1){f=f-4|0;c=c-4|0;F[f>>2]=F[c>>2];if((b|0)!=(c|0)){continue}break}}F[j+72>>2]=q;F[j+68>>2]=a;F[j+64>>2]=f;if(!b){break u}ja(b);break u}na();v();}d=-1;a=F[g>>2];F[a+(p<<2)>>2]=-1;i=-1;break q}na();v();}c=a;b=f;}a=F[h+40>>2];if((a|0)==F[h+36>>2]){break n}d=a-12|0;i=F[d+4>>2];g=n+(e^-1)|0;if(i>>>0>g>>>0){break p}if((g|0)!=(i|0)){break n}i=G[a-4|0];e=F[d>>2];F[h+40>>2]=d;if((e|0)<0){break p}k=c-4|0;a=F[k>>2];F[j+20>>2]=n+(e^-1);e=j+20|0;F[j+88>>2]=e;Fb(j,j+40|0,e,j+88|0);d=F[j>>2];S:{if(i&1){e=-1;if((a|0)==-1){break S}e=a+1|0;e=(e>>>0)%3|0?e:a-2|0;break S}e=-1;if((a|0)==-1){break S}e=a-1|0;if((a>>>0)%3|0){break S}e=a+2|0;}F[d+12>>2]=e;d=F[h+40>>2];if((d|0)==F[h+36>>2]){break n}while(1){a=d-12|0;e=F[a+4>>2];if(e>>>0>g>>>0){break p}if((g|0)!=(e|0)){break n}d=G[d-4|0];e=F[a>>2];F[h+40>>2]=a;if((e|0)<0){break p}a=F[k>>2];F[j+20>>2]=n+(e^-1);e=j+20|0;F[j+88>>2]=e;Fb(j,j+40|0,e,j+88|0);i=F[j>>2];T:{if(d&1){e=-1;if((a|0)==-1){break T}e=a+1|0;e=(e>>>0)%3|0?e:a-2|0;break T}e=-1;if((a|0)==-1){break T}e=a-1|0;if((a>>>0)%3|0){break T}e=a+2|0;}F[i+12>>2]=e;d=F[h+40>>2];if((d|0)!=F[h+36>>2]){continue}break}break n}a=F[g>>2];d=F[a+(d<<2)>>2];}F[(p<<2)+a>>2]=d;A=b+1|0;b=(A>>>0)%3|0?A:b-2|0;i=-1;if((b|0)==-1){break q}i=F[(b<<2)+a>>2];}F[a+u>>2]=i;U:{if((k|0)==-1){F[a+e>>2]=-1;i=-1;e=-1;break U}V:{W:{X:{if((k>>>0)%3|0){b=k-1|0;break X}b=k+2|0;if((b|0)==-1){break W}}b=F[(b<<2)+a>>2];F[a+e>>2]=b;if((b|0)==-1){break V}F[F[g+24>>2]+(b<<2)>>2]=r;break V}F[a+e>>2]=-1;}i=-1;b=k+1|0;b=(b>>>0)%3|0?b:k-2|0;e=-1;if((b|0)==-1){break U}i=F[(b<<2)+a>>2];e=b;}b=F[g+24>>2];k=b+(i<<2)|0;if((d|0)!=-1){F[b+(d<<2)>>2]=F[k>>2];}b=e;while(1){if((b|0)==-1){break o}F[(b<<2)+a>>2]=d;r=b+1|0;b=(r>>>0)%3|0?r:b-2|0;g=-1;Y:{if((b|0)==-1){break Y}b=F[l+(b<<2)>>2];g=-1;if((b|0)==-1){break Y}g=b+1|0;g=(g>>>0)%3|0?g:b-2|0;}b=g;if((e|0)!=(b|0)){continue}break}}g=-1;if(!z){break m}break l}F[k>>2]=-1;Z:{if(I){break Z}if((w|0)!=(x|0)){F[x>>2]=i;x=x+4|0;F[j+28>>2]=x;break Z}a=w-o|0;d=a>>2;b=d+1|0;if(b>>>0>=1073741824){break i}e=a>>>1|0;e=a>>>0>=2147483644?1073741823:b>>>0<e>>>0?e:b;if(e){if(e>>>0>=1073741824){break j}a=ka(e<<2);}else {a=0;}b=a+(d<<2)|0;F[b>>2]=i;x=b+4|0;if((o|0)!=(w|0)){while(1){b=b-4|0;w=w-4|0;F[b>>2]=F[w>>2];if((o|0)!=(w|0)){continue}break}}w=a+(e<<2)|0;F[j+32>>2]=w;F[j+28>>2]=x;F[j+24>>2]=b;if(o){ja(o);}o=b;}F[s>>2]=p;b=f;}z=(m|0)<(n|0);if((m|0)!=(n|0)){continue}break}m=n;}g=-1;a=F[h+8>>2];if(F[a+28>>2]-F[a+24>>2]>>2>(B|0)){break l}if((c|0)!=(f|0)){l=h+72|0;e=h+60|0;w=h+312|0;while(1){c=c-4|0;i=F[c>>2];F[j+68>>2]=c;_:{if(wa(w)){q=F[h+8>>2];k=F[q>>2];if(((F[q+4>>2]-k>>2>>>0)/3|0)<=(m|0)){g=-1;break l}a=-1;g=-1;b=-1;x=F[q+24>>2];f=-1;$:{if((i|0)==-1){break $}n=i+1|0;n=(n>>>0)%3|0?n:i-2|0;f=-1;if((n|0)==-1){break $}f=F[k+(n<<2)>>2];}n=f;o=F[x+(n<<2)>>2];aa:{if((o|0)==-1){d=1;f=-1;break aa}d=1;p=o+1|0;o=(p>>>0)%3|0?p:o-2|0;f=-1;if((o|0)==-1){break aa}d=0;a=o;f=a+1|0;f=(f>>>0)%3|0?f:a-2|0;if((f|0)!=-1){f=F[k+(f<<2)>>2];}else {f=-1;}}o=F[(f<<2)+x>>2];if((o|0)!=-1){b=o+1|0;b=(b>>>0)%3|0?b:o-2|0;}if((a|0)==(i|0)|(b|0)==(i|0)|((i|0)!=-1&F[F[q+12>>2]+(i<<2)>>2]!=-1|(a|0)==(b|0))){break l}if(!d&F[F[q+12>>2]+(a<<2)>>2]!=-1){break l}d=-1;o=F[q+12>>2];q=-1;ba:{if((b|0)==-1){break ba}if(F[o+(b<<2)>>2]!=-1){break l}g=b+1|0;g=(g>>>0)%3|0?g:b-2|0;q=-1;if((g|0)==-1){break ba}q=F[k+(g<<2)>>2];}g=L(m,3);F[j>>2]=g;F[o+(g<<2)>>2]=i;F[o+(i<<2)>>2]=g;g=F[j>>2]+1|0;F[o+(g<<2)>>2]=a;F[o+(a<<2)>>2]=g;a=F[j>>2]+2|0;F[o+(a<<2)>>2]=b;F[o+(b<<2)>>2]=a;a=F[j>>2];F[k+(a<<2)>>2]=f;b=a+1|0;g=k+(b<<2)|0;F[g>>2]=q;o=a+2|0;i=k+(o<<2)|0;F[i>>2]=n;a=F[h+120>>2];f=b?f:-1;n=a+(f>>>3&536870908)|0;k=F[n>>2];K=n,M=oi(f)&k,F[K>>2]=M;d=(b|0)!=-1?F[g>>2]:d;b=a+(d>>>3&536870908)|0;f=F[b>>2];K=b,M=oi(d)&f,F[K>>2]=M;b=-1;b=(o|0)!=-1?F[i>>2]:b;a=a+(b>>>3&536870908)|0;f=F[a>>2];K=a,M=oi(b)&f,F[K>>2]=M;D[j+88|0]=1;wd(e,j+88|0);Ma(l,j);m=m+1|0;f=F[j+64>>2];break _}b=F[h+64>>2];a=F[h+68>>2];if((b|0)==a<<5){if((b+1|0)<0){break h}if(b>>>0<=1073741822){a=a<<6;b=(b&-32)+32|0;a=a>>>0>b>>>0?a:b;}else {a=2147483647;}$a(e,a);b=F[h+64>>2];}F[h+64>>2]=b+1;a=F[h+60>>2]+(b>>>3&536870908)|0;d=F[a>>2];K=a,M=oi(b)&d,F[K>>2]=M;b=F[h+76>>2];if((b|0)!=F[h+80>>2]){F[b>>2]=i;F[h+76>>2]=b+4;break _}g=F[l>>2];a=b-g|0;o=a>>2;d=o+1|0;if(d>>>0>=1073741824){break g}n=a>>>1|0;n=a>>>0>=2147483644?1073741823:d>>>0<n>>>0?n:d;if(n){if(n>>>0>=1073741824){break j}a=ka(n<<2);}else {a=0;}d=a+(o<<2)|0;F[d>>2]=i;o=d+4|0;if((b|0)!=(g|0)){while(1){d=d-4|0;b=b-4|0;F[d>>2]=F[b>>2];if((b|0)!=(g|0)){continue}break}}F[h+80>>2]=a+(n<<2);F[h+76>>2]=o;F[h+72>>2]=d;if(!g){break _}ja(g);}if((c|0)!=(f|0)){continue}break}a=F[h+8>>2];}g=-1;if(((F[a+4>>2]-F[a>>2]>>2>>>0)/3|0)!=(m|0)){break l}g=F[a+28>>2]-F[a+24>>2]>>2;c=F[j+24>>2];n=F[j+28>>2];if((c|0)==(n|0)){break k}while(1){f=F[c>>2];e=F[a+24>>2];b=g-1|0;d=e+(b<<2)|0;if(F[d>>2]==-1){while(1){b=g-2|0;g=g-1|0;d=e+(b<<2)|0;if(F[d>>2]==-1){continue}break}}if(b>>>0>=f>>>0){F[j>>2]=a;d=F[d>>2];D[j+12|0]=1;F[j+8>>2]=d;F[j+4>>2]=d;if((d|0)!=-1){while(1){a=F[F[h+8>>2]>>2]+(d<<2)|0;if(F[a>>2]!=(b|0)){g=-1;break l}F[a>>2]=f;nc(j);d=F[j+8>>2];if((d|0)!=-1){continue}break}a=F[h+8>>2];}m=F[a+24>>2];e=m+(b<<2)|0;if((f|0)!=-1){F[m+(f<<2)>>2]=F[e>>2];}F[e>>2]=-1;e=1<<f;m=F[h+120>>2];f=m+(f>>>3&536870908)|0;d=1<<b;m=m+(b>>>3&536870908)|0;if(d&F[m>>2]){b=e|F[f>>2];}else {b=F[f>>2]&(e^-1);}F[f>>2]=b;F[m>>2]=F[m>>2]&(d^-1);g=g-1|0;}c=c+4|0;if((n|0)!=(c|0)){continue}break}}c=F[j+24>>2];}if(c){ja(c);}a=F[j+48>>2];if(a){while(1){c=F[a>>2];ja(a);a=c;if(a){continue}break}}a=F[j+40>>2];F[j+40>>2]=0;if(a){ja(a);}a=F[j+64>>2];if(a){F[j+68>>2]=a;ja(a);}Z=j+96|0;a=g;break f}oa();v();}na();v();}na();v();}na();v();}b=a;if((a|0)==-1){break e}a=C;c=F[a+16>>2];f=c+F[a>>2]|0;c=F[a+8>>2]-c|0;a=F[F[h+4>>2]+32>>2];E[a+38>>1]=H[a+38>>1];F[a>>2]=f;F[a+16>>2]=0;F[a+20>>2]=0;F[a+8>>2]=c;F[a+12>>2]=0;ca:{if(F[h+216>>2]==F[h+220>>2]){break ca}a=F[h+8>>2];if(F[a+4>>2]==F[a>>2]){break ca}c=0;while(1){if(Ad(h,c)){c=c+3|0;a=F[h+8>>2];if(c>>>0<F[a+4>>2]-F[a>>2]>>2>>>0){continue}break ca}break}break e}if(G[h+308|0]){D[h+308|0]=0;f=F[h+292>>2];a=0;e=F[h+304>>2]+7|0;a=e>>>0<7?1:a;c=a>>>3|0;m=a<<29|e>>>3;a=m+F[h+288>>2]|0;e=c+f|0;F[h+288>>2]=a;F[h+292>>2]=a>>>0<m>>>0?e+1|0:e;}c=F[h+216>>2];if((c|0)!=F[h+220>>2]){a=0;while(1){e=L(a,144);Zc((e+c|0)+4|0,F[h+8>>2]);f=F[y>>2];m=f+e|0;c=F[m+132>>2];m=F[m+136>>2];if((c|0)!=(m|0)){while(1){Xc((e+F[y>>2]|0)+4|0,F[c>>2]);c=c+4|0;if((m|0)!=(c|0)){continue}break}f=F[y>>2];}if(!Yc((f+e|0)+4|0)){break e}a=a+1|0;c=F[h+216>>2];if(a>>>0<(F[h+220>>2]-c|0)/144>>>0){continue}break}}a=F[h+8>>2];Hb(h+184|0,F[a+28>>2]-F[a+24>>2]>>2);f=F[h+216>>2];if((f|0)!=F[h+220>>2]){c=0;while(1){a=L(c,144)+f|0;f=F[a+60>>2]-F[a+56>>2]>>2;e=a+104|0;a=F[h+8>>2];a=F[a+28>>2]-F[a+24>>2]>>2;Hb(e,(a|0)<(f|0)?f:a);c=c+1|0;f=F[h+216>>2];if(c>>>0<(F[h+220>>2]-f|0)/144>>>0){continue}break}}J=zd(h,b);}}Z=t- -64|0;return J|0}function Cf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,E=0,H=0,I=0,J=0,K=0,M=0,N=0,O=0;B=c;c=0;m=Z-96|0;Z=m;l=m+16|0;ma(l,0,76);F[m+92>>2]=-1;F[m+8>>2]=0;F[m>>2]=0;F[m+4>>2]=0;r=Z-16|0;Z=r;F[l+68>>2]=0;F[l+72>>2]=0;F[l>>2]=b;s=Z-16|0;Z=s;u=b;a=F[b+20>>2];a:{if((F[b+24>>2]-a|0)<=0){break a}a=F[a>>2];if((a|0)==-1){break a}c=F[F[u+8>>2]+(a<<2)>>2];}b:{c:{d:{if(!c){a=0;break d}a=F[u+100>>2];e=F[u+96>>2];F[s+8>>2]=0;F[s>>2]=0;F[s+4>>2]=0;f=a-e|0;b=(f|0)/12|0;e:{if((a|0)==(e|0)){break e}if(b>>>0>=357913942){break c}d=ka(f);F[s>>2]=d;F[s+8>>2]=d+L(b,12);a=0;n=d;f=f-12|0;d=(f-((f>>>0)%12|0)|0)+12|0;f=ma(n,0,d);F[s+4>>2]=d+f;if(G[c+84|0]){c=b>>>0<=1?1:b;h=c&1;if(b>>>0>=2){g=c&-2;c=0;while(1){d=L(a,12);b=d+e|0;i=F[b+4>>2];j=F[b>>2];d=d+f|0;F[d+8>>2]=F[b+8>>2];F[d>>2]=j;F[d+4>>2]=i;d=L(a|1,12);b=d+e|0;i=F[b+4>>2];j=F[b>>2];d=d+f|0;F[d+8>>2]=F[b+8>>2];F[d>>2]=j;F[d+4>>2]=i;a=a+2|0;c=c+2|0;if((g|0)!=(c|0)){continue}break}}if(!h){break e}b=L(a,12);a=b+e|0;c=F[a+4>>2];e=F[a>>2];b=b+f|0;F[b+8>>2]=F[a+8>>2];F[b>>2]=e;F[b+4>>2]=c;break e}h=b>>>0<=1?1:b;a=F[c+68>>2];c=0;while(1){d=L(c,12);b=d+e|0;g=F[a+(F[b>>2]<<2)>>2];i=F[a+(F[b+4>>2]<<2)>>2];d=d+f|0;F[d+8>>2]=F[a+(F[b+8>>2]<<2)>>2];F[d+4>>2]=i;F[d>>2]=g;c=c+1|0;if((h|0)!=(c|0)){continue}break}}d=0;H=Z-16|0;Z=H;h=ka(88);Zb(h);C=Z-16|0;Z=C;F[h+80>>2]=0;F[h+84>>2]=0;a=F[h+76>>2];F[h+76>>2]=0;if(a){ja(a);}F[h+68>>2]=0;F[h+72>>2]=0;b=h- -64|0;a=F[b>>2];F[b>>2]=0;if(a){ja(a);}g=F[s+4>>2];b=F[s>>2];c=(g-b|0)/12|0;a=L(c,3);f=F[h>>2];e=F[h+4>>2]-f>>2;f:{if(a>>>0>e>>>0){nd(h,a-e|0);g=F[s+4>>2];b=F[s>>2];c=(g-b|0)/12|0;break f}if(a>>>0>=e>>>0){break f}F[h+4>>2]=f+(a<<2);}g:{if((b|0)==(g|0)){break g}e=c>>>0<=1?1:c;g=e&1;a=F[h>>2];if(c>>>0>=2){i=e&-2;c=0;while(1){e=L(d,12);j=e+a|0;f=b+e|0;F[j>>2]=F[f>>2];F[a+(e|4)>>2]=F[f+4>>2];F[j+8>>2]=F[f+8>>2];f=L(d|1,12);e=f+a|0;f=b+f|0;F[e>>2]=F[f>>2];F[e+4>>2]=F[f+4>>2];F[e+8>>2]=F[f+8>>2];d=d+2|0;c=c+2|0;if((i|0)!=(c|0)){continue}break}}if(!g){break g}c=L(d,12);a=c+a|0;b=b+c|0;F[a>>2]=F[b>>2];F[a+4>>2]=F[b+4>>2];F[a+8>>2]=F[b+8>>2];}F[C+12>>2]=-1;a=0;e=0;g=0;f=Z-32|0;Z=f;h:{i:{w=C+12|0;j:{if(!w){break j}c=F[h+4>>2];j=F[h>>2];d=c-j|0;i=d>>2;n=F[h+12>>2];b=F[h+16>>2]-n>>2;k:{if(i>>>0>b>>>0){ab(h+12|0,i-b|0,10228);c=F[h+4>>2];j=F[h>>2];d=c-j|0;i=d>>2;break k}if(b>>>0<=i>>>0){break k}F[h+16>>2]=n+(i<<2);}F[f+24>>2]=0;F[f+16>>2]=0;F[f+20>>2]=0;b=(c|0)==(j|0);if(!b){if((d|0)<0){break i}e=ka(d);F[f+20>>2]=e;F[f+16>>2]=e;F[f+24>>2]=(i<<2)+e;}l:{m:{n:{o:{p:{if(d){while(1){i=F[(a<<2)+j>>2];b=F[f+20>>2]-e>>2;q:{if(i>>>0<b>>>0){break q}F[f>>2]=0;d=i+1|0;if(d>>>0>b>>>0){Fa(f+16|0,d-b|0,f);j=F[h>>2];c=F[h+4>>2];e=F[f+16>>2];break q}if(b>>>0<=d>>>0){break q}F[f+20>>2]=(d<<2)+e;}b=(i<<2)+e|0;F[b>>2]=F[b>>2]+1;a=a+1|0;d=c-j|0;i=d>>2;if(a>>>0<i>>>0){continue}break}break p}d=0;if(!b){break o}break n}if((c|0)==(j|0)){d=0;break n}if(d>>>0>=2147483645){break m}}d=ka(d<<1);ma(d,255,i<<3);}F[f+8>>2]=0;F[f>>2]=0;F[f+4>>2]=0;b=F[f+20>>2];a=b-e|0;t=a>>2;r:{s:{if((b|0)==(e|0)){break s}if((a|0)<0){break r}q=ka(a);F[f>>2]=q;F[f+8>>2]=(t<<2)+q;b=ma(q,0,a);F[f+4>>2]=b+a;c=t>>>0<=1?1:t;n=c&3;a=0;if(c-1>>>0>=3){o=c&-4;while(1){c=g<<2;F[c+b>>2]=a;x=c|4;a=F[c+e>>2]+a|0;F[x+b>>2]=a;y=c|8;a=a+F[e+x>>2]|0;F[y+b>>2]=a;c=c|12;a=a+F[e+y>>2]|0;F[c+b>>2]=a;a=a+F[c+e>>2]|0;g=g+4|0;p=p+4|0;if((o|0)!=(p|0)){continue}break}}if(!n){break s}while(1){c=g<<2;F[c+b>>2]=a;g=g+1|0;a=F[c+e>>2]+a|0;k=k+1|0;if((n|0)!=(k|0)){continue}break}}if(!i){break l}x=F[h+40>>2];y=F[h+12>>2];n=0;while(1){I=n<<2;a=I+j|0;k=-1;c=n+1|0;b=(c>>>0)%3|0?c:n-2|0;if((b|0)!=-1){k=F[(b<<2)+j>>2];}b=F[a>>2];t:{u:{if(!((n>>>0)%3|0)){p=-1;a=n+2|0;if((a|0)!=-1){p=F[(a<<2)+j>>2];}if(!((b|0)==(k|0)|(b|0)==(p|0))&(k|0)!=(p|0)){break u}x=x+1|0;F[h+40>>2]=x;c=n+3|0;break t}p=F[a-4>>2];}a=p<<2;A=F[a+e>>2];v:{w:{if((A|0)<=0){break w}a=F[a+q>>2];g=0;while(1){o=(a<<3)+d|0;z=F[o>>2];if((z|0)==-1){break w}x:{if((k|0)!=(z|0)){break x}o=F[o+4>>2];if((o|0)!=-1){z=F[(o<<2)+j>>2];}else {z=-1;}if((z|0)==(b|0)){break x}while(1){y:{b=a;g=g+1|0;if((A|0)<=(g|0)){break y}a=b+1|0;J=(a<<3)+d|0;z=F[J>>2];K=(b<<3)+d|0;F[K+4>>2]=F[J+4>>2];F[K>>2]=z;if((z|0)!=-1){continue}}break}F[(b<<3)+d>>2]=-1;if((o|0)==-1){break w}F[y+I>>2]=o;F[y+(o<<2)>>2]=n;break v}a=a+1|0;g=g+1|0;if((A|0)!=(g|0)){continue}break}}a=k<<2;k=F[a+e>>2];if((k|0)<=0){break v}a=F[a+q>>2];g=0;while(1){b=(a<<3)+d|0;if(F[b>>2]==-1){F[b>>2]=p;F[b+4>>2]=n;break v}a=a+1|0;g=g+1|0;if((k|0)!=(g|0)){continue}break}}}n=c;if(n>>>0<i>>>0){continue}break}break l}break i}na();v();}F[w>>2]=t;if(q){ja(q);}if(d){ja(d);}a=F[f+16>>2];if(!a){break j}F[f+20>>2]=a;ja(a);}Z=f+32|0;x=(w|0)!=0;if(x){k=Z-32|0;Z=k;a=F[h>>2];g=F[h+4>>2];F[k+24>>2]=0;F[k+16>>2]=0;F[k+20>>2]=0;if((a|0)==(g|0)){c=g;}else {a=g-a|0;if((a|0)<0){break i}a=a>>2;b=(a-1>>>5|0)+1|0;c=ka(b<<2);F[k+24>>2]=b;F[k+20>>2]=0;F[k+16>>2]=c;Yb(k+16|0,a);g=F[h>>2];c=F[h+4>>2];}F[k+8>>2]=0;F[k>>2]=0;while(1){z:{o=0;i=0;if((c|0)==(g|0)){break z}while(1){b=F[k+16>>2];A:{if(F[b+(i>>>3&536870908)>>2]>>>i&1){break A}c=F[k>>2];F[k+4>>2]=c;e=F[h+12>>2];a=i;while(1){B:{f=a+1|0;d=a;a=(f>>>0)%3|0?f:a-2|0;if((a|0)==-1){break B}a=F[e+(a<<2)>>2];if((a|0)==-1){break B}f=a+1|0;a=(f>>>0)%3|0?f:a-2|0;if((i|0)==(a|0)|(a|0)==-1){break B}if(!(F[b+(a>>>3&536870908)>>2]>>>a&1)){continue}}break}j=d;C:{D:{E:{while(1){a=F[k+16>>2]+(j>>>3&536870908)|0;F[a>>2]=F[a>>2]|1<<j;a=j+1|0;f=(a>>>0)%3|0?a:j-2|0;g=F[h>>2];y=(j>>>0)%3|0;b=(y?-1:2)+j|0;n=F[k>>2];A=(n|0)==(c|0);F:{if(A){break F}w=F[(f<<2)+g>>2];q=F[h+12>>2];a=n;if((b|0)!=-1){e=q+(b<<2)|0;while(1){G:{if((w|0)!=F[a>>2]){break G}p=F[a+4>>2];t=F[e>>2];if((p|0)==(t|0)){break G}e=b;c=-1;a=-1;if((p|0)==-1){break C}break D}a=a+8|0;if((c|0)!=(a|0)){continue}break}break F}while(1){if((w|0)==F[a>>2]){t=-1;e=-1;p=F[a+4>>2];if((p|0)!=-1){break D}}a=a+8|0;if((c|0)!=(a|0)){continue}break}}b=F[(b<<2)+g>>2];H:{if(F[k+8>>2]!=(c|0)){F[c>>2]=b;F[c+4>>2]=f;c=c+8|0;F[k+4>>2]=c;break H}a=c-n|0;p=a>>3;e=p+1|0;if(e>>>0>=536870912){break i}g=a>>>2|0;g=a>>>0>=2147483640?536870911:e>>>0<g>>>0?g:e;if(g){if(g>>>0>=536870912){break E}e=ka(g<<3);}else {e=0;}a=e+(p<<3)|0;F[a>>2]=b;F[a+4>>2]=f;b=a+8|0;if(!A){while(1){c=c-8|0;f=F[c+4>>2];a=a-8|0;F[a>>2]=F[c>>2];F[a+4>>2]=f;if((c|0)!=(n|0)){continue}break}c=F[k>>2];}F[k+8>>2]=e+(g<<3);F[k+4>>2]=b;F[k>>2]=a;if(c){ja(c);}c=b;}I:{J:{if(y){a=j-1|0;break J}a=j+2|0;if((a|0)==-1){break I}}a=F[F[h+12>>2]+(a<<2)>>2];if((a|0)==-1){break I}j=a+((a>>>0)%3|0?-1:2)|0;if((d|0)==(j|0)){break I}if((j|0)!=-1){continue}}break}g=F[h>>2];break A}oa();v();}c=F[q+(p<<2)>>2];b=e;a=p;}if((t|0)!=-1){F[q+(t<<2)>>2]=-1;}if((c|0)!=-1){F[q+(c<<2)>>2]=-1;}F[q+(b<<2)>>2]=-1;F[q+(a<<2)>>2]=-1;o=1;}i=i+1|0;c=F[h+4>>2];if(i>>>0<c-g>>2>>>0){continue}break}if(o){continue}}break}a=F[k>>2];if(a){ja(a);}a=F[k+16>>2];if(a){ja(a);}Z=k+32|0;n=0;g=Z-32|0;Z=g;e=F[C+12>>2];F[h+36>>2]=e;p=h+24|0;b=F[h+24>>2];a=F[h+28>>2]-b>>2;K:{L:{if(a>>>0<e>>>0){ab(p,e-a|0,10228);F[g+24>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;break L}if(a>>>0>e>>>0){F[h+28>>2]=b+(e<<2);}F[g+24>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;if(!e){break K}}if((e|0)<0){break i}a=(e-1>>>5|0)+1|0;b=ka(a<<2);F[g+24>>2]=a;F[g+20>>2]=0;F[g+16>>2]=b;Yb(g+16|0,e);}a=F[h>>2];b=F[h+4>>2];F[g+8>>2]=0;F[g>>2]=0;F[g+4>>2]=0;M:{if((a|0)==(b|0)){a=b;}else {a=b-a|0;if((a|0)<0){break i}a=a>>2;b=(a-1>>>5|0)+1|0;c=ka(b<<2);F[g+8>>2]=b;F[g+4>>2]=0;F[g>>2]=c;Yb(g,a);b=F[h>>2];a=F[h+4>>2];}if(a-b>>>0<12){break M}N:{while(1){q=L(n,3);d=(q<<2)+b|0;f=F[d>>2];c=-1;i=q+1|0;if((i|0)!=-1){c=F[(i<<2)+b>>2];}O:{if((c|0)==(f|0)){break O}i=f;f=F[d+8>>2];if((i|0)==(f|0)|(c|0)==(f|0)){break O}k=0;i=F[g>>2];while(1){f=k+q|0;if(!(F[(f>>>3&536870908)+i>>2]>>>f&1)){a=F[(f<<2)+b>>2];c=1<<a;d=F[g+16>>2];b=a>>>5|0;i=F[d+(b<<2)>>2];t=c&i;if(t){c=F[h+28>>2];P:{if((c|0)!=F[h+32>>2]){F[c>>2]=-1;F[h+28>>2]=c+4;break P}i=F[p>>2];b=c-i|0;o=b>>2;d=o+1|0;if(d>>>0>=1073741824){break i}j=b>>>1|0;j=b>>>0>=2147483644?1073741823:d>>>0<j>>>0?j:d;if(j){if(j>>>0>=1073741824){break N}b=ka(j<<2);}else {b=0;}d=b+(o<<2)|0;F[d>>2]=-1;o=d+4|0;if((c|0)!=(i|0)){while(1){d=d-4|0;c=c-4|0;F[d>>2]=F[c>>2];if((c|0)!=(i|0)){continue}break}}F[h+32>>2]=b+(j<<2);F[h+28>>2]=o;F[h+24>>2]=d;if(!i){break P}ja(i);}c=F[h+52>>2];Q:{if((c|0)!=F[h+56>>2]){F[c>>2]=a;F[h+52>>2]=c+4;break Q}i=F[h+48>>2];b=c-i|0;o=b>>2;d=o+1|0;if(d>>>0>=1073741824){break i}j=b>>>1|0;j=b>>>0>=2147483644?1073741823:d>>>0<j>>>0?j:d;if(j){if(j>>>0>=1073741824){break N}b=ka(j<<2);}else {b=0;}d=b+(o<<2)|0;F[d>>2]=a;a=d+4|0;if((c|0)!=(i|0)){while(1){d=d-4|0;c=c-4|0;F[d>>2]=F[c>>2];if((c|0)!=(i|0)){continue}break}}F[h+56>>2]=b+(j<<2);F[h+52>>2]=a;F[h+48>>2]=d;if(!i){break Q}ja(i);}c=F[g+20>>2];a=F[g+24>>2];if((c|0)==a<<5){if((c+1|0)<0){break i}b=g+16|0;if(c>>>0<=1073741822){a=a<<6;c=(c&-32)+32|0;a=a>>>0>c>>>0?a:c;}else {a=2147483647;}$a(b,a);c=F[g+20>>2];}F[g+20>>2]=c+1;d=F[g+16>>2];a=d+(c>>>3&536870908)|0;b=F[a>>2];N=a,O=oi(c)&b,F[N>>2]=O;c=1<<e;b=e>>>5|0;i=F[(b<<2)+d>>2];a=e;e=a+1|0;}F[(b<<2)+d>>2]=c|i;o=F[h+24>>2]+(a<<2)|0;j=F[h+12>>2];b=F[h>>2];i=F[g>>2];c=f;R:{S:{T:{while(1){if((c|0)==-1){break T}d=(c>>>3&536870908)+i|0;F[d>>2]=F[d>>2]|1<<c;F[o>>2]=c;if(t){F[(c<<2)+b>>2]=a;}w=c+1|0;c=(w>>>0)%3|0?w:c-2|0;d=-1;U:{if((c|0)==-1){break U}c=F[j+(c<<2)>>2];d=-1;if((c|0)==-1){break U}d=c+1|0;d=(d>>>0)%3|0?d:c-2|0;}c=d;if((f|0)!=(c|0)){continue}break}if((f|0)!=-1){break R}c=1;break S}if((f>>>0)%3|0){c=f-1|0;break S}c=f+2|0;if((c|0)==-1){break R}}c=F[j+(c<<2)>>2];if((c|0)==-1){break R}V:{if((c>>>0)%3|0){c=c-1|0;break V}c=c+2|0;if((c|0)==-1){break R}}f=F[h+12>>2];b=F[h>>2];while(1){d=(c>>>3&536870908)+i|0;F[d>>2]=F[d>>2]|1<<c;if(t){F[(c<<2)+b>>2]=a;}W:{if((c>>>0)%3|0){c=c-1|0;break W}c=c+2|0;if((c|0)==-1){break R}}c=F[f+(c<<2)>>2];if((c|0)==-1){break R}c=c+((c>>>0)%3|0?-1:2)|0;if((c|0)!=-1){continue}break}}}k=k+1|0;if((k|0)!=3){continue}break}b=F[h>>2];a=F[h+4>>2];}n=n+1|0;if(n>>>0<(a-b>>2>>>0)/3>>>0){continue}break}break M}oa();v();}c=0;F[h+44>>2]=0;a=F[g+16>>2];b=F[g+20>>2];if(b){e=b&31;b=(b>>>3&536870908)+a|0;d=a;i=0;while(1){if(!(F[d>>2]>>>c&1)){i=i+1|0;F[h+44>>2]=i;}f=(c|0)==31;c=f?0:c+1|0;d=(f<<2)+d|0;if((b|0)!=(d|0)|(c|0)!=(e|0)){continue}break}}b=F[g>>2];if(b){ja(b);a=F[g+16>>2];}if(a){ja(a);}Z=g+32|0;}Z=C+16|0;if(!x){F[H+8>>2]=0;Za(h);h=0;}Z=H+16|0;a=h;break h}na();v();}b=F[s>>2];if(!b){break d}F[s+4>>2]=b;ja(b);}Z=s+16|0;break b}na();v();}c=F[l+4>>2];b=a;F[l+4>>2]=a;if(c){Za(c);b=F[l+4>>2];}X:{if(!b){break X}a=F[u+100>>2];c=F[u+96>>2];D[r+12|0]=0;Ea(l+56|0,(a-c|0)/12|0,r+12|0);a=F[u+100>>2];c=F[u+96>>2];if((a|0)==(c|0)){break X}while(1){if(!(F[F[l+56>>2]+(E>>>3&536870908)>>2]>>>E&1)){a=L(E,3);Vb(l,0,a);c=F[l+8>>2];e=F[l+12>>2];Vb(l,1,a+1|0);f=F[l+20>>2];d=F[l+24>>2];Vb(l,2,a+2|0);n=(c|0)==(e|0)?-1:0;a=d-f>>2;c=e-c>>2;e=a>>>0>c>>>0;c=F[l+36>>2]-F[l+32>>2]>>2>>>0>(e?a:c)>>>0?2:e?1:n;Y:{if(F[l+68>>2]<=0){break Y}F[r+12>>2]=F[l+76>>2];F[r+8>>2]=m;Qa(r+8|0,r+12|0);a=F[((c<<2)+l|0)+44>>2];if((a|0)<0){a=-1;}else {e=(a>>>0)/3|0;a=F[(F[F[l>>2]+96>>2]+L(e,12)|0)+(a-L(e,3)<<2)>>2];}F[r+12>>2]=a;F[r+8>>2]=m;Qa(r+8|0,r+12|0);e=F[l+72>>2];F[l+72>>2]=e+2;if(!(e&1)){break Y}F[r+12>>2]=a;F[r+8>>2]=m;Qa(r+8|0,r+12|0);F[l+72>>2]=F[l+72>>2]+1;}d=0;e=Z-16|0;Z=e;F[l+68>>2]=F[l+68>>2]+1;a=L(c,12)+l|0;a=F[a+12>>2]-F[a+8>>2]|0;if((a|0)>0){a=a>>>2|0;h=a>>>0<=1?1:a;c=F[((c<<2)+l|0)+44>>2];while(1){a=c;f=(a>>>0)/3|0;c=(a|0)==-1;g=c?-1:f;i=F[l+56>>2]+(g>>>3&536870908)|0;F[i>>2]=F[i>>2]|1<<g;F[l+72>>2]=F[l+72>>2]+1;Z:{_:{$:{aa:{ba:{if(!d){ca:{if((a|0)>=0){F[e+12>>2]=F[(F[F[l>>2]+96>>2]+L(f,12)|0)+((a>>>0)%3<<2)>>2];F[e+8>>2]=m;Qa(e+8|0,e+12|0);break ca}F[e+12>>2]=-1;F[e+8>>2]=m;Qa(e+8|0,e+12|0);if(c){break ba}}c=-1;f=a+1|0;f=(f>>>0)%3|0?f:a-2|0;if((f|0)>=0){g=(f>>>0)/3|0;f=F[(F[F[l>>2]+96>>2]+L(g,12)|0)+(f-L(g,3)<<2)>>2];}else {f=-1;}F[e+12>>2]=f;F[e+8>>2]=m;Qa(e+8|0,e+12|0);f=((a>>>0)%3|0?-1:2)+a|0;if((f|0)<0){break aa}c=(f>>>0)/3|0;c=F[(F[F[l>>2]+96>>2]+L(c,12)|0)+(f-L(c,3)<<2)>>2];break aa}c=(a|0)<0?-1:F[(F[F[l>>2]+96>>2]+L(f,12)|0)+((a>>>0)%3<<2)>>2];F[l+76>>2]=c;F[e+12>>2]=c;F[e+8>>2]=m;Qa(e+8|0,e+12|0);if(d&1){c=-1;if((a|0)==-1){break Z}if((L(f,3)|0)!=(a|0)){a=a-1|0;break _}a=a+2|0;break $}c=-1;if((a|0)==-1){break Z}c=a+1|0;a=(c>>>0)%3|0?c:a-2|0;break $}c=-1;F[e+12>>2]=-1;F[e+8>>2]=m;Qa(e+8|0,e+12|0);}F[l+76>>2]=c;F[e+12>>2]=c;F[e+8>>2]=m;Qa(e+8|0,e+12|0);}c=-1;if((a|0)==-1){break Z}}c=F[F[F[l+4>>2]+12>>2]+(a<<2)>>2];}d=d+1|0;if((h|0)!=(d|0)){continue}break}}Z=e+16|0;c=F[u+96>>2];a=F[u+100>>2];}E=E+1|0;if(E>>>0<(a-c|0)/12>>>0){continue}break}}Z=r+16|0;da:{if(b){a=F[B>>2];if(a){F[B+4>>2]=a;ja(a);}F[B>>2]=F[m>>2];F[B+4>>2]=F[m+4>>2];F[B+8>>2]=F[m+8>>2];M=F[m+84>>2];break da}a=F[m>>2];if(!a){break da}F[m+4>>2]=a;ja(a);}a=F[m+72>>2];if(a){ja(a);}a=F[m+48>>2];if(a){F[m+52>>2]=a;ja(a);}a=F[m+36>>2];if(a){F[m+40>>2]=a;ja(a);}a=F[m+24>>2];if(a){F[m+28>>2]=a;ja(a);}a=F[m+20>>2];F[m+20>>2]=0;if(a){Za(a);}Z=m+96|0;return M|0}function sf(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;i=b;a=0;b=0;a:{b:{switch(d-1|0){case 0:j=F[i+80>>2];h=G[c+24|0];c:{if((L(j,h)|0)!=(e|0)){break c}d=F[c+28>>2]!=1;b=G[c+84|0];if(!(d|!b)){la(f,F[F[c>>2]>>2]+F[c+48>>2]|0,e);b=1;break c}if(h){a=ka(h);ma(a,0,h);}d:{if(!j){b=1;break d}if(!d){if(h){d=0;e=0;while(1){i=d+f|0;k=F[F[c>>2]>>2];m=F[c+48>>2];g=F[c+40>>2];b=ki(g,F[c+44>>2],G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],0);n=b;b=b+m|0;la(i,la(a,b+k|0,g),h);d=d+h|0;b=1;e=e+1|0;if((j|0)!=(e|0)){continue}break}break d}if(b){b=1;h=F[c>>2];e=F[c+48>>2];f=F[c+40>>2];i=F[c+44>>2];if((j|0)!=1){g=j&-2;c=0;d=0;while(1){k=F[h>>2];m=ki(f,i,c,0)+e|0;k=la(a,k+m|0,f);m=F[h>>2];n=ki(f,i,c|1,0)+e|0;la(k,m+n|0,f);c=c+2|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}g=c;}if(!(j&1)){break d}c=F[h>>2];d=ki(g,0,f,i)+e|0;la(a,c+d|0,f);break d}b=1;h=F[c>>2];e=F[c+48>>2];g=F[c+68>>2];f=F[c+40>>2];i=F[c+44>>2];c=0;if((j|0)!=1){k=j&-2;d=0;while(1){m=F[h>>2];n=c<<2;l=ki(f,i,F[n+g>>2],0)+e|0;m=la(a,m+l|0,f);l=F[h>>2];n=ki(f,i,F[g+(n|4)>>2],0)+e|0;la(m,l+n|0,f);c=c+2|0;d=d+2|0;if((k|0)!=(d|0)){continue}break}}if(!(j&1)){break d}d=F[h>>2];c=ki(f,i,F[g+(c<<2)>>2],0)+e|0;la(a,c+d|0,f);break d}b=0;if(!h){d=0;while(1){if(!Cb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],a)){break d}d=d+1|0;b=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}break d}d=0;e=0;while(1){if(!Cb(c,G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],D[c+24|0],a)){break d}la(d+f|0,a,h);d=d+h|0;e=e+1|0;b=j>>>0<=e>>>0;if((e|0)!=(j|0)){continue}break}}if(!a){break c}ja(a);}break a;case 2:n=G[c+24|0];l=n<<1;j=F[i+80>>2];e:{if((L(l,j)|0)!=(e|0)){break e}i=F[c+28>>2]!=3;d=G[c+84|0];if(!(i|!d)){la(f,F[F[c>>2]>>2]+F[c+48>>2]|0,e);a=1;break e}f:{if(!n){e=0;break f}e=ka(l);ma(e,0,l);}g:{if(!j){a=1;break g}if(!i){o=F[c+68>>2];k=F[c>>2];b=F[c+48>>2];i=F[c+40>>2];m=F[c+44>>2];if(n){if(!d){c=0;d=0;while(1){a=1;g=F[k>>2];p=ki(i,m,F[o+(d<<2)>>2],0)+b|0;la((c<<1)+f|0,la(e,g+p|0,i),l);c=c+n|0;d=d+1|0;if((j|0)!=(d|0)){continue}break}break g}c=0;while(1){a=1;o=F[k>>2];p=ki(g,h,i,m)+b|0;la((c<<1)+f|0,la(e,o+p|0,i),l);c=c+n|0;d=h;g=g+1|0;d=g?d:d+1|0;h=d;if((j|0)!=(g|0)|d){continue}break}break g}if(!d){a=1;c=0;if((j|0)!=1){f=j&-2;d=0;while(1){h=F[k>>2];g=c<<2;n=ki(i,m,F[g+o>>2],0)+b|0;h=la(e,h+n|0,i);n=F[k>>2];g=ki(i,m,F[o+(g|4)>>2],0)+b|0;la(h,g+n|0,i);c=c+2|0;d=d+2|0;if((f|0)!=(d|0)){continue}break}}if(!(j&1)){break g}d=F[k>>2];b=ki(i,m,F[o+(c<<2)>>2],0)+b|0;la(e,b+d|0,i);break g}n=j&1;a=1;if((j|0)!=1){j=j&-2;f=0;c=0;while(1){d=F[k>>2];l=ki(g,h,i,m)+b|0;d=la(e,d+l|0,i);l=F[k>>2];o=ki(i,m,g|1,h)+b|0;la(d,l+o|0,i);g=g+2|0;h=g>>>0<2?h+1|0:h;f=f+2|0;d=f>>>0<2?c+1|0:c;c=d;if((f|0)!=(j|0)|c){continue}break}}if(!n){break g}c=F[k>>2];b=ki(g,h,i,m)+b|0;la(e,b+c|0,i);break g}if(!n){d=0;while(1){if(!Ab(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],e)){break g}d=d+1|0;a=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}break g}d=0;while(1){if(!Ab(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],e)){break g}la((b<<1)+f|0,e,l);b=b+n|0;d=d+1|0;a=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}}if(!e){break e}ja(e);}b=a;break a;case 4:l=G[c+24|0];o=l<<2;j=F[i+80>>2];h:{if((L(o,j)|0)!=(e|0)){break h}i=F[c+28>>2]!=5;d=G[c+84|0];if(!(i|!d)){la(f,F[F[c>>2]>>2]+F[c+48>>2]|0,e);b=1;break h}i:{if(!l){e=0;break i}e=ka(o);ma(e,0,o);}b=1;j:{if(!j){break j}if(!i){a=F[c+68>>2];m=F[c>>2];i=F[c+48>>2];k=F[c+40>>2];n=F[c+44>>2];if(l){if(!d){c=0;d=0;while(1){g=F[m>>2];p=ki(k,n,F[a+(d<<2)>>2],0)+i|0;la((c<<2)+f|0,la(e,g+p|0,k),o);c=c+l|0;d=d+1|0;if((j|0)!=(d|0)){continue}break}break j}c=0;while(1){d=F[m>>2];p=ki(g,h,k,n)+i|0;la((c<<2)+f|0,la(e,d+p|0,k),o);c=c+l|0;g=g+1|0;a=g?h:h+1|0;h=a;if((j|0)!=(g|0)|h){continue}break}break j}if(!d){c=0;if((j|0)!=1){f=j&-2;d=0;while(1){h=F[m>>2];g=c<<2;l=ki(k,n,F[g+a>>2],0)+i|0;h=la(e,h+l|0,k);l=F[m>>2];g=ki(k,n,F[a+(g|4)>>2],0)+i|0;la(h,g+l|0,k);c=c+2|0;d=d+2|0;if((f|0)!=(d|0)){continue}break}}if(!(j&1)){break j}d=F[m>>2];a=ki(k,n,F[a+(c<<2)>>2],0)+i|0;la(e,a+d|0,k);break j}l=j&1;if((j|0)!=1){j=j&-2;f=0;c=0;while(1){a=F[m>>2];d=ki(g,h,k,n)+i|0;a=la(e,a+d|0,k);d=F[m>>2];o=ki(k,n,g|1,h)+i|0;la(a,d+o|0,k);d=h;g=g+2|0;h=g>>>0<2?d+1|0:d;f=f+2|0;a=f>>>0<2?c+1|0:c;c=a;if((f|0)!=(j|0)|c){continue}break}}if(!l){break j}a=F[m>>2];c=ki(g,h,k,n)+i|0;la(e,a+c|0,k);break j}b=0;if(!l){d=0;while(1){if(!yb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],e)){break j}d=d+1|0;b=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}break j}d=0;while(1){if(!yb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],e)){break j}la((a<<2)+f|0,e,o);a=a+l|0;d=d+1|0;b=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}}if(!e){break h}ja(e);}break a;case 1:j=F[i+80>>2];h=G[c+24|0];k:{if((L(j,h)|0)!=(e|0)){break k}d=F[c+28>>2]!=2;b=G[c+84|0];if(!(d|!b)){la(f,F[F[c>>2]>>2]+F[c+48>>2]|0,e);b=1;break k}if(h){a=ka(h);ma(a,0,h);}l:{if(!j){b=1;break l}if(!d){if(h){d=0;e=0;while(1){i=d+f|0;k=F[F[c>>2]>>2];m=F[c+48>>2];g=F[c+40>>2];b=ki(g,F[c+44>>2],G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],0);n=b;b=b+m|0;la(i,la(a,b+k|0,g),h);d=d+h|0;b=1;e=e+1|0;if((j|0)!=(e|0)){continue}break}break l}if(b){b=1;h=F[c>>2];e=F[c+48>>2];f=F[c+40>>2];i=F[c+44>>2];if((j|0)!=1){g=j&-2;c=0;d=0;while(1){k=F[h>>2];m=ki(f,i,c,0)+e|0;k=la(a,k+m|0,f);m=F[h>>2];n=ki(f,i,c|1,0)+e|0;la(k,m+n|0,f);c=c+2|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}g=c;}if(!(j&1)){break l}c=F[h>>2];d=ki(g,0,f,i)+e|0;la(a,c+d|0,f);break l}b=1;h=F[c>>2];e=F[c+48>>2];g=F[c+68>>2];f=F[c+40>>2];i=F[c+44>>2];c=0;if((j|0)!=1){k=j&-2;d=0;while(1){m=F[h>>2];n=c<<2;l=ki(f,i,F[n+g>>2],0)+e|0;m=la(a,m+l|0,f);l=F[h>>2];n=ki(f,i,F[g+(n|4)>>2],0)+e|0;la(m,l+n|0,f);c=c+2|0;d=d+2|0;if((k|0)!=(d|0)){continue}break}}if(!(j&1)){break l}d=F[h>>2];c=ki(f,i,F[g+(c<<2)>>2],0)+e|0;la(a,c+d|0,f);break l}b=0;if(!h){d=0;while(1){if(!Bb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],a)){break l}d=d+1|0;b=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}break l}d=0;e=0;while(1){if(!Bb(c,G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],D[c+24|0],a)){break l}la(d+f|0,a,h);d=d+h|0;e=e+1|0;b=j>>>0<=e>>>0;if((e|0)!=(j|0)){continue}break}}if(!a){break k}ja(a);}break a;case 3:n=G[c+24|0];l=n<<1;j=F[i+80>>2];m:{if((L(l,j)|0)!=(e|0)){break m}i=F[c+28>>2]!=4;d=G[c+84|0];if(!(i|!d)){la(f,F[F[c>>2]>>2]+F[c+48>>2]|0,e);a=1;break m}n:{if(!n){e=0;break n}e=ka(l);ma(e,0,l);}o:{if(!j){a=1;break o}if(!i){o=F[c+68>>2];k=F[c>>2];b=F[c+48>>2];i=F[c+40>>2];m=F[c+44>>2];if(n){if(!d){c=0;d=0;while(1){a=1;g=F[k>>2];p=ki(i,m,F[o+(d<<2)>>2],0)+b|0;la((c<<1)+f|0,la(e,g+p|0,i),l);c=c+n|0;d=d+1|0;if((j|0)!=(d|0)){continue}break}break o}c=0;while(1){a=1;o=F[k>>2];p=ki(g,h,i,m)+b|0;la((c<<1)+f|0,la(e,o+p|0,i),l);c=c+n|0;d=h;g=g+1|0;d=g?d:d+1|0;h=d;if((j|0)!=(g|0)|d){continue}break}break o}if(!d){a=1;c=0;if((j|0)!=1){f=j&-2;d=0;while(1){h=F[k>>2];g=c<<2;n=ki(i,m,F[g+o>>2],0)+b|0;h=la(e,h+n|0,i);n=F[k>>2];g=ki(i,m,F[o+(g|4)>>2],0)+b|0;la(h,g+n|0,i);c=c+2|0;d=d+2|0;if((f|0)!=(d|0)){continue}break}}if(!(j&1)){break o}d=F[k>>2];b=ki(i,m,F[o+(c<<2)>>2],0)+b|0;la(e,b+d|0,i);break o}n=j&1;a=1;if((j|0)!=1){j=j&-2;f=0;c=0;while(1){d=F[k>>2];l=ki(g,h,i,m)+b|0;d=la(e,d+l|0,i);l=F[k>>2];o=ki(i,m,g|1,h)+b|0;la(d,l+o|0,i);g=g+2|0;h=g>>>0<2?h+1|0:h;f=f+2|0;d=f>>>0<2?c+1|0:c;c=d;if((f|0)!=(j|0)|c){continue}break}}if(!n){break o}c=F[k>>2];b=ki(g,h,i,m)+b|0;la(e,b+c|0,i);break o}if(!n){d=0;while(1){if(!zb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],e)){break o}d=d+1|0;a=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}break o}d=0;while(1){if(!zb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],e)){break o}la((b<<1)+f|0,e,l);b=b+n|0;d=d+1|0;a=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}}if(!e){break m}ja(e);}b=a;break a;case 5:l=G[c+24|0];o=l<<2;j=F[i+80>>2];p:{if((L(o,j)|0)!=(e|0)){break p}i=F[c+28>>2]!=6;d=G[c+84|0];if(!(i|!d)){la(f,F[F[c>>2]>>2]+F[c+48>>2]|0,e);b=1;break p}q:{if(!l){e=0;break q}e=ka(o);ma(e,0,o);}b=1;r:{if(!j){break r}if(!i){a=F[c+68>>2];m=F[c>>2];i=F[c+48>>2];k=F[c+40>>2];n=F[c+44>>2];if(l){if(!d){c=0;d=0;while(1){g=F[m>>2];p=ki(k,n,F[a+(d<<2)>>2],0)+i|0;la((c<<2)+f|0,la(e,g+p|0,k),o);c=c+l|0;d=d+1|0;if((j|0)!=(d|0)){continue}break}break r}c=0;while(1){d=F[m>>2];p=ki(g,h,k,n)+i|0;la((c<<2)+f|0,la(e,d+p|0,k),o);c=c+l|0;g=g+1|0;a=g?h:h+1|0;h=a;if((j|0)!=(g|0)|h){continue}break}break r}if(!d){c=0;if((j|0)!=1){f=j&-2;d=0;while(1){h=F[m>>2];g=c<<2;l=ki(k,n,F[g+a>>2],0)+i|0;h=la(e,h+l|0,k);l=F[m>>2];g=ki(k,n,F[a+(g|4)>>2],0)+i|0;la(h,g+l|0,k);c=c+2|0;d=d+2|0;if((f|0)!=(d|0)){continue}break}}if(!(j&1)){break r}d=F[m>>2];a=ki(k,n,F[a+(c<<2)>>2],0)+i|0;la(e,a+d|0,k);break r}l=j&1;if((j|0)!=1){j=j&-2;f=0;c=0;while(1){a=F[m>>2];d=ki(g,h,k,n)+i|0;a=la(e,a+d|0,k);d=F[m>>2];o=ki(k,n,g|1,h)+i|0;la(a,d+o|0,k);d=h;g=g+2|0;h=g>>>0<2?d+1|0:d;f=f+2|0;a=f>>>0<2?c+1|0:c;c=a;if((f|0)!=(j|0)|c){continue}break}}if(!l){break r}a=F[m>>2];c=ki(g,h,k,n)+i|0;la(e,a+c|0,k);break r}b=0;if(!l){d=0;while(1){if(!xb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],e)){break r}d=d+1|0;b=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}break r}d=0;while(1){if(!xb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],e)){break r}la((a<<2)+f|0,e,o);a=a+l|0;d=d+1|0;b=j>>>0<=d>>>0;if((d|0)!=(j|0)){continue}break}}if(!e){break p}ja(e);}break a;case 8:p=G[c+24|0];q=p<<2;k=F[i+80>>2];s:{if((L(q,k)|0)!=(e|0)){break s}i=F[c+28>>2];t:{if(!p){break t}a=ka(q);d=a;m=q-4|0;l=(m>>>2|0)+1&7;if(l){e=0;while(1){F[d>>2]=-1073741824;d=d+4|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}if(m>>>0<28){break t}e=(p<<2)+a|0;while(1){F[d+24>>2]=-1073741824;F[d+28>>2]=-1073741824;F[d+16>>2]=-1073741824;F[d+20>>2]=-1073741824;F[d+8>>2]=-1073741824;F[d+12>>2]=-1073741824;F[d>>2]=-1073741824;F[d+4>>2]=-1073741824;d=d+32|0;if((e|0)!=(d|0)){continue}break}}u:{if(!k){b=1;break u}if((i|0)==9){r=F[c+68>>2];l=F[c>>2];i=F[c+48>>2];s=G[c+84|0];m=F[c+44>>2];c=F[c+40>>2];o=c;if(p){e=0;d=0;while(1){h=(e<<2)+f|0;g=F[l>>2];b=ki(c,m,s?d:F[r+(d<<2)>>2],0)+i|0;la(h,la(a,b+g|0,o),q);e=e+p|0;b=1;d=d+1|0;if((k|0)!=(d|0)){continue}break}break u}if(!s){b=1;d=0;if((k|0)!=1){f=k&-2;e=0;while(1){h=F[l>>2];g=d<<2;j=ki(c,m,F[g+r>>2],0)+i|0;h=la(a,h+j|0,o);j=F[l>>2];g=ki(c,m,F[r+(g|4)>>2],0)+i|0;la(h,j+g|0,o);d=d+2|0;e=e+2|0;if((f|0)!=(e|0)){continue}break}}if(!(k&1)){break u}e=F[l>>2];c=ki(c,m,F[r+(d<<2)>>2],0)+i|0;la(a,c+e|0,o);break u}f=k&1;b=1;if((k|0)!=1){k=k&-2;while(1){d=F[l>>2];e=ki(g,h,c,m)+i|0;d=la(a,d+e|0,o);e=F[l>>2];p=ki(c,m,g|1,h)+i|0;la(d,e+p|0,o);g=g+2|0;h=g>>>0<2?h+1|0:h;d=j;e=n+2|0;d=e>>>0<2?d+1|0:d;n=e;j=d;if((e|0)!=(k|0)|d){continue}break}}if(!f){break u}d=F[l>>2];c=ki(g,h,c,m)+i|0;la(a,c+d|0,o);break u}if(!p){d=0;while(1){if(!lb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],a)){break u}d=d+1|0;b=k>>>0<=d>>>0;if((d|0)!=(k|0)){continue}break}break u}e=0;d=0;while(1){if(!lb(c,G[c+84|0]?d:F[F[c+68>>2]+(d<<2)>>2],D[c+24|0],a)){break u}la((e<<2)+f|0,a,q);e=e+p|0;d=d+1|0;b=k>>>0<=d>>>0;if((d|0)!=(k|0)){continue}break}}if(!a){break s}ja(a);}a=b;break;default:break b}}b=a;}return b|0}function Pd(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=Z-80|0;Z=h;e=F[c+36>>2];F[h+72>>2]=F[c+32>>2];F[h+76>>2]=e;f=F[c+28>>2];e=h- -64|0;F[e>>2]=F[c+24>>2];F[e+4>>2]=f;e=F[c+20>>2];F[h+56>>2]=F[c+16>>2];F[h+60>>2]=e;e=F[c+12>>2];F[h+48>>2]=F[c+8>>2];F[h+52>>2]=e;e=F[c+4>>2];F[h+40>>2]=F[c>>2];F[h+44>>2]=e;jc(a,h+40|0,h+24|0);a:{if(F[a>>2]){break a}if(D[a+15|0]<0){ja(F[a+4>>2]);}if(G[h+31|0]!=1){b=ka(32);D[b+20|0]=0;c=G[1446]|G[1447]<<8|(G[1448]<<16|G[1449]<<24);D[b+16|0]=c;D[b+17|0]=c>>>8;D[b+18|0]=c>>>16;D[b+19|0]=c>>>24;c=G[1442]|G[1443]<<8|(G[1444]<<16|G[1445]<<24);d=G[1438]|G[1439]<<8|(G[1440]<<16|G[1441]<<24);D[b+8|0]=d;D[b+9|0]=d>>>8;D[b+10|0]=d>>>16;D[b+11|0]=d>>>24;D[b+12|0]=c;D[b+13|0]=c>>>8;D[b+14|0]=c>>>16;D[b+15|0]=c>>>24;c=G[1434]|G[1435]<<8|(G[1436]<<16|G[1437]<<24);d=G[1430]|G[1431]<<8|(G[1432]<<16|G[1433]<<24);D[b|0]=d;D[b+1|0]=d>>>8;D[b+2|0]=d>>>16;D[b+3|0]=d>>>24;D[b+4|0]=c;D[b+5|0]=c>>>8;D[b+6|0]=c>>>16;D[b+7|0]=c>>>24;F[a>>2]=-1;ra(a+4|0,b,20);ja(b);break a}j=Z-16|0;Z=j;b:{c:{switch(G[h+32|0]){case 0:e=Kd(ka(48));F[e>>2]=9864;F[h+8>>2]=0;F[h+12>>2]=0;F[h>>2]=0;F[h+4>>2]=0;F[h+16>>2]=e;break b;case 1:e=Kd(ka(52));F[e+48>>2]=0;F[e>>2]=8176;F[h+8>>2]=0;F[h+12>>2]=0;F[h>>2]=0;F[h+4>>2]=0;F[h+16>>2]=e;break b;default:break c}}f=ka(32);D[f+28|0]=0;e=G[1520]|G[1521]<<8|(G[1522]<<16|G[1523]<<24);D[f+24|0]=e;D[f+25|0]=e>>>8;D[f+26|0]=e>>>16;D[f+27|0]=e>>>24;e=G[1516]|G[1517]<<8|(G[1518]<<16|G[1519]<<24);g=G[1512]|G[1513]<<8|(G[1514]<<16|G[1515]<<24);D[f+16|0]=g;D[f+17|0]=g>>>8;D[f+18|0]=g>>>16;D[f+19|0]=g>>>24;D[f+20|0]=e;D[f+21|0]=e>>>8;D[f+22|0]=e>>>16;D[f+23|0]=e>>>24;e=G[1508]|G[1509]<<8|(G[1510]<<16|G[1511]<<24);g=G[1504]|G[1505]<<8|(G[1506]<<16|G[1507]<<24);D[f+8|0]=g;D[f+9|0]=g>>>8;D[f+10|0]=g>>>16;D[f+11|0]=g>>>24;D[f+12|0]=e;D[f+13|0]=e>>>8;D[f+14|0]=e>>>16;D[f+15|0]=e>>>24;e=G[1500]|G[1501]<<8|(G[1502]<<16|G[1503]<<24);g=G[1496]|G[1497]<<8|(G[1498]<<16|G[1499]<<24);D[f|0]=g;D[f+1|0]=g>>>8;D[f+2|0]=g>>>16;D[f+3|0]=g>>>24;D[f+4|0]=e;D[f+5|0]=e>>>8;D[f+6|0]=e>>>16;D[f+7|0]=e>>>24;F[j>>2]=-1;e=j|4;ra(e,f,28);k=D[j+15|0];F[h>>2]=F[j>>2];g=h+4|0;d:{if((k|0)>=0){k=F[e+4>>2];F[g>>2]=F[e>>2];F[g+4>>2]=k;F[g+8>>2]=F[e+8>>2];F[h+16>>2]=0;break d}ra(g,F[j+4>>2],F[j+8>>2]);e=D[j+15|0];F[h+16>>2]=0;if((e|0)>=0){break d}ja(F[j+4>>2]);}ja(f);}Z=j+16|0;e=F[h>>2];e:{if(e){F[a>>2]=e;a=a+4|0;if(D[h+15|0]>=0){b=h|4;c=F[b+4>>2];F[a>>2]=F[b>>2];F[a+4>>2]=c;F[a+8>>2]=F[b+8>>2];break e}ra(a,F[h+4>>2],F[h+8>>2]);break e}e=F[h+16>>2];F[h+16>>2]=0;F[e+44>>2]=d;f=Z-32|0;Z=f;F[e+32>>2]=c;F[e+40>>2]=b;F[e+4>>2]=d;jc(a,c,f+16|0);f:{if(F[a>>2]){break f}if(D[a+15|0]<0){ja(F[a+4>>2]);}b=G[f+23|0];if(($[F[F[e>>2]+8>>2]](e)|0)!=(b|0)){b=ka(64);D[b+50|0]=0;c=G[1304]|G[1305]<<8;D[b+48|0]=c;D[b+49|0]=c>>>8;c=G[1300]|G[1301]<<8|(G[1302]<<16|G[1303]<<24);d=G[1296]|G[1297]<<8|(G[1298]<<16|G[1299]<<24);D[b+40|0]=d;D[b+41|0]=d>>>8;D[b+42|0]=d>>>16;D[b+43|0]=d>>>24;D[b+44|0]=c;D[b+45|0]=c>>>8;D[b+46|0]=c>>>16;D[b+47|0]=c>>>24;c=G[1292]|G[1293]<<8|(G[1294]<<16|G[1295]<<24);d=G[1288]|G[1289]<<8|(G[1290]<<16|G[1291]<<24);D[b+32|0]=d;D[b+33|0]=d>>>8;D[b+34|0]=d>>>16;D[b+35|0]=d>>>24;D[b+36|0]=c;D[b+37|0]=c>>>8;D[b+38|0]=c>>>16;D[b+39|0]=c>>>24;c=G[1284]|G[1285]<<8|(G[1286]<<16|G[1287]<<24);d=G[1280]|G[1281]<<8|(G[1282]<<16|G[1283]<<24);D[b+24|0]=d;D[b+25|0]=d>>>8;D[b+26|0]=d>>>16;D[b+27|0]=d>>>24;D[b+28|0]=c;D[b+29|0]=c>>>8;D[b+30|0]=c>>>16;D[b+31|0]=c>>>24;c=G[1276]|G[1277]<<8|(G[1278]<<16|G[1279]<<24);d=G[1272]|G[1273]<<8|(G[1274]<<16|G[1275]<<24);D[b+16|0]=d;D[b+17|0]=d>>>8;D[b+18|0]=d>>>16;D[b+19|0]=d>>>24;D[b+20|0]=c;D[b+21|0]=c>>>8;D[b+22|0]=c>>>16;D[b+23|0]=c>>>24;c=G[1268]|G[1269]<<8|(G[1270]<<16|G[1271]<<24);d=G[1264]|G[1265]<<8|(G[1266]<<16|G[1267]<<24);D[b+8|0]=d;D[b+9|0]=d>>>8;D[b+10|0]=d>>>16;D[b+11|0]=d>>>24;D[b+12|0]=c;D[b+13|0]=c>>>8;D[b+14|0]=c>>>16;D[b+15|0]=c>>>24;c=G[1260]|G[1261]<<8|(G[1262]<<16|G[1263]<<24);d=G[1256]|G[1257]<<8|(G[1258]<<16|G[1259]<<24);D[b|0]=d;D[b+1|0]=d>>>8;D[b+2|0]=d>>>16;D[b+3|0]=d>>>24;D[b+4|0]=c;D[b+5|0]=c>>>8;D[b+6|0]=c>>>16;D[b+7|0]=c>>>24;F[a>>2]=-1;ra(a+4|0,b,50);ja(b);break f}c=G[f+21|0];D[e+36|0]=c;d=G[f+22|0];D[e+37|0]=d;if((c|0)!=2){b=ka(32);D[b+26|0]=0;c=G[1427]|G[1428]<<8;D[b+24|0]=c;D[b+25|0]=c>>>8;c=G[1423]|G[1424]<<8|(G[1425]<<16|G[1426]<<24);d=G[1419]|G[1420]<<8|(G[1421]<<16|G[1422]<<24);D[b+16|0]=d;D[b+17|0]=d>>>8;D[b+18|0]=d>>>16;D[b+19|0]=d>>>24;D[b+20|0]=c;D[b+21|0]=c>>>8;D[b+22|0]=c>>>16;D[b+23|0]=c>>>24;c=G[1415]|G[1416]<<8|(G[1417]<<16|G[1418]<<24);d=G[1411]|G[1412]<<8|(G[1413]<<16|G[1414]<<24);D[b+8|0]=d;D[b+9|0]=d>>>8;D[b+10|0]=d>>>16;D[b+11|0]=d>>>24;D[b+12|0]=c;D[b+13|0]=c>>>8;D[b+14|0]=c>>>16;D[b+15|0]=c>>>24;c=G[1407]|G[1408]<<8|(G[1409]<<16|G[1410]<<24);d=G[1403]|G[1404]<<8|(G[1405]<<16|G[1406]<<24);D[b|0]=d;D[b+1|0]=d>>>8;D[b+2|0]=d>>>16;D[b+3|0]=d>>>24;D[b+4|0]=c;D[b+5|0]=c>>>8;D[b+6|0]=c>>>16;D[b+7|0]=c>>>24;F[a>>2]=-5;ra(a+4|0,b,26);ja(b);break f}b=b?2:3;if((b|0)!=(d|0)){b=ka(32);D[b+26|0]=0;c=G[1400]|G[1401]<<8;D[b+24|0]=c;D[b+25|0]=c>>>8;c=G[1396]|G[1397]<<8|(G[1398]<<16|G[1399]<<24);d=G[1392]|G[1393]<<8|(G[1394]<<16|G[1395]<<24);D[b+16|0]=d;D[b+17|0]=d>>>8;D[b+18|0]=d>>>16;D[b+19|0]=d>>>24;D[b+20|0]=c;D[b+21|0]=c>>>8;D[b+22|0]=c>>>16;D[b+23|0]=c>>>24;c=G[1388]|G[1389]<<8|(G[1390]<<16|G[1391]<<24);d=G[1384]|G[1385]<<8|(G[1386]<<16|G[1387]<<24);D[b+8|0]=d;D[b+9|0]=d>>>8;D[b+10|0]=d>>>16;D[b+11|0]=d>>>24;D[b+12|0]=c;D[b+13|0]=c>>>8;D[b+14|0]=c>>>16;D[b+15|0]=c>>>24;c=G[1380]|G[1381]<<8|(G[1382]<<16|G[1383]<<24);d=G[1376]|G[1377]<<8|(G[1378]<<16|G[1379]<<24);D[b|0]=d;D[b+1|0]=d>>>8;D[b+2|0]=d>>>16;D[b+3|0]=d>>>24;D[b+4|0]=c;D[b+5|0]=c>>>8;D[b+6|0]=c>>>16;D[b+7|0]=c>>>24;F[a>>2]=-5;ra(a+4|0,b,26);ja(b);break f}E[F[e+32>>2]+38>>1]=b|512;g:{if(E[f+26>>1]>=0){break g}j=Z-16|0;Z=j;d=ka(36);b=d;F[b+4>>2]=0;F[b+8>>2]=0;F[b+24>>2]=0;F[b+28>>2]=0;b=b+16|0;F[b>>2]=0;F[b+4>>2]=0;F[d>>2]=d+4;F[d+32>>2]=0;F[d+12>>2]=b;F[j>>2]=0;c=F[e+32>>2];k=Z-16|0;Z=k;b=0;h:{if(!d){break h}F[j>>2]=c;F[k+12>>2]=0;b=0;if(!fb(1,k+12|0,c)){break h}n=F[k+12>>2];if(n){while(1){i:{if(fb(1,k+8|0,F[j>>2])){b=ka(28);F[b+4>>2]=0;F[b+8>>2]=0;c=b+16|0;F[c>>2]=0;F[c+4>>2]=0;F[b>>2]=b+4;F[b+12>>2]=c;F[b+24>>2]=F[k+8>>2];if(Vc(j,b)){break i}Ca(b+12|0,F[b+16>>2]);Ba(b,F[b+4>>2]);ja(b);}b=0;break h}g=Z-16|0;Z=g;F[g+8>>2]=b;j:{if(!b){break j}c=F[d+28>>2];k:{if(c>>>0<I[d+32>>2]){F[g+8>>2]=0;F[c>>2]=b;F[d+28>>2]=c+4;break k}c=0;l:{m:{n:{i=F[d+24>>2];m=F[d+28>>2]-i>>2;b=m+1|0;if(b>>>0<1073741824){i=F[d+32>>2]-i|0;l=i>>>1|0;i=i>>>0>=2147483644?1073741823:b>>>0<l>>>0?l:b;if(i){if(i>>>0>=1073741824){break n}c=ka(i<<2);}l=F[g+8>>2];F[g+8>>2]=0;b=(m<<2)+c|0;F[b>>2]=l;i=(i<<2)+c|0;m=b+4|0;c=F[d+28>>2];l=F[d+24>>2];if((c|0)==(l|0)){break m}while(1){c=c-4|0;p=F[c>>2];F[c>>2]=0;b=b-4|0;F[b>>2]=p;if((c|0)!=(l|0)){continue}break}F[d+32>>2]=i;i=F[d+28>>2];F[d+28>>2]=m;c=F[d+24>>2];F[d+24>>2]=b;if((c|0)==(i|0)){break l}while(1){i=i-4|0;b=F[i>>2];F[i>>2]=0;if(b){Ca(b+12|0,F[b+16>>2]);Ba(b,F[b+4>>2]);ja(b);}if((c|0)!=(i|0)){continue}break}break l}na();v();}oa();v();}F[d+32>>2]=i;F[d+28>>2]=m;F[d+24>>2]=b;}if(c){ja(c);}}b=F[g+8>>2];F[g+8>>2]=0;if(!b){break j}Ca(b+12|0,F[b+16>>2]);Ba(b,F[b+4>>2]);ja(b);}Z=g+16|0;o=o+1|0;if((n|0)!=(o|0)){continue}break}}b=Vc(j,d);}Z=k+16|0;o:{if(b){c=F[e+4>>2];b=F[c+4>>2];F[c+4>>2]=d;if(b){ic(b);}F[a>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[a+12>>2]=0;break o}b=ka(32);D[b+26|0]=0;c=G[1549]|G[1550]<<8;D[b+24|0]=c;D[b+25|0]=c>>>8;c=G[1545]|G[1546]<<8|(G[1547]<<16|G[1548]<<24);g=G[1541]|G[1542]<<8|(G[1543]<<16|G[1544]<<24);D[b+16|0]=g;D[b+17|0]=g>>>8;D[b+18|0]=g>>>16;D[b+19|0]=g>>>24;D[b+20|0]=c;D[b+21|0]=c>>>8;D[b+22|0]=c>>>16;D[b+23|0]=c>>>24;c=G[1537]|G[1538]<<8|(G[1539]<<16|G[1540]<<24);g=G[1533]|G[1534]<<8|(G[1535]<<16|G[1536]<<24);D[b+8|0]=g;D[b+9|0]=g>>>8;D[b+10|0]=g>>>16;D[b+11|0]=g>>>24;D[b+12|0]=c;D[b+13|0]=c>>>8;D[b+14|0]=c>>>16;D[b+15|0]=c>>>24;c=G[1529]|G[1530]<<8|(G[1531]<<16|G[1532]<<24);g=G[1525]|G[1526]<<8|(G[1527]<<16|G[1528]<<24);D[b|0]=g;D[b+1|0]=g>>>8;D[b+2|0]=g>>>16;D[b+3|0]=g>>>24;D[b+4|0]=c;D[b+5|0]=c>>>8;D[b+6|0]=c>>>16;D[b+7|0]=c>>>24;F[a>>2]=-1;ra(a+4|0,b,26);ja(b);F[j+8>>2]=0;ic(d);}Z=j+16|0;if(F[a>>2]){break f}if(D[a+15|0]>=0){break g}ja(F[a+4>>2]);}if(!($[F[F[e>>2]+12>>2]](e)|0)){b=ka(48);D[b+33|0]=0;D[b+32|0]=G[1374];c=G[1370]|G[1371]<<8|(G[1372]<<16|G[1373]<<24);d=G[1366]|G[1367]<<8|(G[1368]<<16|G[1369]<<24);D[b+24|0]=d;D[b+25|0]=d>>>8;D[b+26|0]=d>>>16;D[b+27|0]=d>>>24;D[b+28|0]=c;D[b+29|0]=c>>>8;D[b+30|0]=c>>>16;D[b+31|0]=c>>>24;c=G[1362]|G[1363]<<8|(G[1364]<<16|G[1365]<<24);d=G[1358]|G[1359]<<8|(G[1360]<<16|G[1361]<<24);D[b+16|0]=d;D[b+17|0]=d>>>8;D[b+18|0]=d>>>16;D[b+19|0]=d>>>24;D[b+20|0]=c;D[b+21|0]=c>>>8;D[b+22|0]=c>>>16;D[b+23|0]=c>>>24;c=G[1354]|G[1355]<<8|(G[1356]<<16|G[1357]<<24);d=G[1350]|G[1351]<<8|(G[1352]<<16|G[1353]<<24);D[b+8|0]=d;D[b+9|0]=d>>>8;D[b+10|0]=d>>>16;D[b+11|0]=d>>>24;D[b+12|0]=c;D[b+13|0]=c>>>8;D[b+14|0]=c>>>16;D[b+15|0]=c>>>24;c=G[1346]|G[1347]<<8|(G[1348]<<16|G[1349]<<24);d=G[1342]|G[1343]<<8|(G[1344]<<16|G[1345]<<24);D[b|0]=d;D[b+1|0]=d>>>8;D[b+2|0]=d>>>16;D[b+3|0]=d>>>24;D[b+4|0]=c;D[b+5|0]=c>>>8;D[b+6|0]=c>>>16;D[b+7|0]=c>>>24;F[a>>2]=-1;ra(a+4|0,b,33);ja(b);break f}if(!($[F[F[e>>2]+20>>2]](e)|0)){b=Eb(f,1552);F[a>>2]=-1;c=a+4|0;if(D[b+11|0]>=0){d=F[b+4>>2];F[c>>2]=F[b>>2];F[c+4>>2]=d;F[c+8>>2]=F[b+8>>2];break f}ra(c,F[b>>2],F[b+4>>2]);if(D[b+11|0]>=0){break f}ja(F[b>>2]);break f}if(!($[F[F[e>>2]+24>>2]](e)|0)){b=Eb(f,1307);F[a>>2]=-1;c=a+4|0;if(D[b+11|0]>=0){d=F[b+4>>2];F[c>>2]=F[b>>2];F[c+4>>2]=d;F[c+8>>2]=F[b+8>>2];break f}ra(c,F[b>>2],F[b+4>>2]);if(D[b+11|0]>=0){break f}ja(F[b>>2]);break f}F[a>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[a+12>>2]=0;}Z=f+32|0;if(!F[a>>2]){if(D[a+15|0]<0){ja(F[a+4>>2]);}F[a>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[a+12>>2]=0;}$[F[F[e>>2]+4>>2]](e);}a=F[h+16>>2];F[h+16>>2]=0;if(a){$[F[F[a>>2]+4>>2]](a);}if(D[h+15|0]>=0){break a}ja(F[h+4>>2]);}Z=h+80|0;}function Ub(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;l=Z-16|0;Z=l;a:{b:{c:{d:{e:{f:{g:{h:{i:{if(a>>>0<=244){g=F[2941];h=a>>>0<11?16:a+11&-8;c=h>>>3|0;b=g>>>c|0;if(b&3){c=c+((b^-1)&1)|0;a=c<<3;b=a+11804|0;d=F[a+11812>>2];a=F[d+8>>2];j:{if((b|0)==(a|0)){m=11764,n=oi(c)&g,F[m>>2]=n;break j}F[a+12>>2]=b;F[b+8>>2]=a;}a=d+8|0;b=c<<3;F[d+4>>2]=b|3;b=b+d|0;F[b+4>>2]=F[b+4>>2]|1;break a}k=F[2943];if(k>>>0>=h>>>0){break i}if(b){a=2<<c;a=(0-a|a)&b<<c;d=ji(0-a&a);a=d<<3;b=a+11804|0;e=F[a+11812>>2];a=F[e+8>>2];k:{if((b|0)==(a|0)){g=oi(d)&g;F[2941]=g;break k}F[a+12>>2]=b;F[b+8>>2]=a;}F[e+4>>2]=h|3;c=e+h|0;a=d<<3;d=a-h|0;F[c+4>>2]=d|1;F[a+e>>2]=d;if(k){b=(k&-8)+11804|0;f=F[2946];a=1<<(k>>>3);l:{if(!(a&g)){F[2941]=a|g;a=b;break l}a=F[b+8>>2];}F[b+8>>2]=f;F[a+12>>2]=f;F[f+12>>2]=b;F[f+8>>2]=a;}a=e+8|0;F[2946]=c;F[2943]=d;break a}j=F[2942];if(!j){break i}c=F[(ji(0-j&j)<<2)+12068>>2];f=(F[c+4>>2]&-8)-h|0;b=c;while(1){m:{a=F[b+16>>2];if(!a){a=F[b+20>>2];if(!a){break m}}b=(F[a+4>>2]&-8)-h|0;d=b>>>0<f>>>0;f=d?b:f;c=d?a:c;b=a;continue}break}i=F[c+24>>2];d=F[c+12>>2];if((d|0)!=(c|0)){a=F[c+8>>2];F[a+12>>2]=d;F[d+8>>2]=a;break b}b=c+20|0;a=F[b>>2];if(!a){a=F[c+16>>2];if(!a){break h}b=c+16|0;}while(1){e=b;d=a;b=a+20|0;a=F[b>>2];if(a){continue}b=d+16|0;a=F[d+16>>2];if(a){continue}break}F[e>>2]=0;break b}h=-1;if(a>>>0>4294967231){break i}a=a+11|0;h=a&-8;j=F[2942];if(!j){break i}f=0-h|0;g=0;n:{if(h>>>0<256){break n}g=31;if(h>>>0>16777215){break n}a=O(a>>>8|0);g=((h>>>38-a&1)-(a<<1)|0)+62|0;}b=F[(g<<2)+12068>>2];o:{p:{q:{if(!b){a=0;break q}a=0;c=h<<((g|0)!=31?25-(g>>>1|0)|0:0);while(1){r:{e=(F[b+4>>2]&-8)-h|0;if(e>>>0>=f>>>0){break r}d=b;f=e;if(e){break r}f=0;a=b;break p}e=F[b+20>>2];b=F[((c>>>29&4)+b|0)+16>>2];a=e?(e|0)==(b|0)?a:e:a;c=c<<1;if(b){continue}break}}if(!(a|d)){d=0;a=2<<g;a=(0-a|a)&j;if(!a){break i}a=F[(ji(a&0-a)<<2)+12068>>2];}if(!a){break o}}while(1){b=(F[a+4>>2]&-8)-h|0;c=b>>>0<f>>>0;f=c?b:f;d=c?a:d;b=F[a+16>>2];if(b){a=b;}else {a=F[a+20>>2];}if(a){continue}break}}if(!d|F[2943]-h>>>0<=f>>>0){break i}g=F[d+24>>2];c=F[d+12>>2];if((d|0)!=(c|0)){a=F[d+8>>2];F[a+12>>2]=c;F[c+8>>2]=a;break c}b=d+20|0;a=F[b>>2];if(!a){a=F[d+16>>2];if(!a){break g}b=d+16|0;}while(1){e=b;c=a;b=a+20|0;a=F[b>>2];if(a){continue}b=c+16|0;a=F[c+16>>2];if(a){continue}break}F[e>>2]=0;break c}a=F[2943];if(a>>>0>=h>>>0){d=F[2946];b=a-h|0;s:{if(b>>>0>=16){c=d+h|0;F[c+4>>2]=b|1;F[a+d>>2]=b;F[d+4>>2]=h|3;break s}F[d+4>>2]=a|3;a=a+d|0;F[a+4>>2]=F[a+4>>2]|1;c=0;b=0;}F[2943]=b;F[2946]=c;a=d+8|0;break a}i=F[2944];if(i>>>0>h>>>0){b=i-h|0;F[2944]=b;c=F[2947];a=c+h|0;F[2947]=a;F[a+4>>2]=b|1;F[c+4>>2]=h|3;a=c+8|0;break a}a=0;j=h+47|0;if(F[3059]){c=F[3061];}else {F[3062]=-1;F[3063]=-1;F[3060]=4096;F[3061]=4096;F[3059]=l+12&-16^1431655768;F[3064]=0;F[3052]=0;c=4096;}e=j+c|0;f=0-c|0;b=e&f;if(b>>>0<=h>>>0){break a}d=F[3051];if(d){c=F[3049];g=c+b|0;if(d>>>0<g>>>0|c>>>0>=g>>>0){break a}}t:{if(!(G[12208]&4)){u:{v:{w:{x:{d=F[2947];if(d){a=12212;while(1){c=F[a>>2];if(c>>>0<=d>>>0&d>>>0<c+F[a+4>>2]>>>0){break x}a=F[a+8>>2];if(a){continue}break}}c=eb(0);if((c|0)==-1){break u}g=b;d=F[3060];a=d-1|0;if(a&c){g=(b-c|0)+(a+c&0-d)|0;}if(g>>>0<=h>>>0){break u}d=F[3051];if(d){a=F[3049];f=a+g|0;if(d>>>0<f>>>0|a>>>0>=f>>>0){break u}}a=eb(g);if((c|0)!=(a|0)){break w}break t}g=f&e-i;c=eb(g);if((c|0)==(F[a>>2]+F[a+4>>2]|0)){break v}a=c;}if((a|0)==-1){break u}if(h+48>>>0<=g>>>0){c=a;break t}c=F[3061];c=c+(j-g|0)&0-c;if((eb(c)|0)==-1){break u}g=c+g|0;c=a;break t}if((c|0)!=-1){break t}}F[3052]=F[3052]|4;}c=eb(b);a=eb(0);if((c|0)==-1|(a|0)==-1|a>>>0<=c>>>0){break d}g=a-c|0;if(g>>>0<=h+40>>>0){break d}}a=F[3049]+g|0;F[3049]=a;if(a>>>0>I[3050]){F[3050]=a;}y:{e=F[2947];if(e){a=12212;while(1){d=F[a>>2];b=F[a+4>>2];if((d+b|0)==(c|0)){break y}a=F[a+8>>2];if(a){continue}break}break f}a=F[2945];if(!(a>>>0<=c>>>0?a:0)){F[2945]=c;}a=0;F[3054]=g;F[3053]=c;F[2949]=-1;F[2950]=F[3059];F[3056]=0;while(1){d=a<<3;b=d+11804|0;F[d+11812>>2]=b;F[d+11816>>2]=b;a=a+1|0;if((a|0)!=32){continue}break}d=g-40|0;a=c+8&7?-8-c&7:0;b=d-a|0;F[2944]=b;a=a+c|0;F[2947]=a;F[a+4>>2]=b|1;F[(c+d|0)+4>>2]=40;F[2948]=F[3063];break e}if(G[a+12|0]&8|d>>>0>e>>>0|c>>>0<=e>>>0){break f}F[a+4>>2]=b+g;a=e+8&7?-8-e&7:0;c=a+e|0;F[2947]=c;b=F[2944]+g|0;a=b-a|0;F[2944]=a;F[c+4>>2]=a|1;F[(b+e|0)+4>>2]=40;F[2948]=F[3063];break e}d=0;break b}c=0;break c}if(I[2945]>c>>>0){F[2945]=c;}b=c+g|0;a=12212;z:{A:{B:{C:{D:{E:{while(1){if((b|0)!=F[a>>2]){a=F[a+8>>2];if(a){continue}break E}break}if(!(G[a+12|0]&8)){break D}}a=12212;while(1){b=F[a>>2];if(b>>>0<=e>>>0){f=b+F[a+4>>2]|0;if(f>>>0>e>>>0){break C}}a=F[a+8>>2];continue}}F[a>>2]=c;F[a+4>>2]=F[a+4>>2]+g;j=(c+8&7?-8-c&7:0)+c|0;F[j+4>>2]=h|3;g=b+(b+8&7?-8-b&7:0)|0;i=h+j|0;a=g-i|0;if((e|0)==(g|0)){F[2947]=i;a=F[2944]+a|0;F[2944]=a;F[i+4>>2]=a|1;break A}if(F[2946]==(g|0)){F[2946]=i;a=F[2943]+a|0;F[2943]=a;F[i+4>>2]=a|1;F[a+i>>2]=a;break A}f=F[g+4>>2];if((f&3)==1){e=f&-8;F:{if(f>>>0<=255){d=F[g+8>>2];b=f>>>3|0;c=F[g+12>>2];if((c|0)==(d|0)){m=11764,n=F[2941]&oi(b),F[m>>2]=n;break F}F[d+12>>2]=c;F[c+8>>2]=d;break F}h=F[g+24>>2];c=F[g+12>>2];G:{if((g|0)!=(c|0)){b=F[g+8>>2];F[b+12>>2]=c;F[c+8>>2]=b;break G}H:{f=g+20|0;b=F[f>>2];if(b){break H}f=g+16|0;b=F[f>>2];if(b){break H}c=0;break G}while(1){d=f;c=b;f=c+20|0;b=F[f>>2];if(b){continue}f=c+16|0;b=F[c+16>>2];if(b){continue}break}F[d>>2]=0;}if(!h){break F}d=F[g+28>>2];b=(d<<2)+12068|0;I:{if(F[b>>2]==(g|0)){F[b>>2]=c;if(c){break I}m=11768,n=F[2942]&oi(d),F[m>>2]=n;break F}F[h+(F[h+16>>2]==(g|0)?16:20)>>2]=c;if(!c){break F}}F[c+24>>2]=h;b=F[g+16>>2];if(b){F[c+16>>2]=b;F[b+24>>2]=c;}b=F[g+20>>2];if(!b){break F}F[c+20>>2]=b;F[b+24>>2]=c;}g=e+g|0;f=F[g+4>>2];a=a+e|0;}F[g+4>>2]=f&-2;F[i+4>>2]=a|1;F[a+i>>2]=a;if(a>>>0<=255){b=(a&-8)+11804|0;c=F[2941];a=1<<(a>>>3);J:{if(!(c&a)){F[2941]=a|c;a=b;break J}a=F[b+8>>2];}F[b+8>>2]=i;F[a+12>>2]=i;F[i+12>>2]=b;F[i+8>>2]=a;break A}f=31;if(a>>>0<=16777215){b=O(a>>>8|0);f=((a>>>38-b&1)-(b<<1)|0)+62|0;}F[i+28>>2]=f;F[i+16>>2]=0;F[i+20>>2]=0;b=(f<<2)+12068|0;d=F[2942];c=1<<f;K:{if(!(d&c)){F[2942]=c|d;F[b>>2]=i;break K}f=a<<((f|0)!=31?25-(f>>>1|0)|0:0);c=F[b>>2];while(1){b=c;if((F[c+4>>2]&-8)==(a|0)){break B}c=f>>>29|0;f=f<<1;d=(c&4)+b|0;c=F[d+16>>2];if(c){continue}break}F[d+16>>2]=i;}F[i+24>>2]=b;F[i+12>>2]=i;F[i+8>>2]=i;break A}d=g-40|0;a=c+8&7?-8-c&7:0;b=d-a|0;F[2944]=b;a=a+c|0;F[2947]=a;F[a+4>>2]=b|1;F[(c+d|0)+4>>2]=40;F[2948]=F[3063];a=(f+(f-39&7?39-f&7:0)|0)-47|0;d=a>>>0<e+16>>>0?e:a;F[d+4>>2]=27;a=F[3056];F[d+16>>2]=F[3055];F[d+20>>2]=a;a=F[3054];F[d+8>>2]=F[3053];F[d+12>>2]=a;F[3055]=d+8;F[3054]=g;F[3053]=c;F[3056]=0;a=d+24|0;while(1){F[a+4>>2]=7;b=a+8|0;a=a+4|0;if(b>>>0<f>>>0){continue}break}if((d|0)==(e|0)){break e}F[d+4>>2]=F[d+4>>2]&-2;f=d-e|0;F[e+4>>2]=f|1;F[d>>2]=f;if(f>>>0<=255){b=(f&-8)+11804|0;c=F[2941];a=1<<(f>>>3);L:{if(!(c&a)){F[2941]=a|c;a=b;break L}a=F[b+8>>2];}F[b+8>>2]=e;F[a+12>>2]=e;F[e+12>>2]=b;F[e+8>>2]=a;break e}a=31;if(f>>>0<=16777215){a=O(f>>>8|0);a=((f>>>38-a&1)-(a<<1)|0)+62|0;}F[e+28>>2]=a;F[e+16>>2]=0;F[e+20>>2]=0;b=(a<<2)+12068|0;d=F[2942];c=1<<a;M:{if(!(d&c)){F[2942]=c|d;F[b>>2]=e;break M}a=f<<((a|0)!=31?25-(a>>>1|0)|0:0);d=F[b>>2];while(1){b=d;if((f|0)==(F[b+4>>2]&-8)){break z}c=a>>>29|0;a=a<<1;c=(c&4)+b|0;d=F[c+16>>2];if(d){continue}break}F[c+16>>2]=e;}F[e+24>>2]=b;F[e+12>>2]=e;F[e+8>>2]=e;break e}a=F[b+8>>2];F[a+12>>2]=i;F[b+8>>2]=i;F[i+24>>2]=0;F[i+12>>2]=b;F[i+8>>2]=a;}a=j+8|0;break a}a=F[b+8>>2];F[a+12>>2]=e;F[b+8>>2]=e;F[e+24>>2]=0;F[e+12>>2]=b;F[e+8>>2]=a;}a=F[2944];if(a>>>0<=h>>>0){break d}b=a-h|0;F[2944]=b;c=F[2947];a=c+h|0;F[2947]=a;F[a+4>>2]=b|1;F[c+4>>2]=h|3;a=c+8|0;break a}F[2940]=48;a=0;break a}N:{if(!g){break N}b=F[d+28>>2];a=(b<<2)+12068|0;O:{if(F[a>>2]==(d|0)){F[a>>2]=c;if(c){break O}j=oi(b)&j;F[2942]=j;break N}F[g+(F[g+16>>2]==(d|0)?16:20)>>2]=c;if(!c){break N}}F[c+24>>2]=g;a=F[d+16>>2];if(a){F[c+16>>2]=a;F[a+24>>2]=c;}a=F[d+20>>2];if(!a){break N}F[c+20>>2]=a;F[a+24>>2]=c;}P:{if(f>>>0<=15){a=f+h|0;F[d+4>>2]=a|3;a=a+d|0;F[a+4>>2]=F[a+4>>2]|1;break P}F[d+4>>2]=h|3;e=d+h|0;F[e+4>>2]=f|1;F[e+f>>2]=f;if(f>>>0<=255){b=(f&-8)+11804|0;c=F[2941];a=1<<(f>>>3);Q:{if(!(c&a)){F[2941]=a|c;a=b;break Q}a=F[b+8>>2];}F[b+8>>2]=e;F[a+12>>2]=e;F[e+12>>2]=b;F[e+8>>2]=a;break P}a=31;if(f>>>0<=16777215){a=O(f>>>8|0);a=((f>>>38-a&1)-(a<<1)|0)+62|0;}F[e+28>>2]=a;F[e+16>>2]=0;F[e+20>>2]=0;b=(a<<2)+12068|0;R:{c=1<<a;S:{if(!(c&j)){F[2942]=c|j;F[b>>2]=e;break S}a=f<<((a|0)!=31?25-(a>>>1|0)|0:0);h=F[b>>2];while(1){b=h;if((F[b+4>>2]&-8)==(f|0)){break R}c=a>>>29|0;a=a<<1;c=(c&4)+b|0;h=F[c+16>>2];if(h){continue}break}F[c+16>>2]=e;}F[e+24>>2]=b;F[e+12>>2]=e;F[e+8>>2]=e;break P}a=F[b+8>>2];F[a+12>>2]=e;F[b+8>>2]=e;F[e+24>>2]=0;F[e+12>>2]=b;F[e+8>>2]=a;}a=d+8|0;break a}T:{if(!i){break T}b=F[c+28>>2];a=(b<<2)+12068|0;U:{if(F[a>>2]==(c|0)){F[a>>2]=d;if(d){break U}m=11768,n=oi(b)&j,F[m>>2]=n;break T}F[i+(F[i+16>>2]==(c|0)?16:20)>>2]=d;if(!d){break T}}F[d+24>>2]=i;a=F[c+16>>2];if(a){F[d+16>>2]=a;F[a+24>>2]=d;}a=F[c+20>>2];if(!a){break T}F[d+20>>2]=a;F[a+24>>2]=d;}V:{if(f>>>0<=15){a=f+h|0;F[c+4>>2]=a|3;a=a+c|0;F[a+4>>2]=F[a+4>>2]|1;break V}F[c+4>>2]=h|3;d=c+h|0;F[d+4>>2]=f|1;F[d+f>>2]=f;if(k){b=(k&-8)+11804|0;e=F[2946];a=1<<(k>>>3);W:{if(!(a&g)){F[2941]=a|g;a=b;break W}a=F[b+8>>2];}F[b+8>>2]=e;F[a+12>>2]=e;F[e+12>>2]=b;F[e+8>>2]=a;}F[2946]=d;F[2943]=f;}a=c+8|0;}Z=l+16|0;return a|0}function Vc(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0;m=Z-32|0;Z=m;o=ka(12);F[o+8>>2]=0;F[o+4>>2]=b;F[o>>2]=0;s=o+12|0;b=s;a:{b:{c:{while(1){b=b-12|0;w=F[b+8>>2];j=F[b+4>>2];t=F[b>>2];if(t){if((w|0)>1e3){break a}F[m+24>>2]=0;F[m+16>>2]=0;F[m+20>>2]=0;d=1;c=F[a>>2];e=F[c+8>>2];h=F[c+12>>2];g=F[c+20>>2];f=F[c+16>>2];d:{if((h|0)<=(g|0)&f>>>0>=e>>>0|(g|0)>(h|0)){break d}e=G[f+F[c>>2]|0];h=c;c=g;f=f+1|0;c=f?c:c+1|0;F[h+16>>2]=f;F[h+20>>2]=c;Sb(m+16|0,e);if(e){c=F[a>>2];n=Tb(m+16|0);p=F[c+8>>2];g=F[c+12>>2];h=F[c+20>>2];f=F[c+16>>2];k=f+e|0;h=k>>>0<e>>>0?h+1|0:h;if((g|0)<=(h|0)&k>>>0>p>>>0|(g|0)<(h|0)){break d}la(n,f+F[c>>2]|0,e);d=F[c+20>>2];f=e;e=e+F[c+16>>2]|0;d=f>>>0>e>>>0?d+1|0:d;F[c+16>>2]=e;F[c+20>>2]=d;}j=ka(24);c=j;F[c+4>>2]=0;F[c+8>>2]=0;c=c+16|0;F[c>>2]=0;F[c+4>>2]=0;F[j>>2]=j+4;F[j+12>>2]=c;e=Z-32|0;Z=e;h=t+12|0;c=m+16|0;u=Ya(h,c);i=t+16|0;e:{if((u|0)==(i|0)){F[e+16>>2]=c;f:{g:{d=F[h+4>>2];h:{if(!d){f=h+4|0;c=f;break h}f=G[c+11|0];g=f<<24>>24<0;n=g?F[c>>2]:c;g=g?F[c+4>>2]:f;while(1){c=d;d=G[c+27|0];f=d<<24>>24<0;d=f?F[c+20>>2]:d;p=d>>>0<g>>>0;i:{j:{k:{l:{k=p?d:g;m:{if(k){f=f?F[c+16>>2]:c+16|0;q=sa(n,f,k);if(!q){if(d>>>0>g>>>0){break m}break l}if((q|0)>=0){break l}break m}if(d>>>0<=g>>>0){break k}}f=c;d=F[c>>2];if(d){continue}break h}d=sa(f,n,k);if(d){break j}}if(p){break i}break g}if((d|0)>=0){break g}}d=F[c+4>>2];if(d){continue}break}f=c+4|0;}d=ka(32);n=d+16|0;g=F[e+16>>2];n:{if(D[g+11|0]>=0){p=F[g+4>>2];F[n>>2]=F[g>>2];F[n+4>>2]=p;F[n+8>>2]=F[g+8>>2];break n}ra(n,F[g>>2],F[g+4>>2]);}F[d+8>>2]=c;F[d>>2]=0;F[d+4>>2]=0;F[d+28>>2]=0;F[f>>2]=d;c=d;g=F[F[h>>2]>>2];if(g){F[h>>2]=g;c=F[f>>2];}nb(F[h+4>>2],c);F[h+8>>2]=F[h+8>>2]+1;c=1;break f}d=c;c=0;}D[e+28|0]=c;F[e+24>>2]=d;d=F[e+24>>2];c=F[d+28>>2];F[d+28>>2]=j;if(!c){break e}Ca(c+12|0,F[c+16>>2]);Ba(c,F[c+4>>2]);ja(c);break e}if(!j){break e}Ca(j+12|0,F[j+16>>2]);Ba(j,F[j+4>>2]);ja(j);}Z=e+32|0;d=(i|0)!=(u|0);}if(D[m+27|0]<0){ja(F[m+16>>2]);}if(d){break a}}if(!j){break a}F[m+16>>2]=0;if(!fb(1,m+16|0,F[a>>2])){break a}q=0;x=F[m+16>>2];if(x){while(1){d=0;i=Z-32|0;Z=i;F[i+24>>2]=0;F[i+16>>2]=0;F[i+20>>2]=0;c=F[a>>2];f=F[c+8>>2];o:{p:{h=F[c+12>>2];g=F[c+20>>2];e=F[c+16>>2];q:{if((h|0)<=(g|0)&e>>>0>=f>>>0|(g|0)>(h|0)){break q}f=G[e+F[c>>2]|0];h=c;c=g;e=e+1|0;c=e?c:c+1|0;F[h+16>>2]=e;F[h+20>>2]=c;Sb(i+16|0,f);if(f){e=F[a>>2];n=Tb(i+16|0);p=F[e+8>>2];g=F[e+12>>2];c=F[e+20>>2];h=F[e+16>>2];k=h+f|0;c=k>>>0<f>>>0?c+1|0:c;if(k>>>0>p>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break q}la(n,h+F[e>>2]|0,f);c=F[e+20>>2];g=f;f=f+F[e+16>>2]|0;c=g>>>0>f>>>0?c+1|0:c;F[e+16>>2]=f;F[e+20>>2]=c;}F[i+12>>2]=0;if(!fb(1,i+12|0,F[a>>2])){break q}f=F[i+12>>2];if(!f){break q}e=F[a>>2];c=F[e+8>>2];h=F[e+16>>2];g=c-h|0;c=F[e+12>>2]-(F[e+20>>2]+(c>>>0<h>>>0)|0)|0;if((c|0)<=0&f>>>0>g>>>0|(c|0)<0){break q}F[i+8>>2]=0;F[i>>2]=0;F[i+4>>2]=0;if((f|0)<0){break p}d=ka(f);F[i>>2]=d;c=d+f|0;F[i+8>>2]=c;l=ma(d,0,f);F[i+4>>2]=c;h=F[e+12>>2];y=h;p=F[e+8>>2];c=F[e+20>>2];k=F[e+16>>2];g=f+k|0;c=g>>>0<f>>>0?c+1|0:c;u=g;n=c;r:{if((c|0)<=(h|0)&g>>>0<=p>>>0|(c|0)<(h|0)){la(l,F[e>>2]+k|0,f);d=F[e+20>>2];c=f+F[e+16>>2]|0;d=c>>>0<f>>>0?d+1|0:d;F[e+16>>2]=c;F[e+20>>2]=d;h=Z-48|0;Z=h;e=Ya(j,i+16|0);if((e|0)!=(j+4|0)){c=F[e+4>>2];s:{if(!c){c=e;while(1){d=F[c+8>>2];f=F[d>>2]!=(c|0);c=d;if(f){continue}break}break s}while(1){d=c;c=F[c>>2];if(c){continue}break}}if((e|0)==F[j>>2]){F[j>>2]=d;}F[j+8>>2]=F[j+8>>2]-1;f=F[j+4>>2];t:{u:{g=e;d=e;e=F[d>>2];if(e){c=F[g+4>>2];if(!c){break u}while(1){d=c;c=F[c>>2];if(c){continue}break}}e=F[d+4>>2];if(e){break u}e=0;k=1;break t}F[e+8>>2]=F[d+8>>2];k=0;}l=F[d+8>>2];c=F[l>>2];v:{if((d|0)==(c|0)){F[l>>2]=e;if((d|0)==(f|0)){c=0;f=e;break v}c=F[l+4>>2];break v}F[l+4>>2]=e;}r=!G[d+12|0];if((d|0)!=(g|0)){l=F[g+8>>2];F[d+8>>2]=l;F[l+(((g|0)!=F[F[g+8>>2]>>2])<<2)>>2]=d;l=F[g>>2];F[d>>2]=l;F[l+8>>2]=d;l=F[g+4>>2];F[d+4>>2]=l;if(l){F[l+8>>2]=d;}D[d+12|0]=G[g+12|0];f=(f|0)==(g|0)?d:f;}w:{if(r|!f){break w}if(k){while(1){e=G[c+12|0];x:{d=F[c+8>>2];if(F[d>>2]!=(c|0)){if(!e){D[c+12|0]=1;D[d+12|0]=0;e=F[d+4>>2];k=F[e>>2];F[d+4>>2]=k;if(k){F[k+8>>2]=d;}F[e+8>>2]=F[d+8>>2];k=F[d+8>>2];F[(((d|0)!=F[k>>2])<<2)+k>>2]=e;F[e>>2]=d;F[d+8>>2]=e;d=c;c=F[c>>2];f=(c|0)==(f|0)?d:f;c=F[c+4>>2];}y:{z:{d=F[c>>2];A:{if(!(G[d+12|0]?0:d)){e=F[c+4>>2];if(G[e+12|0]?0:e){break A}D[c+12|0]=0;c=F[c+8>>2];B:{if((f|0)==(c|0)){c=f;break B}if(G[c+12|0]){break x}}D[c+12|0]=1;break w}e=F[c+4>>2];if(!e){break z}}if(G[e+12|0]){break z}d=c;break y}D[d+12|0]=1;D[c+12|0]=0;e=F[d+4>>2];F[c>>2]=e;if(e){F[e+8>>2]=c;}F[d+8>>2]=F[c+8>>2];e=F[c+8>>2];F[((F[e>>2]!=(c|0))<<2)+e>>2]=d;F[d+4>>2]=c;F[c+8>>2]=d;e=c;}c=F[d+8>>2];D[d+12|0]=G[c+12|0];D[c+12|0]=1;D[e+12|0]=1;d=F[c+4>>2];e=F[d>>2];F[c+4>>2]=e;if(e){F[e+8>>2]=c;}F[d+8>>2]=F[c+8>>2];e=F[c+8>>2];F[(((c|0)!=F[e>>2])<<2)+e>>2]=d;F[d>>2]=c;F[c+8>>2]=d;break w}if(!e){D[c+12|0]=1;D[d+12|0]=0;e=F[c+4>>2];F[d>>2]=e;if(e){F[e+8>>2]=d;}F[c+8>>2]=F[d+8>>2];e=F[d+8>>2];F[(((d|0)!=F[e>>2])<<2)+e>>2]=c;F[c+4>>2]=d;F[d+8>>2]=c;f=(d|0)==(f|0)?c:f;c=F[d>>2];}e=F[c>>2];C:{if(!(!e|G[e+12|0])){d=c;break C}d=F[c+4>>2];if(!(G[d+12|0]?0:d)){D[c+12|0]=0;c=F[c+8>>2];if((c|0)!=(f|0)?G[c+12|0]:0){break x}D[c+12|0]=1;break w}if(e){if(!G[e+12|0]){d=c;break C}d=F[c+4>>2];}D[d+12|0]=1;D[c+12|0]=0;e=F[d>>2];F[c+4>>2]=e;if(e){F[e+8>>2]=c;}F[d+8>>2]=F[c+8>>2];e=F[c+8>>2];F[((F[e>>2]!=(c|0))<<2)+e>>2]=d;F[d>>2]=c;F[c+8>>2]=d;e=c;}c=F[d+8>>2];D[d+12|0]=G[c+12|0];D[c+12|0]=1;D[e+12|0]=1;d=F[c>>2];e=F[d+4>>2];F[c>>2]=e;if(e){F[e+8>>2]=c;}F[d+8>>2]=F[c+8>>2];e=F[c+8>>2];F[(((c|0)!=F[e>>2])<<2)+e>>2]=d;F[d+4>>2]=c;F[c+8>>2]=d;break w}d=c;c=F[c+8>>2];c=F[(((d|0)==F[c>>2])<<2)+c>>2];continue}}D[e+12|0]=1;}c=F[g+28>>2];if(c){F[g+32>>2]=c;ja(c);}if(D[g+27|0]<0){ja(F[g+16>>2]);}ja(g);}F[h+8>>2]=0;F[h>>2]=0;F[h+4>>2]=0;c=F[i+4>>2];d=F[i>>2];f=c-d|0;e=0;D:{E:{if((c|0)!=(d|0)){if((f|0)<0){break E}e=ka(f);c=ma(e,0,f);g=c+f|0;F[h+8>>2]=g;F[h+4>>2]=g;F[h>>2]=c;c=d;}la(e,c,f);F:{if(D[i+27|0]>=0){F[h+24>>2]=F[i+24>>2];c=F[i+20>>2];F[h+16>>2]=F[i+16>>2];F[h+20>>2]=c;break F}ra(h+16|0,F[i+16>>2],F[i+20>>2]);}Tc(h+28|0,h);f=h+16|0;c=f;G:{H:{d=F[j+4>>2];I:{if(!d){e=j+4|0;c=e;break I}e=G[c+11|0];g=e<<24>>24<0;k=g?F[c>>2]:c;g=g?F[c+4>>2]:e;while(1){c=d;d=G[c+27|0];e=d<<24>>24<0;d=e?F[c+20>>2]:d;l=d>>>0<g>>>0;J:{K:{L:{M:{r=l?d:g;N:{if(r){e=e?F[c+16>>2]:c+16|0;z=sa(k,e,r);if(!z){if(d>>>0>g>>>0){break N}break M}if((z|0)>=0){break M}break N}if(d>>>0<=g>>>0){break L}}e=c;d=F[c>>2];if(d){continue}break I}d=sa(e,k,r);if(d){break K}}if(l){break J}break H}if((d|0)>=0){break H}}d=F[c+4>>2];if(d){continue}break}e=c+4|0;}d=ka(40);F[d+24>>2]=F[f+8>>2];g=F[f+4>>2];F[d+16>>2]=F[f>>2];F[d+20>>2]=g;F[f>>2]=0;F[f+4>>2]=0;F[f+8>>2]=0;Tc(d+28|0,f+12|0);F[d+8>>2]=c;F[d>>2]=0;F[d+4>>2]=0;F[e>>2]=d;c=d;f=F[F[j>>2]>>2];if(f){F[j>>2]=f;c=F[e>>2];}nb(F[j+4>>2],c);F[j+8>>2]=F[j+8>>2]+1;c=1;break G}d=c;c=0;}D[h+44|0]=c;F[h+40>>2]=d;c=F[h+28>>2];if(c){F[h+32>>2]=c;ja(c);}if(D[h+27|0]<0){ja(F[h+16>>2]);}c=F[h>>2];if(c){F[h+4>>2]=c;ja(c);}Z=h+48|0;break D}na();v();}d=F[i>>2];if(!d){break r}}F[i+4>>2]=d;ja(d);}d=(n|0)<=(y|0)&p>>>0>=u>>>0|(n|0)<(y|0);}if(D[i+27|0]<0){ja(F[i+16>>2]);}Z=i+32|0;break o}na();v();}if(!d){break a}q=q+1|0;if((x|0)!=(q|0)){continue}break}}F[m+12>>2]=0;if(!fb(1,m+12|0,F[a>>2])){break a}c=F[a>>2];e=F[c+8>>2];f=F[c+16>>2];h=e-f|0;d=F[m+12>>2];c=F[c+12>>2]-(F[c+20>>2]+(e>>>0<f>>>0)|0)|0;if(h>>>0<d>>>0&(c|0)<=0|(c|0)<0){break a}if(d){q=0;h=((t|0)!=0)+w|0;while(1){O:{if(b>>>0<s>>>0){F[b+8>>2]=h;F[b+4>>2]=0;F[b>>2]=j;b=b+12|0;d=F[m+12>>2];break O}c=b-o|0;g=(c|0)/12|0;b=g+1|0;if(b>>>0>=357913942){break c}e=(s-o|0)/12|0;f=e<<1;e=e>>>0>=178956970?357913941:b>>>0<f>>>0?f:b;if(e){if(e>>>0>=357913942){break b}f=ka(L(e,12));}else {f=0;}b=f+L(g,12)|0;F[b+8>>2]=h;F[b+4>>2]=0;F[b>>2]=j;c=pa(b+L((c|0)/-12|0,12)|0,o,c);s=f+L(e,12)|0;b=b+12|0;if(o){ja(o);}o=c;}q=q+1|0;if(q>>>0<d>>>0){continue}break}}if((b|0)!=(o|0)){continue}break}A=1;break a}na();v();}oa();v();}if(o){ja(o);}Z=m+32|0;return A}function me(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;h=Z-48|0;Z=h;a:{if((c|0)!=1){break a}i=F[a+4>>2];c=F[a+12>>2];F[h+40>>2]=0;F[h+32>>2]=0;F[h+36>>2]=0;F[h+24>>2]=0;F[h+28>>2]=0;F[h+16>>2]=0;F[h+20>>2]=0;F[h+8>>2]=0;F[h+12>>2]=0;d=h+8|0;b:{if((b|0)==-2){break b}k=F[F[F[i+4>>2]+8>>2]+(c<<2)>>2];if(($[F[F[i>>2]+8>>2]](i)|0)==1){j=Z-32|0;Z=j;l=F[F[F[i+4>>2]+8>>2]+(c<<2)>>2];c:{d:{e:{if(($[F[F[i>>2]+8>>2]](i)|0)!=1|b-1>>>0>5){break e}g=$[F[F[i>>2]+36>>2]](i)|0;f=$[F[F[i>>2]+44>>2]](i,c)|0;if(!g|!f){break e}c=$[F[F[i>>2]+40>>2]](i,c)|0;if(c){a=F[i+44>>2];F[j+12>>2]=c;F[j+8>>2]=a;F[j+20>>2]=f;F[j+16>>2]=f+12;f=j+8|0;a=0;f:{g:{switch(b-1|0){case 0:b=ka(60);F[b+4>>2]=l;F[b>>2]=2960;a=F[d+4>>2];F[b+8>>2]=F[d>>2];F[b+12>>2]=a;a=F[d+12>>2];F[b+16>>2]=F[d+8>>2];F[b+20>>2]=a;a=F[d+20>>2];F[b+24>>2]=F[d+16>>2];F[b+28>>2]=a;F[b+40>>2]=0;F[b+32>>2]=0;F[b+36>>2]=0;a=F[d+24>>2];g=F[d+28>>2];if((a|0)!=(g|0)){c=g-a|0;if((c|0)<0){break d}e=ka(c);F[b+32>>2]=e;F[b+40>>2]=(c&-4)+e;while(1){F[e>>2]=F[a>>2];e=e+4|0;a=a+4|0;if((g|0)!=(a|0)){continue}break}F[b+36>>2]=e;}a=F[f+4>>2];F[b+44>>2]=F[f>>2];F[b+48>>2]=a;a=F[f+12>>2];F[b+52>>2]=F[f+8>>2];F[b+56>>2]=a;F[b>>2]=2252;a=b;break f;case 3:b=ka(112);F[b+4>>2]=l;F[b>>2]=2960;a=F[d+4>>2];F[b+8>>2]=F[d>>2];F[b+12>>2]=a;a=F[d+12>>2];F[b+16>>2]=F[d+8>>2];F[b+20>>2]=a;a=F[d+20>>2];F[b+24>>2]=F[d+16>>2];F[b+28>>2]=a;F[b+40>>2]=0;F[b+32>>2]=0;F[b+36>>2]=0;a=F[d+24>>2];g=F[d+28>>2];if((a|0)!=(g|0)){c=g-a|0;if((c|0)<0){break d}e=ka(c);F[b+32>>2]=e;F[b+40>>2]=(c&-4)+e;while(1){F[e>>2]=F[a>>2];e=e+4|0;a=a+4|0;if((g|0)!=(a|0)){continue}break}F[b+36>>2]=e;}a=F[f+4>>2];F[b+44>>2]=F[f>>2];F[b+48>>2]=a;a=F[f+12>>2];F[b+52>>2]=F[f+8>>2];F[b+56>>2]=a;F[b+60>>2]=0;F[b+64>>2]=0;F[b>>2]=3016;F[b+68>>2]=0;F[b+72>>2]=0;F[b+76>>2]=0;F[b+80>>2]=0;F[b+84>>2]=0;F[b+88>>2]=0;F[b+92>>2]=0;F[b+96>>2]=0;F[b+100>>2]=0;F[b+104>>2]=0;F[b+108>>2]=0;a=b;break f;case 4:b=ka(104);F[b+4>>2]=l;F[b>>2]=2960;a=F[d+4>>2];F[b+8>>2]=F[d>>2];F[b+12>>2]=a;a=F[d+12>>2];F[b+16>>2]=F[d+8>>2];F[b+20>>2]=a;a=F[d+20>>2];F[b+24>>2]=F[d+16>>2];F[b+28>>2]=a;F[b+40>>2]=0;F[b+32>>2]=0;F[b+36>>2]=0;a=F[d+24>>2];g=F[d+28>>2];if((a|0)!=(g|0)){c=g-a|0;if((c|0)<0){break d}e=ka(c);F[b+32>>2]=e;F[b+40>>2]=(c&-4)+e;while(1){F[e>>2]=F[a>>2];e=e+4|0;a=a+4|0;if((g|0)!=(a|0)){continue}break}F[b+36>>2]=e;}a=F[f+4>>2];F[b+44>>2]=F[f>>2];F[b+48>>2]=a;a=F[f+12>>2];F[b+52>>2]=F[f+8>>2];F[b+56>>2]=a;F[b+84>>2]=0;F[b+76>>2]=0;F[b+80>>2]=0;F[b+60>>2]=0;F[b+64>>2]=0;F[b>>2]=3264;a=F[f+4>>2];F[b+88>>2]=F[f>>2];F[b+92>>2]=a;a=F[f+12>>2];F[b+96>>2]=F[f+8>>2];F[b+100>>2]=a;a=b;break f;case 5:break g;default:break f}}a=ka(128);F[a+4>>2]=l;F[a>>2]=2960;b=F[d+4>>2];F[a+8>>2]=F[d>>2];F[a+12>>2]=b;b=F[d+12>>2];F[a+16>>2]=F[d+8>>2];F[a+20>>2]=b;b=F[d+20>>2];F[a+24>>2]=F[d+16>>2];F[a+28>>2]=b;F[a+40>>2]=0;F[a+32>>2]=0;F[a+36>>2]=0;h:{i:{c=F[d+28>>2];b=F[d+24>>2];if((c|0)!=(b|0)){c=c-b|0;if((c|0)<0){break i}b=ka(c);F[a+36>>2]=b;F[a+32>>2]=b;F[a+40>>2]=(c&-4)+b;e=F[d+24>>2];c=F[d+28>>2];if((e|0)!=(c|0)){while(1){F[b>>2]=F[e>>2];b=b+4|0;e=e+4|0;if((c|0)!=(e|0)){continue}break}}F[a+36>>2]=b;}F[a>>2]=2904;b=F[f+4>>2];F[a+44>>2]=F[f>>2];F[a+48>>2]=b;b=F[f+12>>2];F[a+52>>2]=F[f+8>>2];F[a+56>>2]=b;b=a- -64|0;F[b>>2]=0;F[b+4>>2]=0;F[a+60>>2]=4128;F[a>>2]=3500;b=F[f+4>>2];F[a+72>>2]=F[f>>2];F[a+76>>2]=b;b=F[f+12>>2];F[a+80>>2]=F[f+8>>2];F[a+84>>2]=b;F[a+104>>2]=1065353216;F[a+108>>2]=-1;F[a+96>>2]=-1;F[a+100>>2]=-1;F[a+88>>2]=1;F[a+92>>2]=-1;F[a+60>>2]=3736;F[a+112>>2]=0;F[a+116>>2]=0;D[a+117|0]=0;D[a+118|0]=0;D[a+119|0]=0;D[a+120|0]=0;D[a+121|0]=0;D[a+122|0]=0;D[a+123|0]=0;D[a+124|0]=0;break h}na();v();}break f}e=a;break e}a=F[i+44>>2];F[j+12>>2]=g;F[j+8>>2]=a;F[j+20>>2]=f;F[j+16>>2]=f+12;f=j+8|0;a=0;j:{k:{switch(b-1|0){case 0:b=ka(60);F[b+4>>2]=l;F[b>>2]=2960;a=F[d+4>>2];F[b+8>>2]=F[d>>2];F[b+12>>2]=a;a=F[d+12>>2];F[b+16>>2]=F[d+8>>2];F[b+20>>2]=a;a=F[d+20>>2];F[b+24>>2]=F[d+16>>2];F[b+28>>2]=a;F[b+40>>2]=0;F[b+32>>2]=0;F[b+36>>2]=0;a=F[d+24>>2];g=F[d+28>>2];if((a|0)!=(g|0)){c=g-a|0;if((c|0)<0){break d}e=ka(c);F[b+32>>2]=e;F[b+40>>2]=(c&-4)+e;while(1){F[e>>2]=F[a>>2];e=e+4|0;a=a+4|0;if((g|0)!=(a|0)){continue}break}F[b+36>>2]=e;}a=F[f+4>>2];F[b+44>>2]=F[f>>2];F[b+48>>2]=a;a=F[f+12>>2];F[b+52>>2]=F[f+8>>2];F[b+56>>2]=a;F[b>>2]=4156;a=b;break j;case 3:b=ka(112);F[b+4>>2]=l;F[b>>2]=2960;a=F[d+4>>2];F[b+8>>2]=F[d>>2];F[b+12>>2]=a;a=F[d+12>>2];F[b+16>>2]=F[d+8>>2];F[b+20>>2]=a;a=F[d+20>>2];F[b+24>>2]=F[d+16>>2];F[b+28>>2]=a;F[b+40>>2]=0;F[b+32>>2]=0;F[b+36>>2]=0;a=F[d+24>>2];g=F[d+28>>2];if((a|0)!=(g|0)){c=g-a|0;if((c|0)<0){break d}e=ka(c);F[b+32>>2]=e;F[b+40>>2]=(c&-4)+e;while(1){F[e>>2]=F[a>>2];e=e+4|0;a=a+4|0;if((g|0)!=(a|0)){continue}break}F[b+36>>2]=e;}a=F[f+4>>2];F[b+44>>2]=F[f>>2];F[b+48>>2]=a;a=F[f+12>>2];F[b+52>>2]=F[f+8>>2];F[b+56>>2]=a;F[b+60>>2]=0;F[b+64>>2]=0;F[b>>2]=4580;F[b+68>>2]=0;F[b+72>>2]=0;F[b+76>>2]=0;F[b+80>>2]=0;F[b+84>>2]=0;F[b+88>>2]=0;F[b+92>>2]=0;F[b+96>>2]=0;F[b+100>>2]=0;F[b+104>>2]=0;F[b+108>>2]=0;a=b;break j;case 4:b=ka(104);F[b+4>>2]=l;F[b>>2]=2960;a=F[d+4>>2];F[b+8>>2]=F[d>>2];F[b+12>>2]=a;a=F[d+12>>2];F[b+16>>2]=F[d+8>>2];F[b+20>>2]=a;a=F[d+20>>2];F[b+24>>2]=F[d+16>>2];F[b+28>>2]=a;F[b+40>>2]=0;F[b+32>>2]=0;F[b+36>>2]=0;a=F[d+24>>2];g=F[d+28>>2];if((a|0)!=(g|0)){c=g-a|0;if((c|0)<0){break d}e=ka(c);F[b+32>>2]=e;F[b+40>>2]=(c&-4)+e;while(1){F[e>>2]=F[a>>2];e=e+4|0;a=a+4|0;if((g|0)!=(a|0)){continue}break}F[b+36>>2]=e;}a=F[f+4>>2];F[b+44>>2]=F[f>>2];F[b+48>>2]=a;a=F[f+12>>2];F[b+52>>2]=F[f+8>>2];F[b+56>>2]=a;F[b+84>>2]=0;F[b+76>>2]=0;F[b+80>>2]=0;F[b+60>>2]=0;F[b+64>>2]=0;F[b>>2]=4816;a=F[f+4>>2];F[b+88>>2]=F[f>>2];F[b+92>>2]=a;a=F[f+12>>2];F[b+96>>2]=F[f+8>>2];F[b+100>>2]=a;a=b;break j;case 5:break k;default:break j}}a=ka(128);F[a+4>>2]=l;F[a>>2]=2960;b=F[d+4>>2];F[a+8>>2]=F[d>>2];F[a+12>>2]=b;b=F[d+12>>2];F[a+16>>2]=F[d+8>>2];F[a+20>>2]=b;b=F[d+20>>2];F[a+24>>2]=F[d+16>>2];F[a+28>>2]=b;F[a+40>>2]=0;F[a+32>>2]=0;F[a+36>>2]=0;l:{m:{c=F[d+28>>2];b=F[d+24>>2];if((c|0)!=(b|0)){c=c-b|0;if((c|0)<0){break m}b=ka(c);F[a+36>>2]=b;F[a+32>>2]=b;F[a+40>>2]=(c&-4)+b;e=F[d+24>>2];c=F[d+28>>2];if((e|0)!=(c|0)){while(1){F[b>>2]=F[e>>2];b=b+4|0;e=e+4|0;if((c|0)!=(e|0)){continue}break}}F[a+36>>2]=b;}F[a>>2]=4524;b=F[f+4>>2];F[a+44>>2]=F[f>>2];F[a+48>>2]=b;b=F[f+12>>2];F[a+52>>2]=F[f+8>>2];F[a+56>>2]=b;b=a- -64|0;F[b>>2]=0;F[b+4>>2]=0;F[a+60>>2]=5624;F[a>>2]=5040;b=F[f+4>>2];F[a+72>>2]=F[f>>2];F[a+76>>2]=b;b=F[f+12>>2];F[a+80>>2]=F[f+8>>2];F[a+84>>2]=b;F[a+104>>2]=1065353216;F[a+108>>2]=-1;F[a+96>>2]=-1;F[a+100>>2]=-1;F[a+88>>2]=1;F[a+92>>2]=-1;F[a+60>>2]=5260;F[a+112>>2]=0;F[a+116>>2]=0;D[a+117|0]=0;D[a+118|0]=0;D[a+119|0]=0;D[a+120|0]=0;D[a+121|0]=0;D[a+122|0]=0;D[a+123|0]=0;D[a+124|0]=0;break l}na();v();}break j}e=a;}Z=j+32|0;break c}na();v();}if(e){break b}}e=ka(44);F[e+4>>2]=k;F[e>>2]=2960;a=F[d+4>>2];F[e+8>>2]=F[d>>2];F[e+12>>2]=a;a=F[d+12>>2];F[e+16>>2]=F[d+8>>2];F[e+20>>2]=a;a=F[d+20>>2];F[e+24>>2]=F[d+16>>2];F[e+28>>2]=a;F[e+40>>2]=0;F[e+32>>2]=0;F[e+36>>2]=0;n:{c=F[d+24>>2];b=F[d+28>>2];if((c|0)!=(b|0)){a=b-c|0;if((a|0)<0){break n}k=ka(a);F[e+32>>2]=k;F[e+40>>2]=(a&-4)+k;while(1){F[k>>2]=F[c>>2];k=k+4|0;c=c+4|0;if((b|0)!=(c|0)){continue}break}F[e+36>>2]=k;}F[e>>2]=5652;break b}na();v();}k=e;a=F[h+32>>2];if(!a){break a}F[h+36>>2]=a;ja(a);}Z=h+48|0;return k|0}function rf(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0;m=Z-16|0;Z=m;F[m+12>>2]=b;b=ka(32);F[m>>2]=b;F[m+4>>2]=24;F[m+8>>2]=-2147483616;c=G[1196]|G[1197]<<8|(G[1198]<<16|G[1199]<<24);d=G[1192]|G[1193]<<8|(G[1194]<<16|G[1195]<<24);D[b+16|0]=d;D[b+17|0]=d>>>8;D[b+18|0]=d>>>16;D[b+19|0]=d>>>24;D[b+20|0]=c;D[b+21|0]=c>>>8;D[b+22|0]=c>>>16;D[b+23|0]=c>>>24;c=G[1188]|G[1189]<<8|(G[1190]<<16|G[1191]<<24);d=G[1184]|G[1185]<<8|(G[1186]<<16|G[1187]<<24);D[b+8|0]=d;D[b+9|0]=d>>>8;D[b+10|0]=d>>>16;D[b+11|0]=d>>>24;D[b+12|0]=c;D[b+13|0]=c>>>8;D[b+14|0]=c>>>16;D[b+15|0]=c>>>24;c=G[1180]|G[1181]<<8|(G[1182]<<16|G[1183]<<24);d=G[1176]|G[1177]<<8|(G[1178]<<16|G[1179]<<24);D[b|0]=d;D[b+1|0]=d>>>8;D[b+2|0]=d>>>16;D[b+3|0]=d>>>24;D[b+4|0]=c;D[b+5|0]=c>>>8;D[b+6|0]=c>>>16;D[b+7|0]=c>>>24;D[b+24|0]=0;l=Z-48|0;Z=l;f=F[m+12>>2];d=a;a=a+16|0;b=F[a>>2];a:{b:{if(!b){break b}c=a;while(1){e=(f|0)>F[b+16>>2];c=e?c:b;b=F[(e?b+4|0:b)>>2];if(b){continue}break}if((a|0)==(c|0)){break b}if((f|0)>=F[c+16>>2]){break a}}F[l+28>>2]=0;F[l+32>>2]=0;y=l+24|0;F[l+24>>2]=y|4;a=l+16|0;F[a>>2]=0;F[a+4>>2]=0;F[l+8>>2]=f;F[l+12>>2]=a;t=l+8|0;a=t;x=Z-16|0;Z=x;u=d+12|0;c=F[u+4>>2];c:{d:{if(!c){o=u+4|0;d=o;break d}a=F[a>>2];while(1){d=c;b=F[c+16>>2];if((b|0)>(a|0)){o=d;c=F[d>>2];if(c){continue}break d}if((a|0)<=(b|0)){g=d;a=0;break c}c=F[d+4>>2];if(c){continue}break}o=d+4|0;}g=ka(32);b=F[t>>2];q=g+24|0;a=q;F[a>>2]=0;F[a+4>>2]=0;F[g+16>>2]=b;r=g+20|0;F[r>>2]=a;c=F[t+4>>2];z=t+8|0;if((c|0)!=(z|0)){while(1){p=Z-16|0;Z=p;a=p+8|0;k=c+16|0;e:{f:{g:{h:{i:{j:{k:{f=q;e=r+4|0;l:{if((f|0)==(e|0)){break l}b=G[f+27|0];h=b<<24>>24<0;i=G[k+11|0];n=i<<24>>24;j=(n|0)<0;i=j?F[k+4>>2]:i;b=h?F[f+20>>2]:b;s=i>>>0>b>>>0;w=s?b:i;if(w){j=j?F[k>>2]:k;h=h?F[f+16>>2]:f+16|0;A=sa(j,h,w);if(!A){if(b>>>0>i>>>0){break l}break k}if((A|0)>=0){break k}break l}if(b>>>0<=i>>>0){break j}}h=F[f>>2];m:{a=f;n:{if((a|0)==F[r>>2]){break n}o:{if(!h){b=f;while(1){a=F[b+8>>2];i=F[a>>2]==(b|0);b=a;if(i){continue}break}break o}b=h;while(1){a=b;b=F[b+4>>2];if(b){continue}break}}i=G[k+11|0];s=i<<24>>24;b=(s|0)<0;j=G[a+27|0];n=j<<24>>24<0;p:{i=b?F[k+4>>2]:i;j=n?F[a+20>>2]:j;w=i>>>0<j>>>0?i:j;if(w){b=sa(n?F[a+16>>2]:a+16|0,b?F[k>>2]:k,w);if(b){break p}}if(i>>>0>j>>>0){break n}break m}if((b|0)>=0){break m}}if(!h){F[p+12>>2]=f;a=f;break e}F[p+12>>2]=a;a=a+4|0;break e}b=F[e>>2];if(!b){F[p+12>>2]=e;a=e;break e}h=(s|0)<0?F[k>>2]:k;f=e;while(1){a=b;b=G[b+27|0];e=b<<24>>24<0;b=e?F[a+20>>2]:b;k=b>>>0<i>>>0;q:{r:{s:{t:{n=k?b:i;u:{if(n){e=e?F[a+16>>2]:a+16|0;j=sa(h,e,n);if(!j){if(b>>>0>i>>>0){break u}break t}if((j|0)>=0){break t}break u}if(b>>>0<=i>>>0){break s}}f=a;b=F[a>>2];if(b){continue}break g}b=sa(e,h,n);if(b){break r}}if(k){break q}break g}if((b|0)>=0){break g}}f=a+4|0;b=F[a+4>>2];if(b){continue}break}break g}b=sa(h,j,w);if(b){break i}}if(s){break h}break f}if((b|0)>=0){break f}}h=F[f+4>>2];v:{if(!h){b=f;while(1){a=F[b+8>>2];j=F[a>>2]!=(b|0);b=a;if(j){continue}break}break v}b=h;while(1){a=b;b=F[b>>2];if(b){continue}break}}w:{x:{if((a|0)==(e|0)){break x}j=G[a+27|0];b=j<<24>>24<0;y:{j=b?F[a+20>>2]:j;s=i>>>0>j>>>0?j:i;if(s){b=sa((n|0)<0?F[k>>2]:k,b?F[a+16>>2]:a+16|0,s);if(b){break y}}if(i>>>0<j>>>0){break x}break w}if((b|0)>=0){break w}}if(!h){F[p+12>>2]=f;a=f+4|0;break e}F[p+12>>2]=a;break e}b=F[e>>2];if(!b){F[p+12>>2]=e;a=e;break e}h=(n|0)<0?F[k>>2]:k;f=e;while(1){a=b;b=G[b+27|0];e=b<<24>>24<0;b=e?F[a+20>>2]:b;k=b>>>0<i>>>0;z:{A:{B:{C:{n=k?b:i;D:{if(n){e=e?F[a+16>>2]:a+16|0;j=sa(h,e,n);if(!j){if(b>>>0>i>>>0){break D}break C}if((j|0)>=0){break C}break D}if(b>>>0<=i>>>0){break B}}f=a;b=F[a>>2];if(b){continue}break g}b=sa(e,h,n);if(b){break A}}if(k){break z}break g}if((b|0)>=0){break g}}f=a+4|0;b=F[a+4>>2];if(b){continue}break}}F[p+12>>2]=a;a=f;break e}F[p+12>>2]=f;F[a>>2]=f;}f=a;a=F[a>>2];if(a){b=0;}else {a=ka(40);b=a+16|0;E:{if(D[c+27|0]>=0){e=F[c+20>>2];F[b>>2]=F[c+16>>2];F[b+4>>2]=e;F[b+8>>2]=F[c+24>>2];break E}ra(b,F[c+16>>2],F[c+20>>2]);}b=a+28|0;F:{if(D[c+39|0]>=0){e=F[c+32>>2];F[b>>2]=F[c+28>>2];F[b+4>>2]=e;F[b+8>>2]=F[c+36>>2];break F}ra(b,F[c+28>>2],F[c+32>>2]);}F[a+8>>2]=F[p+12>>2];F[a>>2]=0;F[a+4>>2]=0;F[f>>2]=a;b=a;e=F[F[r>>2]>>2];if(e){F[r>>2]=e;b=F[f>>2];}nb(F[r+4>>2],b);F[r+8>>2]=F[r+8>>2]+1;b=1;}D[x+12|0]=b;F[x+8>>2]=a;Z=p+16|0;b=F[c+4>>2];G:{if(b){while(1){c=b;b=F[b>>2];if(b){continue}break G}}while(1){a=c;c=F[c+8>>2];if((a|0)!=F[c>>2]){continue}break}}if((c|0)!=(z|0)){continue}break}}F[g+8>>2]=d;F[g>>2]=0;F[g+4>>2]=0;F[o>>2]=g;c=g;a=F[F[u>>2]>>2];if(a){F[u>>2]=a;c=F[o>>2];}nb(F[u+4>>2],c);F[u+8>>2]=F[u+8>>2]+1;a=1;}D[l+44|0]=a;F[l+40>>2]=g;Z=x+16|0;c=F[l+40>>2];ib(t|4,F[l+16>>2]);ib(y,F[l+28>>2]);}f=Z-48|0;Z=f;d=f+8|0;g=Z-32|0;Z=g;o=g+32|0;b=o;a=g+21|0;e=b-a|0;I:{if((e|0)<=9){h=61;if((e|0)<(I[2684]<=1|0)){break I}}D[a|0]=49;b=a+1|0;h=0;}F[g+12>>2]=h;F[g+8>>2]=b;h=Z-16|0;Z=h;e=Z-16|0;Z=e;J:{q=F[g+8>>2];g=q-a|0;if(g>>>0<=2147483631){K:{if(g>>>0<11){D[d+11|0]=g|G[d+11|0]&128;D[d+11|0]=G[d+11|0]&127;b=d;break K}t=e+8|0;if(g>>>0>=11){k=g+16&-16;b=k-1|0;b=(b|0)==11?k:b;}else {b=10;}sb(t,b+1|0);b=F[e+8>>2];F[d>>2]=b;F[d+8>>2]=F[d+8>>2]&-2147483648|F[e+12>>2]&2147483647;F[d+8>>2]=F[d+8>>2]|-2147483648;F[d+4>>2]=g;}while(1){if((a|0)!=(q|0)){D[b|0]=G[a|0];b=b+1|0;a=a+1|0;continue}break}D[e+7|0]=0;D[b|0]=G[e+7|0];Z=e+16|0;break J}za();v();}Z=h+16|0;Z=o;F[f+32>>2]=m;L:{M:{a=c+20|0;d=F[a+4>>2];N:{if(!d){g=a+4|0;c=g;break N}b=G[m+11|0];c=b<<24>>24<0;e=c?F[m>>2]:m;b=c?F[m+4>>2]:b;while(1){c=d;d=G[c+27|0];g=d<<24>>24<0;d=g?F[c+20>>2]:d;o=d>>>0<b>>>0;O:{P:{Q:{R:{h=o?d:b;S:{if(h){g=g?F[c+16>>2]:c+16|0;q=sa(e,g,h);if(!q){if(b>>>0<d>>>0){break S}break R}if((q|0)>=0){break R}break S}if(b>>>0>=d>>>0){break Q}}g=c;d=F[c>>2];if(d){continue}break N}d=sa(g,e,h);if(d){break P}}if(o){break O}break M}if((d|0)>=0){break M}}d=F[c+4>>2];if(d){continue}break}g=c+4|0;}d=ka(40);e=d+16|0;b=F[f+32>>2];T:{if(D[b+11|0]>=0){o=F[b+4>>2];F[e>>2]=F[b>>2];F[e+4>>2]=o;F[e+8>>2]=F[b+8>>2];break T}ra(e,F[b>>2],F[b+4>>2]);}F[d+8>>2]=c;F[d>>2]=0;F[d+4>>2]=0;F[d+36>>2]=0;F[d+28>>2]=0;F[d+32>>2]=0;F[g>>2]=d;c=d;b=F[F[a>>2]>>2];if(b){F[a>>2]=b;c=F[g>>2];}nb(F[a+4>>2],c);F[a+8>>2]=F[a+8>>2]+1;a=1;break L}d=c;a=0;}D[f+44|0]=a;F[f+40>>2]=d;a=F[f+40>>2];if(D[a+39|0]<0){ja(F[a+28>>2]);}b=F[f+12>>2];F[a+28>>2]=F[f+8>>2];F[a+32>>2]=b;F[a+36>>2]=F[f+16>>2];Z=f+48|0;Z=l+48|0;if(D[m+11|0]<0){ja(F[m>>2]);}Z=m+16|0;}function zd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;h=Z-32|0;Z=h;g=F[F[a+4>>2]+44>>2];c=F[a+8>>2];d=F[c>>2];c=F[c+4>>2];F[h+24>>2]=0;F[h+16>>2]=0;F[h+20>>2]=0;d=(c-d>>2>>>0)/3|0;c=F[g+96>>2];f=(F[g+100>>2]-c|0)/12|0;a:{if(d>>>0>f>>>0){e=d-f|0;i=F[g+104>>2];c=F[g+100>>2];if(e>>>0<=(i-c|0)/12>>>0){b:{if(!e){break b}d=c;f=L(e,12)-12|0;i=((f>>>0)/12|0)+1&3;if(i){while(1){l=F[h+20>>2];F[d>>2]=F[h+16>>2];F[d+4>>2]=l;F[d+8>>2]=F[h+24>>2];d=d+12|0;j=j+1|0;if((i|0)!=(j|0)){continue}break}}c=L(e,12)+c|0;if(f>>>0<36){break b}while(1){f=F[h+20>>2];F[d>>2]=F[h+16>>2];F[d+4>>2]=f;F[d+8>>2]=F[h+24>>2];F[d+20>>2]=F[h+24>>2];f=F[h+20>>2];F[d+12>>2]=F[h+16>>2];F[d+16>>2]=f;F[d+32>>2]=F[h+24>>2];f=F[h+20>>2];F[d+24>>2]=F[h+16>>2];F[d+28>>2]=f;f=F[h+20>>2];F[d+36>>2]=F[h+16>>2];F[d+40>>2]=f;F[d+44>>2]=F[h+24>>2];d=d+48|0;if((d|0)!=(c|0)){continue}break}}F[g+100>>2]=c;break a}c:{f=F[g+96>>2];n=(c-f|0)/12|0;d=n+e|0;if(d>>>0<357913942){f=(i-f|0)/12|0;i=f<<1;i=f>>>0>=178956970?357913941:d>>>0<i>>>0?i:d;if(i){if(i>>>0>=357913942){break c}l=ka(L(i,12));}f=L(n,12)+l|0;d=f;e=L(e,12);n=e-12|0;q=((n>>>0)/12|0)+1&3;if(q){while(1){r=F[h+20>>2];F[d>>2]=F[h+16>>2];F[d+4>>2]=r;F[d+8>>2]=F[h+24>>2];d=d+12|0;j=j+1|0;if((q|0)!=(j|0)){continue}break}}e=e+f|0;if(n>>>0>=36){while(1){j=F[h+20>>2];F[d>>2]=F[h+16>>2];F[d+4>>2]=j;F[d+8>>2]=F[h+24>>2];F[d+20>>2]=F[h+24>>2];j=F[h+20>>2];F[d+12>>2]=F[h+16>>2];F[d+16>>2]=j;F[d+32>>2]=F[h+24>>2];j=F[h+20>>2];F[d+24>>2]=F[h+16>>2];F[d+28>>2]=j;j=F[h+20>>2];F[d+36>>2]=F[h+16>>2];F[d+40>>2]=j;F[d+44>>2]=F[h+24>>2];d=d+48|0;if((e|0)!=(d|0)){continue}break}}j=F[g+96>>2];if((j|0)!=(c|0)){while(1){c=c-12|0;n=F[c+4>>2];f=f-12|0;d=f;F[d>>2]=F[c>>2];F[d+4>>2]=n;F[d+8>>2]=F[c+8>>2];if((c|0)!=(j|0)){continue}break}c=F[g+96>>2];}F[g+104>>2]=L(i,12)+l;F[g+100>>2]=e;F[g+96>>2]=f;if(c){ja(c);}break a}na();v();}oa();v();}if(d>>>0>=f>>>0){break a}F[g+100>>2]=c+L(d,12);}d:{if(F[a+216>>2]==F[a+220>>2]){j=F[a+4>>2];c=F[j+44>>2];d=F[c+100>>2];f=F[c+96>>2];if((d|0)!=(f|0)){c=(d-f|0)/12|0;o=c>>>0<=1?1:c;c=0;while(1){d=F[a+8>>2];i=f+L(c,12)|0;g=L(c,3);e:{f:{if((g|0)==-1){e=F[(F[d>>2]+(g<<2)|0)+4>>2];k=-1;g=1;break f}e=-1;k=F[F[d>>2]+(g<<2)>>2];l=g+1|0;if((l|0)==-1){g=0;break f}e=F[F[d>>2]+(l<<2)>>2];g=g+2|0;m=-1;if((g|0)==-1){break e}}m=F[F[d>>2]+(g<<2)>>2];}F[i+8>>2]=m;F[i+4>>2]=e;F[i>>2]=k;c=c+1|0;if((o|0)!=(c|0)){continue}break}}F[F[j+4>>2]+80>>2]=b;c=1;break d}d=0;F[h+24>>2]=0;F[h+16>>2]=0;F[h+20>>2]=0;l=F[a+8>>2];c=F[l>>2];g=F[l+4>>2];F[h+8>>2]=0;F[h>>2]=0;F[h+4>>2]=0;b=0;g:{h:{i:{j:{k:{l:{if((c|0)!=(g|0)){c=g-c|0;if((c|0)<0){break l}b=ka(c);F[h>>2]=b;F[h+8>>2]=(c&-4)+b;u=h,w=ma(b,0,c)+c|0,F[u+4>>2]=w;}c=F[l+24>>2];if((F[l+28>>2]-c|0)<4){break h}f=0;while(1){g=F[(p<<2)+c>>2];m:{if((g|0)==-1){break m}n:{if(F[F[a+120>>2]+(p>>>3&536870908)>>2]>>>p&1){break n}n=F[a+216>>2];c=F[a+220>>2];if((n|0)==(c|0)){break n}e=g+2|0;i=(g>>>0)%3|0;q=i?g-1|0:e;c=(c-n|0)/144|0;r=c>>>0<=1?1:c;j=0;t=(i|0)!=0|(e|0)!=-1;while(1){s=g<<2;i=L(j,144)+n|0;c=F[s+F[F[i+68>>2]>>2]>>2];o:{if(!(F[F[i+16>>2]+(c>>>3&536870908)>>2]>>>c&1)){break o}c=-1;p:{if(!t){break p}e=F[F[l+12>>2]+(q<<2)>>2];c=-1;if((e|0)==-1){break p}c=e-1|0;if((e>>>0)%3|0){break p}c=e+2|0;}if((g|0)==(c|0)){break o}e=s;s=F[i+32>>2];i=F[e+s>>2];while(1){e=0;if((c|0)==-1){break g}if((i|0)!=F[s+(c<<2)>>2]){g=c;break n}q:{r:{if((c>>>0)%3|0){e=c-1|0;break r}e=c+2|0;m=-1;if((e|0)==-1){break q}}c=F[F[l+12>>2]+(e<<2)>>2];m=-1;if((c|0)==-1){break q}m=c-1|0;if((c>>>0)%3|0){break q}m=c+2|0;}c=m;if((g|0)!=(c|0)){continue}break}}j=j+1|0;if((r|0)!=(j|0)){continue}break}}i=k-f|0;e=i>>2;F[(g<<2)+b>>2]=e;s:{if(k>>>0<o>>>0){F[k>>2]=g;k=k+4|0;F[h+20>>2]=k;break s}c=e+1|0;if(c>>>0>=1073741824){break k}d=o-f|0;k=d>>>1|0;c=d>>>0>=2147483644?1073741823:c>>>0<k>>>0?k:c;if(c){if(c>>>0>=1073741824){break j}d=ka(c<<2);}else {d=0;}e=d+(e<<2)|0;F[e>>2]=g;m=c<<2;c=pa(d,f,i);o=m+c|0;F[h+24>>2]=o;k=e+4|0;F[h+20>>2]=k;F[h+16>>2]=c;if(f){ja(f);l=F[a+8>>2];}f=c;}if((g|0)==-1){break m}t:{if((g>>>0)%3|0){c=g-1|0;break t}c=g+2|0;if((c|0)==-1){break m}}c=F[F[l+12>>2]+(c<<2)>>2];if((c|0)==-1){break m}c=c+((c>>>0)%3|0?-1:2)|0;if((c|0)==-1){break m}e=g;if((c|0)==(g|0)){break m}while(1){i=c;u:{v:{c=F[a+220>>2];j=F[a+216>>2];if((c|0)==(j|0)){break v}c=(c-j|0)/144|0;n=c>>>0<=1?1:c;c=0;while(1){q=F[(j+L(c,144)|0)+32>>2];r=i<<2;if(F[q+r>>2]==F[q+(e<<2)>>2]){c=c+1|0;if((n|0)!=(c|0)){continue}break v}break}j=k-d|0;e=j>>2;F[b+r>>2]=e;if(k>>>0<o>>>0){F[k>>2]=i;k=k+4|0;F[h+20>>2]=k;f=d;break u}c=e+1|0;if(c>>>0>=1073741824){break i}f=o-d|0;k=f>>>1|0;c=f>>>0>=2147483644?1073741823:c>>>0<k>>>0?k:c;if(c){if(c>>>0>=1073741824){break j}f=ka(c<<2);}else {f=0;}e=f+(e<<2)|0;F[e>>2]=i;m=c<<2;c=pa(f,d,j);o=m+c|0;F[h+24>>2]=o;k=e+4|0;F[h+20>>2]=k;F[h+16>>2]=c;if(!d){d=c;break u}ja(d);l=F[a+8>>2];d=c;break u}F[(i<<2)+b>>2]=F[(e<<2)+b>>2];}if((i|0)==-1){break m}w:{if((i>>>0)%3|0){c=i-1|0;break w}c=i+2|0;if((c|0)==-1){break m}}c=F[F[l+12>>2]+(c<<2)>>2];if((c|0)==-1){break m}c=c+((c>>>0)%3|0?-1:2)|0;if((c|0)==-1){break m}e=i;if((c|0)!=(g|0)){continue}break}}p=p+1|0;c=F[l+24>>2];if((p|0)<F[l+28>>2]-c>>2){continue}break}break h}na();v();}na();v();}oa();v();}na();v();}i=F[a+4>>2];a=F[i+44>>2];c=F[a+100>>2];a=F[a+96>>2];x:{if((c|0)==(a|0)){break x}g=(c-a|0)/12|0;f=g>>>0<=1?1:g;l=f&1;c=0;if(g>>>0>=2){j=f&-2;g=0;while(1){e=L(c,12);f=e+b|0;o=F[f>>2];p=F[f+4>>2];e=a+e|0;F[e+8>>2]=F[f+8>>2];F[e>>2]=o;F[e+4>>2]=p;e=L(c|1,12);f=e+b|0;o=F[f>>2];p=F[f+4>>2];e=a+e|0;F[e+8>>2]=F[f+8>>2];F[e>>2]=o;F[e+4>>2]=p;c=c+2|0;g=g+2|0;if((j|0)!=(g|0)){continue}break}}if(!l){break x}g=L(c,12);c=g+b|0;f=F[c>>2];e=F[c+4>>2];a=a+g|0;F[a+8>>2]=F[c+8>>2];F[a>>2]=f;F[a+4>>2]=e;}F[F[i+4>>2]+80>>2]=k-d>>2;e=1;}c=e;if(b){ja(b);}if(!d){break d}F[h+20>>2]=d;ja(d);}Z=h+32|0;return c}function de(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,M=0,N=0,O=0,P=0;g=Z+-64|0;Z=g;F[a+8>>2]=e;y=a+32|0;f=F[y>>2];d=F[a+36>>2]-f>>2;a:{b:{if(d>>>0<e>>>0){qa(y,e-d|0);F[g+56>>2]=0;F[g+60>>2]=0;F[g+48>>2]=0;F[g+52>>2]=0;F[g+40>>2]=0;F[g+44>>2]=0;F[g+32>>2]=0;F[g+36>>2]=0;F[g+24>>2]=0;F[g+28>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;F[g>>2]=0;break b}if(d>>>0>e>>>0){F[a+36>>2]=f+(e<<2);}F[g+56>>2]=0;F[g+60>>2]=0;F[g+48>>2]=0;F[g+52>>2]=0;F[g+40>>2]=0;F[g+44>>2]=0;F[g+32>>2]=0;F[g+36>>2]=0;F[g+24>>2]=0;F[g+28>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;F[g>>2]=0;d=0;if(!e){break a}}Fa(g+16|0,e,g);h=F[g+28>>2];d=F[g+32>>2];}F[g>>2]=0;d=d-h>>2;c:{if(d>>>0>=e>>>0){if(d>>>0<=e>>>0){break c}F[g+32>>2]=(e<<2)+h;break c}Fa(g+16|12,e-d|0,g);}F[g>>2]=0;f=F[g+40>>2];d=F[g+44>>2]-f>>2;d:{if(d>>>0>=e>>>0){if(d>>>0<=e>>>0){break d}F[g+44>>2]=f+(e<<2);break d}Fa(g+40|0,e-d|0,g);}F[g>>2]=0;f=F[g+52>>2];d=F[g+56>>2]-f>>2;e:{if(d>>>0>=e>>>0){if(d>>>0<=e>>>0){break e}F[g+56>>2]=f+(e<<2);break e}Fa(g+52|0,e-d|0,g);}f:{if(F[a+8>>2]<=0){break f}i=F[g+16>>2];j=F[a+32>>2];h=0;while(1){d=h<<2;f=F[d+i>>2];m=F[a+16>>2];g:{if((f|0)>(m|0)){F[d+j>>2]=m;break g}d=d+j|0;m=F[a+12>>2];if((m|0)>(f|0)){F[d>>2]=m;break g}F[d>>2]=f;}h=h+1|0;d=F[a+8>>2];if((h|0)<(d|0)){continue}break}if((d|0)<=0){break f}d=0;while(1){i=d<<2;f=i+c|0;i=F[b+i>>2]+F[j+i>>2]|0;F[f>>2]=i;h:{if((i|0)>F[a+16>>2]){i=i-F[a+20>>2]|0;}else {if((i|0)>=F[a+12>>2]){break h}i=i+F[a+20>>2]|0;}F[f>>2]=i;}d=d+1|0;if((d|0)<F[a+8>>2]){continue}break}}H=F[a+52>>2];t=F[a+48>>2];z=ka(16);d=z;F[d>>2]=0;F[d+4>>2]=0;F[d+8>>2]=0;F[d+12>>2]=0;F[g+8>>2]=0;F[g>>2]=0;F[g+4>>2]=0;i:{if(e){if(e>>>0>=1073741824){break i}d=e<<2;r=ka(d);F[g>>2]=r;F[g+8>>2]=d+r;ma(r,0,d);}A=1;d=F[a+56>>2];B=F[d>>2];d=F[d+4>>2]-B|0;j:{if((d|0)<8){break j}w=d>>2;I=(w|0)<=2?2:w;J=w>>>0<=1?1:w;C=e&-2;D=e&1;K=e&-4;E=e&3;G=e-1|0;M=e<<2;N=e>>>0<4;A=0;m=1;while(1){k:{l:{m:{n:{if((m|0)!=(J|0)){o:{p:{f=F[(m<<2)+B>>2];if((f|0)==-1){break p}k=1;d=f+2|0;j=(f>>>0)%3|0;x=j?f-1|0:d;s=1<<x;n=F[t>>2];O=n+(x>>>3&536870908)|0;i=0;P=(j|0)!=0|(d|0)!=-1;d=f;q:{while(1){r:{if(F[n+(d>>>3&536870908)>>2]>>>d&1){break r}j=F[F[F[t+64>>2]+12>>2]+(d<<2)>>2];if((j|0)==-1){break r}l=F[H>>2];h=F[t+28>>2];p=F[l+(F[h+(j<<2)>>2]<<2)>>2];if((p|0)>=(m|0)){break r}q=j+1|0;q=F[l+(F[h+(((q>>>0)%3|0?q:j-2|0)<<2)>>2]<<2)>>2];if((q|0)>=(m|0)){break r}h=F[l+(F[h+(j+((j>>>0)%3|0?-1:2)<<2)>>2]<<2)>>2];if((h|0)>=(m|0)){break r}s:{if(!e){break s}j=F[(g+16|0)+L(i,12)>>2];l=L(e,h);q=L(e,q);p=L(e,p);h=0;o=0;if(G){while(1){F[j+(h<<2)>>2]=(F[(h+l<<2)+c>>2]+F[(h+q<<2)+c>>2]|0)-F[(h+p<<2)+c>>2];u=h|1;F[j+(u<<2)>>2]=(F[(l+u<<2)+c>>2]+F[(q+u<<2)+c>>2]|0)-F[(p+u<<2)+c>>2];h=h+2|0;o=o+2|0;if((C|0)!=(o|0)){continue}break}}if(!D){break s}F[j+(h<<2)>>2]=(F[(h+l<<2)+c>>2]+F[(h+q<<2)+c>>2]|0)-F[(h+p<<2)+c>>2];}j=4;i=i+1|0;if((i|0)==4){break q}}t:{if(k&1){h=d-2|0;j=d+1|0;d=-1;j=(j>>>0)%3|0?j:h;if((j|0)==-1|F[n+(j>>>3&536870908)>>2]>>>j&1){break t}j=F[F[F[t+64>>2]+12>>2]+(j<<2)>>2];if((j|0)==-1){break t}d=j+1|0;d=(d>>>0)%3|0?d:j-2|0;break t}u:{if((d>>>0)%3|0){h=d-1|0;break u}h=d+2|0;d=-1;if((h|0)==-1){break t}}d=-1;if(F[n+(h>>>3&536870908)>>2]>>>h&1){break t}j=F[F[F[t+64>>2]+12>>2]+(h<<2)>>2];if((j|0)==-1){break t}if((j>>>0)%3|0){d=j-1|0;break t}d=j+2|0;}v:{if((d|0)==(f|0)){break v}if((d|0)==-1&k){if(!P|s&F[O>>2]){break v}d=F[F[F[t+64>>2]+12>>2]+(x<<2)>>2];if((d|0)==-1){break v}k=0;d=(d>>>0)%3|0?d-1|0:d+2|0;}if((d|0)!=-1){continue}}break}j=i;if((j|0)<=0){break p}}if(e){ma(r,0,M);}d=j-1|0;q=(d<<2)+z|0;d=L(d,12)+a|0;u=d;x=F[d- -64>>2];k=0;d=F[g>>2];f=0;while(1){i=F[q>>2];F[q>>2]=i+1;if(i>>>0>=x>>>0){break j}w:{if(F[F[u+60>>2]+(i>>>3&536870908)>>2]>>>i&1){break w}f=f+1|0;if(!e){break w}n=F[(g+16|0)+L(k,12)>>2];i=0;h=0;p=0;if(!N){while(1){l=h<<2;o=l+d|0;F[o>>2]=F[l+n>>2]+F[o>>2];o=l|4;s=o+d|0;F[s>>2]=F[n+o>>2]+F[s>>2];o=l|8;s=o+d|0;F[s>>2]=F[n+o>>2]+F[s>>2];l=l|12;o=l+d|0;F[o>>2]=F[l+n>>2]+F[o>>2];h=h+4|0;p=p+4|0;if((K|0)!=(p|0)){continue}break}}if(!E){break w}while(1){l=h<<2;p=l+d|0;F[p>>2]=F[l+n>>2]+F[p>>2];h=h+1|0;i=i+1|0;if((E|0)!=(i|0)){continue}break}}k=k+1|0;if((k|0)!=(j|0)){continue}break}i=L(e,m);if(!f){break o}if(!e){break l}h=0;d=0;if(G){break n}break m}i=L(e,m);}if(F[a+8>>2]<=0){break k}k=(L(m-1|0,e)<<2)+c|0;j=F[y>>2];h=0;while(1){d=h<<2;f=F[d+k>>2];n=F[a+16>>2];x:{if((f|0)>(n|0)){F[d+j>>2]=n;break x}d=d+j|0;n=F[a+12>>2];if((n|0)>(f|0)){F[d>>2]=n;break x}F[d>>2]=f;}h=h+1|0;f=F[a+8>>2];if((h|0)<(f|0)){continue}break}d=0;if((f|0)<=0){break k}f=i<<2;h=f+c|0;k=b+f|0;while(1){i=d<<2;f=i+h|0;i=F[i+k>>2]+F[j+i>>2]|0;F[f>>2]=i;y:{if((i|0)>F[a+16>>2]){i=i-F[a+20>>2]|0;}else {if((i|0)>=F[a+12>>2]){break y}i=i+F[a+20>>2]|0;}F[f>>2]=i;}d=d+1|0;if((d|0)<F[a+8>>2]){continue}break}break k}ta();v();}while(1){j=h<<2;k=j+r|0;F[k>>2]=F[k>>2]/(f|0);j=(j|4)+r|0;F[j>>2]=F[j>>2]/(f|0);h=h+2|0;d=d+2|0;if((C|0)!=(d|0)){continue}break}}if(!D){break l}d=(h<<2)+r|0;F[d>>2]=F[d>>2]/(f|0);}if(F[a+8>>2]<=0){break k}j=F[y>>2];h=0;while(1){d=h<<2;f=F[d+r>>2];k=F[a+16>>2];z:{if((f|0)>(k|0)){F[d+j>>2]=k;break z}d=d+j|0;k=F[a+12>>2];if((k|0)>(f|0)){F[d>>2]=k;break z}F[d>>2]=f;}h=h+1|0;f=F[a+8>>2];if((h|0)<(f|0)){continue}break}d=0;if((f|0)<=0){break k}f=i<<2;h=f+c|0;k=b+f|0;while(1){i=d<<2;f=i+h|0;i=F[i+k>>2]+F[j+i>>2]|0;F[f>>2]=i;A:{if((i|0)>F[a+16>>2]){i=i-F[a+20>>2]|0;}else {if((i|0)>=F[a+12>>2]){break A}i=i+F[a+20>>2]|0;}F[f>>2]=i;}d=d+1|0;if((d|0)<F[a+8>>2]){continue}break}}m=m+1|0;A=(w|0)<=(m|0);if((m|0)!=(I|0)){continue}break}}a=F[g>>2];if(a){ja(a);}ja(z);a=F[g+52>>2];if(a){F[g+56>>2]=a;ja(a);}a=F[g+40>>2];if(a){F[g+44>>2]=a;ja(a);}a=F[g+28>>2];if(a){F[g+32>>2]=a;ja(a);}a=F[g+16>>2];if(a){F[g+20>>2]=a;ja(a);}Z=g- -64|0;return A|0}na();v();}function $h(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,G=0,H=0,I=0,J=0,K=0,M=0,N=0;h=Z+-64|0;Z=h;F[a+8>>2]=e;x=a+32|0;f=F[x>>2];d=F[a+36>>2]-f>>2;a:{b:{if(d>>>0<e>>>0){qa(x,e-d|0);F[h+56>>2]=0;F[h+60>>2]=0;F[h+48>>2]=0;F[h+52>>2]=0;F[h+40>>2]=0;F[h+44>>2]=0;F[h+32>>2]=0;F[h+36>>2]=0;F[h+24>>2]=0;F[h+28>>2]=0;F[h+16>>2]=0;F[h+20>>2]=0;F[h>>2]=0;break b}if(d>>>0>e>>>0){F[a+36>>2]=f+(e<<2);}F[h+56>>2]=0;F[h+60>>2]=0;F[h+48>>2]=0;F[h+52>>2]=0;F[h+40>>2]=0;F[h+44>>2]=0;F[h+32>>2]=0;F[h+36>>2]=0;F[h+24>>2]=0;F[h+28>>2]=0;F[h+16>>2]=0;F[h+20>>2]=0;F[h>>2]=0;d=0;if(!e){break a}}Fa(h+16|0,e,h);i=F[h+28>>2];d=F[h+32>>2];}F[h>>2]=0;d=d-i>>2;c:{if(d>>>0>=e>>>0){if(d>>>0<=e>>>0){break c}F[h+32>>2]=(e<<2)+i;break c}Fa(h+16|12,e-d|0,h);}F[h>>2]=0;f=F[h+40>>2];d=F[h+44>>2]-f>>2;d:{if(d>>>0>=e>>>0){if(d>>>0<=e>>>0){break d}F[h+44>>2]=f+(e<<2);break d}Fa(h+40|0,e-d|0,h);}F[h>>2]=0;f=F[h+52>>2];d=F[h+56>>2]-f>>2;e:{if(d>>>0>=e>>>0){if(d>>>0<=e>>>0){break e}F[h+56>>2]=f+(e<<2);break e}Fa(h+52|0,e-d|0,h);}f:{if(F[a+8>>2]<=0){break f}g=F[h+16>>2];j=F[a+32>>2];i=0;while(1){d=i<<2;f=F[d+g>>2];m=F[a+16>>2];g:{if((f|0)>(m|0)){F[d+j>>2]=m;break g}d=d+j|0;m=F[a+12>>2];if((m|0)>(f|0)){F[d>>2]=m;break g}F[d>>2]=f;}i=i+1|0;d=F[a+8>>2];if((i|0)<(d|0)){continue}break}if((d|0)<=0){break f}d=0;while(1){g=d<<2;f=g+c|0;g=F[b+g>>2]+F[g+j>>2]|0;F[f>>2]=g;h:{if((g|0)>F[a+16>>2]){g=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break h}g=g+F[a+20>>2]|0;}F[f>>2]=g;}d=d+1|0;if((d|0)<F[a+8>>2]){continue}break}}H=F[a+52>>2];A=F[a+48>>2];y=ka(16);d=y;F[d>>2]=0;F[d+4>>2]=0;F[d+8>>2]=0;F[d+12>>2]=0;F[h+8>>2]=0;F[h>>2]=0;F[h+4>>2]=0;i:{if(e){if(e>>>0>=1073741824){break i}d=e<<2;t=ka(d);F[h>>2]=t;F[h+8>>2]=d+t;ma(t,0,d);}z=1;d=F[a+56>>2];B=F[d>>2];d=F[d+4>>2]-B|0;j:{if((d|0)<8){break j}w=d>>2;I=(w|0)<=2?2:w;J=w>>>0<=1?1:w;C=e&-2;D=e&1;K=e&-4;E=e&3;G=e-1|0;M=e<<2;N=e>>>0<4;z=0;m=1;while(1){k:{l:{m:{n:{if((m|0)!=(J|0)){o:{p:{f=F[(m<<2)+B>>2];if((f|0)==-1){break p}n=F[A+12>>2];d=f+2|0;g=(f>>>0)%3|0;q=n+((g?f-1|0:d)<<2)|0;j=0;u=(g|0)!=0|(d|0)!=-1;k=1;d=f;q:{while(1){g=F[n+(d<<2)>>2];r:{if((g|0)==-1){break r}l=-1;p=F[H>>2];r=F[A>>2];i=p+(F[r+(g<<2)>>2]<<2)|0;o=g+1|0;o=(o>>>0)%3|0?o:g-2|0;if((o|0)!=-1){l=F[r+(o<<2)>>2];}o=F[i>>2];s:{t:{if((g>>>0)%3|0){i=g-1|0;break t}i=g+2|0;s=-1;if((i|0)==-1){break s}}s=F[r+(i<<2)>>2];}if((m|0)<=(o|0)){break r}i=F[p+(l<<2)>>2];if((i|0)>=(m|0)){break r}l=F[p+(s<<2)>>2];if((l|0)>=(m|0)){break r}g=F[(h+16|0)+L(j,12)>>2];u:{if(!e){break u}l=L(e,l);r=L(e,i);p=L(e,o);i=0;s=0;if(G){while(1){F[g+(i<<2)>>2]=(F[(i+l<<2)+c>>2]+F[(i+r<<2)+c>>2]|0)-F[(i+p<<2)+c>>2];o=i|1;F[g+(o<<2)>>2]=(F[(l+o<<2)+c>>2]+F[(o+r<<2)+c>>2]|0)-F[(o+p<<2)+c>>2];i=i+2|0;s=s+2|0;if((C|0)!=(s|0)){continue}break}}if(!D){break u}F[g+(i<<2)>>2]=(F[(i+l<<2)+c>>2]+F[(i+r<<2)+c>>2]|0)-F[(i+p<<2)+c>>2];}g=4;j=j+1|0;if((j|0)==4){break q}}v:{if(k&1){i=d+1|0;d=(i>>>0)%3|0?i:d-2|0;g=-1;if((d|0)==-1){break v}d=F[n+(d<<2)>>2];g=-1;if((d|0)==-1){break v}g=d+1|0;g=(g>>>0)%3|0?g:d-2|0;break v}w:{if((d>>>0)%3|0){i=d-1|0;break w}i=d+2|0;g=-1;if((i|0)==-1){break v}}d=F[n+(i<<2)>>2];g=-1;if((d|0)==-1){break v}g=d-1|0;if((d>>>0)%3|0){break v}g=d+2|0;}d=g;x:{if((f|0)==(d|0)){break x}if((d|0)==-1&k){if(!u){break x}d=F[q>>2];if((d|0)==-1){break x}k=0;d=(d>>>0)%3|0?d-1|0:d+2|0;}if((d|0)!=-1){continue}}break}g=j;if((g|0)<=0){break p}}if(e){ma(t,0,M);}d=g-1|0;r=(d<<2)+y|0;d=L(d,12)+a|0;o=d;s=F[d- -64>>2];k=0;d=F[h>>2];f=0;while(1){j=F[r>>2];F[r>>2]=j+1;if(j>>>0>=s>>>0){break j}y:{if(F[F[o+60>>2]+(j>>>3&536870908)>>2]>>>j&1){break y}f=f+1|0;if(!e){break y}j=F[(h+16|0)+L(k,12)>>2];l=0;i=0;p=0;if(!N){while(1){n=i<<2;q=n+d|0;F[q>>2]=F[j+n>>2]+F[q>>2];q=n|4;u=q+d|0;F[u>>2]=F[j+q>>2]+F[u>>2];q=n|8;u=q+d|0;F[u>>2]=F[j+q>>2]+F[u>>2];n=n|12;q=n+d|0;F[q>>2]=F[j+n>>2]+F[q>>2];i=i+4|0;p=p+4|0;if((K|0)!=(p|0)){continue}break}}if(!E){break y}while(1){n=i<<2;p=n+d|0;F[p>>2]=F[j+n>>2]+F[p>>2];i=i+1|0;l=l+1|0;if((E|0)!=(l|0)){continue}break}}k=k+1|0;if((k|0)!=(g|0)){continue}break}g=L(e,m);if(!f){break o}if(!e){break l}i=0;d=0;if(G){break n}break m}g=L(e,m);}if(F[a+8>>2]<=0){break k}k=(L(m-1|0,e)<<2)+c|0;j=F[x>>2];i=0;while(1){d=i<<2;f=F[d+k>>2];l=F[a+16>>2];z:{if((f|0)>(l|0)){F[d+j>>2]=l;break z}d=d+j|0;l=F[a+12>>2];if((l|0)>(f|0)){F[d>>2]=l;break z}F[d>>2]=f;}i=i+1|0;f=F[a+8>>2];if((i|0)<(f|0)){continue}break}d=0;if((f|0)<=0){break k}f=g<<2;i=f+c|0;k=b+f|0;while(1){g=d<<2;f=g+i|0;g=F[g+k>>2]+F[g+j>>2]|0;F[f>>2]=g;A:{if((g|0)>F[a+16>>2]){g=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break A}g=g+F[a+20>>2]|0;}F[f>>2]=g;}d=d+1|0;if((d|0)<F[a+8>>2]){continue}break}break k}ta();v();}while(1){j=i<<2;k=j+t|0;F[k>>2]=F[k>>2]/(f|0);j=(j|4)+t|0;F[j>>2]=F[j>>2]/(f|0);i=i+2|0;d=d+2|0;if((C|0)!=(d|0)){continue}break}}if(!D){break l}d=(i<<2)+t|0;F[d>>2]=F[d>>2]/(f|0);}if(F[a+8>>2]<=0){break k}j=F[x>>2];i=0;while(1){d=i<<2;f=F[d+t>>2];k=F[a+16>>2];B:{if((f|0)>(k|0)){F[d+j>>2]=k;break B}d=d+j|0;k=F[a+12>>2];if((k|0)>(f|0)){F[d>>2]=k;break B}F[d>>2]=f;}i=i+1|0;f=F[a+8>>2];if((i|0)<(f|0)){continue}break}d=0;if((f|0)<=0){break k}f=g<<2;i=f+c|0;k=b+f|0;while(1){g=d<<2;f=g+i|0;g=F[g+k>>2]+F[g+j>>2]|0;F[f>>2]=g;C:{if((g|0)>F[a+16>>2]){g=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break C}g=g+F[a+20>>2]|0;}F[f>>2]=g;}d=d+1|0;if((d|0)<F[a+8>>2]){continue}break}}m=m+1|0;z=(w|0)<=(m|0);if((m|0)!=(I|0)){continue}break}}a=F[h>>2];if(a){ja(a);}ja(y);a=F[h+52>>2];if(a){F[h+56>>2]=a;ja(a);}a=F[h+40>>2];if(a){F[h+44>>2]=a;ja(a);}a=F[h+28>>2];if(a){F[h+32>>2]=a;ja(a);}a=F[h+16>>2];if(a){F[h+20>>2]=a;ja(a);}Z=h- -64|0;return z|0}na();v();}function Yh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,E=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,$=0,aa=0,ba=0,ca=0;a:{b:{if((e|0)!=2){break b}F[a+8>>2]=2;F[a- -64>>2]=f;N=a+32|0;e=F[N>>2];d=F[a+36>>2]-e|0;c:{if(d>>>0<=7){qa(N,2-(d>>>2|0)|0);break c}if((d|0)==8){break c}F[a+36>>2]=e+8;}j=1;d=F[a+56>>2];d=F[d+4>>2]-F[d>>2]|0;if((d|0)<=0){break b}o=a+60|0;d=d>>>2|0;$=d>>>0<=1?1:d;aa=a+68|0;d=0;while(1){f=F[a+56>>2];e=F[f>>2];if(F[f+4>>2]-e>>2>>>0<=d>>>0){break a}l=Z-80|0;Z=l;f=-1;d:{e:{e=F[e+(d<<2)>>2];if((e|0)==-1){break e}j=F[o+32>>2];g=e+1|0;g=(g>>>0)%3|0?g:e-2|0;if((g|0)!=-1){f=F[F[j>>2]+(g<<2)>>2];}n=-1;e=e+((e>>>0)%3|0?-1:2)|0;if((e|0)!=-1){n=F[F[j>>2]+(e<<2)>>2];}j=F[o+36>>2];e=F[j>>2];j=F[j+4>>2]-e>>2;if(j>>>0<=f>>>0|j>>>0<=n>>>0){break e}f:{g:{h:{i:{j:{k:{i=F[e+(n<<2)>>2];f=F[e+(f<<2)>>2];if((i|0)>=(d|0)|(f|0)>=(d|0)){break k}j=(i<<3)+c|0;u=F[j+4>>2];g=(f<<3)+c|0;e=F[g+4>>2];A=F[j>>2];j=F[g>>2];if(!((A|0)!=(j|0)|(e|0)!=(u|0))){F[o+8>>2]=j;F[o+12>>2]=e;break j}n=F[F[o+4>>2]+(d<<2)>>2];F[l+72>>2]=0;F[l+76>>2]=0;g=l- -64|0;F[g>>2]=0;F[g+4>>2]=0;F[l+56>>2]=0;F[l+60>>2]=0;g=F[o>>2];if(!G[g+84|0]){n=F[F[g+68>>2]+(n<<2)>>2];}Ga(g,n,D[g+24|0],l+56|0);n=F[F[o+4>>2]+(f<<2)>>2];F[l+48>>2]=0;F[l+52>>2]=0;F[l+40>>2]=0;F[l+44>>2]=0;F[l+32>>2]=0;F[l+36>>2]=0;g=F[o>>2];if(!G[g+84|0]){n=F[F[g+68>>2]+(n<<2)>>2];}Ga(g,n,D[g+24|0],l+32|0);n=F[F[o+4>>2]+(i<<2)>>2];F[l+24>>2]=0;F[l+28>>2]=0;F[l+16>>2]=0;F[l+20>>2]=0;F[l+8>>2]=0;F[l+12>>2]=0;g=F[o>>2];if(!G[g+84|0]){n=F[F[g+68>>2]+(n<<2)>>2];}Ga(g,n,D[g+24|0],l+8|0);g=F[l+16>>2];w=F[l+40>>2];B=g-w|0;O=F[l+44>>2];g=F[l+20>>2]-(O+(g>>>0<w>>>0)|0)|0;J=g;i=ki(B,g,B,g);m=_;g=F[l+8>>2];C=F[l+32>>2];E=g-C|0;P=F[l+36>>2];g=F[l+12>>2]-(P+(g>>>0<C>>>0)|0)|0;K=g;k=i;i=ki(E,g,E,g);g=k+i|0;k=_+m|0;k=g>>>0<i>>>0?k+1|0:k;i=F[l+24>>2];H=F[l+48>>2];I=i-H|0;Q=F[l+52>>2];i=F[l+28>>2]-(Q+(i>>>0<H>>>0)|0)|0;L=i;h=g;g=ki(I,i,I,i);q=h+g|0;h=_+k|0;r=g>>>0>q>>>0?h+1|0:h;if(!(r|q)){break k}n=0;x=mi(-1,2147483647,q,r);f=j>>31;S=f;h=f>>31;R=j;g=h;m=j^g;j=m-g|0;f=(f^g)-((g>>>0>m>>>0)+g|0)|0;g=f;f=e>>31;T=f;M=e;e=f>>31;m=M^e;h=m-e|0;k=f>>31;e=(k^f)-((e>>>0>m>>>0)+k|0)|0;f=(g|0)==(e|0)&h>>>0<j>>>0|e>>>0<g>>>0;j=f?j:h;i=_;e=f?g:e;if((i|0)==(e|0)&j>>>0>x>>>0|e>>>0>i>>>0){break f}j=F[l+64>>2];U=F[l+68>>2];e=ki(j-w|0,U-((j>>>0<w>>>0)+O|0)|0,B,J);f=_;g=F[l+56>>2];V=F[l+60>>2];i=ki(g-C|0,V-((g>>>0<C>>>0)+P|0)|0,E,K);e=i+e|0;h=_+f|0;m=F[l+72>>2];W=F[l+76>>2];f=ki(m-H|0,W-((m>>>0<H>>>0)+Q|0)|0,I,L);y=f+e|0;e=_+(e>>>0<i>>>0?h+1|0:h)|0;e=f>>>0>y>>>0?e+1|0:e;x=e;f=e;e=e>>31;i=e;h=e^y;e=h-e|0;i=(f^i)-((h>>>0<i>>>0)+i|0)|0;f=A;A=f-R|0;f=(f>>31)-((f>>>0<R>>>0)+S|0)|0;X=f;z=f>>31;p=z^A;k=p-z|0;h=f>>31;f=(h^f)-((p>>>0<z>>>0)+h|0)|0;p=f;z=u-M|0;f=(u>>31)-((u>>>0<M>>>0)+T|0)|0;u=f;s=f>>31;t=s^z;Y=t-s|0;h=f>>31;f=(h^f)-((s>>>0>t>>>0)+h|0)|0;h=(p|0)==(f|0)&k>>>0>Y>>>0|f>>>0<p>>>0;f=mi(-1,2147483647,h?k:Y,h?p:f);h=_;if((h|0)==(i|0)&e>>>0>f>>>0|h>>>0<i>>>0){break f}f=e;e=i;h=K>>31;p=h^E;i=p-h|0;h=(h^K)-((h>>>0>p>>>0)+h|0)|0;k=J>>31;s=k^B;t=s-k|0;k=(k^J)-((k>>>0>s>>>0)+k|0)|0;p=(h|0)==(k|0)&i>>>0>t>>>0|h>>>0>k>>>0;i=p?i:t;h=p?h:k;k=L>>31;p=i;s=k^I;t=s-k|0;k=(k^L)-((k>>>0>s>>>0)+k|0)|0;i=(h|0)==(k|0)&i>>>0>t>>>0|h>>>0>k>>>0;i=mi(-1,2147483647,i?p:t,i?h:k);h=_;if((h|0)==(e|0)&f>>>0>i>>>0|e>>>0>h>>>0){break f}i=1;f=0;k=li(ki(y,x,B,J),_,q,r);h=k+w|0;e=_+O|0;e=h>>>0<k>>>0?e+1|0:e;k=j-h|0;e=U-((h>>>0>j>>>0)+e|0)|0;k=ki(k,e,k,e);w=_;h=li(ki(y,x,E,K),_,q,r);j=h+C|0;e=_+P|0;e=h>>>0>j>>>0?e+1|0:e;h=g-j|0;e=V-((g>>>0<j>>>0)+e|0)|0;j=ki(h,e,h,e);e=j+k|0;h=_+w|0;h=e>>>0<j>>>0?h+1|0:h;k=e;g=li(ki(y,x,I,L),_,q,r);j=g+H|0;e=_+Q|0;e=g>>>0>j>>>0?e+1|0:e;g=m-j|0;e=W-((j>>>0>m>>>0)+e|0)|0;g=ki(g,e,g,e);j=g+k|0;e=_+h|0;j=ki(j,g>>>0>j>>>0?e+1|0:e,q,r);e=_;m=e;if(!e&j>>>0<=1){break i}h=j;g=m;while(1){e=f<<1|i>>>31;i=i<<1;f=e;k=!g&h>>>0>7|(g|0)!=0;h=(g&3)<<30|h>>>2;g=g>>>2|0;if(k){continue}break}break h}g=o;if((d|0)>(f|0)){e=f<<1;}else {if((d|0)<=0){F[o+8>>2]=0;F[o+12>>2]=0;break j}e=(d<<1)-2|0;}e=(e<<2)+c|0;F[g+8>>2]=F[e>>2];F[o+12>>2]=F[e+4>>2];}n=1;break f}f=m;i=j;if(j-1|0){break g}}while(1){e=mi(j,m,i,f);h=f+_|0;e=e+i|0;h=e>>>0<i>>>0?h+1|0:h;i=(h&1)<<31|e>>>1;f=h>>>1|0;e=ki(i,f,i,f);g=_;if((m|0)==(g|0)&e>>>0>j>>>0|g>>>0>m>>>0){continue}break}}e=F[o+20>>2];if(!e){break f}j=e-1|0;m=F[F[o+16>>2]+(j>>>3&536870908)>>2];F[o+20>>2]=j;n=1;e=ki(y,x,z,u);h=_;g=e;e=ki(q,r,M,T);g=g+e|0;h=_+h|0;h=e>>>0>g>>>0?h+1|0:h;e=ki(i,f,A,X);j=m>>>j&1;m=j?0-e|0:e;g=m+g|0;k=h;h=_;k=k+(j?0-(h+((e|0)!=0)|0)|0:h)|0;ba=o,ca=li(g,g>>>0<m>>>0?k+1|0:k,q,r),F[ba+12>>2]=ca;e=ki(y,x,A,X);m=_;g=e;e=ki(q,r,R,S);g=g+e|0;h=_+m|0;h=e>>>0>g>>>0?h+1|0:h;e=ki(i,f,z,u);f=0-e|0;i=_;k=(j?i:0-(((e|0)!=0)+i|0)|0)+h|0;i=g;g=j?e:f;f=i+g|0;ba=o,ca=li(f,f>>>0<g>>>0?k+1|0:k,q,r),F[ba+8>>2]=ca;}Z=l+80|0;e=n;break d}ta();v();}j=e;if(!e){return 0}l:{if(F[a+8>>2]<=0){break l}i=F[N>>2];e=0;while(1){f=e<<2;g=F[f+aa>>2];m=F[a+16>>2];m:{if((g|0)>(m|0)){F[f+i>>2]=m;break m}f=f+i|0;m=F[a+12>>2];if((m|0)>(g|0)){F[f>>2]=m;break m}F[f>>2]=g;}e=e+1|0;g=F[a+8>>2];if((e|0)<(g|0)){continue}break}f=0;if((g|0)<=0){break l}e=d<<3;m=e+c|0;n=b+e|0;while(1){g=f<<2;e=g+m|0;g=F[g+n>>2]+F[g+i>>2]|0;F[e>>2]=g;n:{if((g|0)>F[a+16>>2]){g=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break n}g=g+F[a+20>>2]|0;}F[e>>2]=g;}f=f+1|0;if((f|0)<F[a+8>>2]){continue}break}}d=d+1|0;if(($|0)!=(d|0)){continue}break}}return j|0}ta();v();}function hi(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,E=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,$=0,aa=0,ba=0,ca=0;a:{b:{if((e|0)!=2){break b}F[a+8>>2]=2;F[a- -64>>2]=f;N=a+32|0;e=F[N>>2];d=F[a+36>>2]-e|0;c:{if(d>>>0<=7){qa(N,2-(d>>>2|0)|0);break c}if((d|0)==8){break c}F[a+36>>2]=e+8;}o=1;d=F[a+56>>2];d=F[d+4>>2]-F[d>>2]|0;if((d|0)<=0){break b}n=a+60|0;d=d>>>2|0;$=d>>>0<=1?1:d;aa=a+68|0;d=0;while(1){e=F[a+56>>2];i=F[e>>2];if(F[e+4>>2]-i>>2>>>0<=d>>>0){break a}l=Z-80|0;Z=l;f=-1;i=F[i+(d<<2)>>2];e=-1;d:{if((i|0)==-1){break d}e=i+1|0;f=(e>>>0)%3|0?e:i-2|0;e=i-1|0;if((i>>>0)%3|0){break d}e=i+2|0;}g=F[n+36>>2];i=F[g>>2];e:{f:{g:{h:{i:{g=F[g+4>>2]-i>>2;k=f<<2;f=F[F[n+32>>2]+28>>2];j=F[k+f>>2];if(g>>>0<=j>>>0){break i}e=F[f+(e<<2)>>2];if(e>>>0>=g>>>0){break i}f=F[i+(j<<2)>>2];j:{k:{j=F[i+(e<<2)>>2];if((d|0)<=(f|0)|(j|0)>=(d|0)){break k}i=(j<<3)+c|0;u=F[i+4>>2];g=(f<<3)+c|0;e=F[g+4>>2];A=F[i>>2];i=F[g>>2];if(!((A|0)!=(i|0)|(e|0)!=(u|0))){F[n+8>>2]=i;F[n+12>>2]=e;break j}o=F[F[n+4>>2]+(d<<2)>>2];F[l+72>>2]=0;F[l+76>>2]=0;g=l- -64|0;F[g>>2]=0;F[g+4>>2]=0;F[l+56>>2]=0;F[l+60>>2]=0;g=F[n>>2];if(!G[g+84|0]){o=F[F[g+68>>2]+(o<<2)>>2];}Ga(g,o,D[g+24|0],l+56|0);o=F[F[n+4>>2]+(f<<2)>>2];F[l+48>>2]=0;F[l+52>>2]=0;F[l+40>>2]=0;F[l+44>>2]=0;F[l+32>>2]=0;F[l+36>>2]=0;g=F[n>>2];if(!G[g+84|0]){o=F[F[g+68>>2]+(o<<2)>>2];}Ga(g,o,D[g+24|0],l+32|0);o=F[F[n+4>>2]+(j<<2)>>2];F[l+24>>2]=0;F[l+28>>2]=0;F[l+16>>2]=0;F[l+20>>2]=0;F[l+8>>2]=0;F[l+12>>2]=0;g=F[n>>2];if(!G[g+84|0]){o=F[F[g+68>>2]+(o<<2)>>2];}Ga(g,o,D[g+24|0],l+8|0);g=F[l+16>>2];w=F[l+40>>2];B=g-w|0;O=F[l+44>>2];g=F[l+20>>2]-(O+(g>>>0<w>>>0)|0)|0;J=g;j=ki(B,g,B,g);m=_;g=F[l+8>>2];C=F[l+32>>2];E=g-C|0;P=F[l+36>>2];g=F[l+12>>2]-(P+(g>>>0<C>>>0)|0)|0;K=g;k=j;j=ki(E,g,E,g);g=k+j|0;k=_+m|0;k=g>>>0<j>>>0?k+1|0:k;j=F[l+24>>2];H=F[l+48>>2];I=j-H|0;Q=F[l+52>>2];j=F[l+28>>2]-(Q+(j>>>0<H>>>0)|0)|0;L=j;h=g;g=ki(I,j,I,j);q=h+g|0;h=_+k|0;r=g>>>0>q>>>0?h+1|0:h;if(!(r|q)){break k}o=0;x=mi(-1,2147483647,q,r);f=i>>31;S=f;h=f>>31;R=i;g=h;m=i^g;i=m-g|0;f=(f^g)-((g>>>0>m>>>0)+g|0)|0;g=f;f=e>>31;T=f;M=e;e=f>>31;m=M^e;h=m-e|0;k=f>>31;e=(k^f)-((e>>>0>m>>>0)+k|0)|0;f=(g|0)==(e|0)&h>>>0<i>>>0|e>>>0<g>>>0;i=f?i:h;j=_;e=f?g:e;if((j|0)==(e|0)&i>>>0>x>>>0|e>>>0>j>>>0){break e}i=F[l+64>>2];U=F[l+68>>2];e=ki(i-w|0,U-((i>>>0<w>>>0)+O|0)|0,B,J);f=_;g=F[l+56>>2];V=F[l+60>>2];j=ki(g-C|0,V-((g>>>0<C>>>0)+P|0)|0,E,K);e=j+e|0;h=_+f|0;m=F[l+72>>2];W=F[l+76>>2];f=ki(m-H|0,W-((m>>>0<H>>>0)+Q|0)|0,I,L);y=f+e|0;e=_+(e>>>0<j>>>0?h+1|0:h)|0;e=f>>>0>y>>>0?e+1|0:e;x=e;f=e;e=e>>31;j=e;h=e^y;e=h-e|0;j=(f^j)-((h>>>0<j>>>0)+j|0)|0;f=A;A=f-R|0;f=(f>>31)-((f>>>0<R>>>0)+S|0)|0;X=f;z=f>>31;p=z^A;k=p-z|0;h=f>>31;f=(h^f)-((p>>>0<z>>>0)+h|0)|0;p=f;z=u-M|0;f=(u>>31)-((u>>>0<M>>>0)+T|0)|0;u=f;s=f>>31;t=s^z;Y=t-s|0;h=f>>31;f=(h^f)-((s>>>0>t>>>0)+h|0)|0;h=(p|0)==(f|0)&k>>>0>Y>>>0|f>>>0<p>>>0;f=mi(-1,2147483647,h?k:Y,h?p:f);h=_;if((h|0)==(j|0)&e>>>0>f>>>0|h>>>0<j>>>0){break e}f=e;e=j;h=K>>31;p=h^E;j=p-h|0;h=(h^K)-((h>>>0>p>>>0)+h|0)|0;k=J>>31;s=k^B;t=s-k|0;k=(k^J)-((k>>>0>s>>>0)+k|0)|0;p=(h|0)==(k|0)&j>>>0>t>>>0|h>>>0>k>>>0;j=p?j:t;h=p?h:k;k=L>>31;p=j;s=k^I;t=s-k|0;k=(k^L)-((k>>>0>s>>>0)+k|0)|0;j=(h|0)==(k|0)&j>>>0>t>>>0|h>>>0>k>>>0;j=mi(-1,2147483647,j?p:t,j?h:k);h=_;if((h|0)==(e|0)&f>>>0>j>>>0|e>>>0>h>>>0){break e}j=1;f=0;k=li(ki(y,x,B,J),_,q,r);h=k+w|0;e=_+O|0;e=h>>>0<k>>>0?e+1|0:e;k=i-h|0;e=U-((h>>>0>i>>>0)+e|0)|0;k=ki(k,e,k,e);w=_;h=li(ki(y,x,E,K),_,q,r);i=h+C|0;e=_+P|0;e=h>>>0>i>>>0?e+1|0:e;h=g-i|0;e=V-((g>>>0<i>>>0)+e|0)|0;i=ki(h,e,h,e);e=i+k|0;h=_+w|0;h=e>>>0<i>>>0?h+1|0:h;k=e;g=li(ki(y,x,I,L),_,q,r);i=g+H|0;e=_+Q|0;e=g>>>0>i>>>0?e+1|0:e;g=m-i|0;e=W-((i>>>0>m>>>0)+e|0)|0;g=ki(g,e,g,e);i=g+k|0;e=_+h|0;i=ki(i,g>>>0>i>>>0?e+1|0:e,q,r);e=_;m=e;if(!e&i>>>0<=1){break h}h=i;g=m;while(1){e=f<<1|j>>>31;j=j<<1;f=e;k=!g&h>>>0>7|(g|0)!=0;h=(g&3)<<30|h>>>2;g=g>>>2|0;if(k){continue}break}break g}g=n;if((d|0)>(f|0)){e=f<<1;}else {if((d|0)<=0){F[n+8>>2]=0;F[n+12>>2]=0;break j}e=(d<<1)-2|0;}e=(e<<2)+c|0;F[g+8>>2]=F[e>>2];F[n+12>>2]=F[e+4>>2];}o=1;break e}ta();v();}f=m;j=i;if(i-1|0){break f}}while(1){e=mi(i,m,j,f);h=f+_|0;e=e+j|0;h=e>>>0<j>>>0?h+1|0:h;j=(h&1)<<31|e>>>1;f=h>>>1|0;e=ki(j,f,j,f);g=_;if((m|0)==(g|0)&e>>>0>i>>>0|g>>>0>m>>>0){continue}break}}e=F[n+20>>2];if(!e){break e}i=e-1|0;m=F[F[n+16>>2]+(i>>>3&536870908)>>2];F[n+20>>2]=i;o=1;e=ki(y,x,z,u);h=_;g=e;e=ki(q,r,M,T);g=g+e|0;h=_+h|0;h=e>>>0>g>>>0?h+1|0:h;e=ki(j,f,A,X);i=m>>>i&1;m=i?0-e|0:e;g=m+g|0;k=h;h=_;k=k+(i?0-(h+((e|0)!=0)|0)|0:h)|0;ba=n,ca=li(g,g>>>0<m>>>0?k+1|0:k,q,r),F[ba+12>>2]=ca;e=ki(y,x,A,X);m=_;g=e;e=ki(q,r,R,S);g=g+e|0;h=_+m|0;h=e>>>0>g>>>0?h+1|0:h;e=ki(j,f,z,u);f=0-e|0;j=_;k=(i?j:0-(((e|0)!=0)+j|0)|0)+h|0;j=g;g=i?e:f;f=j+g|0;ba=n,ca=li(f,f>>>0<g>>>0?k+1|0:k,q,r),F[ba+8>>2]=ca;}Z=l+80|0;if(!o){return 0}l:{if(F[a+8>>2]<=0){break l}g=F[N>>2];e=0;while(1){f=e<<2;i=F[f+aa>>2];j=F[a+16>>2];m:{if((i|0)>(j|0)){F[f+g>>2]=j;break m}f=f+g|0;j=F[a+12>>2];if((j|0)>(i|0)){F[f>>2]=j;break m}F[f>>2]=i;}e=e+1|0;i=F[a+8>>2];if((e|0)<(i|0)){continue}break}f=0;if((i|0)<=0){break l}e=d<<3;j=e+c|0;m=b+e|0;while(1){i=f<<2;e=i+j|0;i=F[i+m>>2]+F[g+i>>2]|0;F[e>>2]=i;n:{if((i|0)>F[a+16>>2]){k=i-F[a+20>>2]|0;}else {if((i|0)>=F[a+12>>2]){break n}k=i+F[a+20>>2]|0;}F[e>>2]=k;}f=f+1|0;if((f|0)<F[a+8>>2]){continue}break}}d=d+1|0;if(($|0)!=(d|0)){continue}break}}return o|0}ta();v();}function Gd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;n=Z-96|0;Z=n;m=F[a+4>>2];d=F[m+32>>2];j=F[d+8>>2];i=F[d+12>>2];e=i;c=F[d+20>>2];f=F[d+16>>2];a:{if((e|0)<=(c|0)&f>>>0>=j>>>0|(c|0)>(e|0)){break a}o=F[d>>2];h=G[o+f|0];g=f+1|0;e=g?c:c+1|0;F[d+16>>2]=g;F[d+20>>2]=e;if((e|0)>=(i|0)&g>>>0>=j>>>0|(e|0)>(i|0)){break a}p=G[g+o|0];g=f+2|0;e=g>>>0<2?c+1|0:c;F[d+16>>2]=g;F[d+20>>2]=e;l=h<<24>>24;b:{if((l|0)>=0){k=F[a+216>>2];if(h>>>0>=(F[a+220>>2]-k|0)/144>>>0){break a}k=k+L(h,144)|0;if(F[k>>2]<0){break b}break a}if(F[a+212>>2]>=0){break a}k=a+212|0;}F[k>>2]=b;c:{d:{e:{f:{g:{h:{k=H[m+36>>1];i:{if(((k<<8|k>>>8)&65535)>>>0>=258){if((e|0)>=(i|0)&g>>>0>=j>>>0|(e|0)>(i|0)){break a}e=G[g+o|0];f=f+3|0;c=f>>>0<3?c+1|0:c;F[d+16>>2]=f;F[d+20>>2]=c;if(e>>>0>1){break a}d=e>>>0<2?e:0;if(!p){break i}if(!d){break h}break a}if(p){break g}d=0;}if((l|0)<0){e=a+184|0;}else {c=F[a+216>>2]+L(h,144)|0;D[c+100|0]=0;e=c+104|0;}if((d|0)!=1){break e}c=Z-112|0;Z=c;g=F[F[a+4>>2]+44>>2];d=ka(120);F[d>>2]=8924;F[d+4>>2]=0;F[d+116>>2]=0;F[d+112>>2]=e;F[d+108>>2]=g;F[d+12>>2]=0;F[d+16>>2]=0;F[d+20>>2]=0;F[d+24>>2]=0;F[d+28>>2]=0;F[d+32>>2]=0;F[d+36>>2]=0;F[d+40>>2]=0;F[d+44>>2]=0;F[d+48>>2]=0;F[d+52>>2]=0;F[d+56>>2]=0;F[d+60>>2]=0;F[d+8>>2]=9136;f=d- -64|0;F[f>>2]=0;F[f+4>>2]=0;F[d+72>>2]=0;F[d+76>>2]=0;F[d+80>>2]=0;F[d+84>>2]=0;F[d+88>>2]=0;F[d+104>>2]=0;F[d+96>>2]=0;F[d+100>>2]=0;f=F[a+8>>2];F[c+48>>2]=0;F[c+52>>2]=0;F[c+40>>2]=0;F[c+44>>2]=0;j=c+32|0;F[j>>2]=0;F[j+4>>2]=0;F[c+24>>2]=0;F[c+28>>2]=0;h=c- -64|0;F[h>>2]=0;F[h+4>>2]=0;F[c+72>>2]=0;F[c+76>>2]=0;F[c+80>>2]=0;F[c+84>>2]=0;F[c+88>>2]=0;F[c+104>>2]=0;F[c+16>>2]=0;F[c+20>>2]=0;F[c+56>>2]=0;F[c+60>>2]=0;F[c+8>>2]=9136;F[c+96>>2]=0;F[c+100>>2]=0;F[c+12>>2]=f;h=F[f>>2];i=F[f+4>>2];D[c+111|0]=0;k=j;j=c+111|0;Ea(k,(i-h>>2>>>0)/3|0,j);h=F[c+12>>2];i=F[h+28>>2];h=F[h+24>>2];D[c+111|0]=0;Ea(c+44|0,i-h>>2,j);F[c+28>>2]=d;F[c+24>>2]=g;F[c+20>>2]=e;F[c+16>>2]=f;f=d+8|0;e=c+8|0;lc(f,e);j:{if((e|0)==(f|0)){F[d+92>>2]=F[e+84>>2];break j}gb(d+56|0,F[e+48>>2],F[e+52>>2]);gb(d+68|0,F[e+60>>2],F[e- -64>>2]);gb(d+80|0,F[e+72>>2],F[e+76>>2]);F[d+92>>2]=F[e+84>>2];k:{h=F[e+92>>2];j=F[e+88>>2];i=h-j|0;e=i>>2;f=F[d+104>>2];g=F[d+96>>2];if(e>>>0<=f-g>>2>>>0){i=F[d+100>>2]-g|0;f=i+j|0;m=i>>2;i=e>>>0>m>>>0?f:h;l=i-j|0;if((i|0)!=(j|0)){pa(g,j,l);}if(e>>>0>m>>>0){e=F[d+100>>2];if((h|0)!=(i|0)){while(1){F[e>>2]=F[f>>2];e=e+4|0;f=f+4|0;if((h|0)!=(f|0)){continue}break}}F[d+100>>2]=e;break k}F[d+100>>2]=g+l;break k}if(g){F[d+100>>2]=g;ja(g);F[d+104>>2]=0;F[d+96>>2]=0;F[d+100>>2]=0;f=0;}l:{if((i|0)<0){break l}g=f>>>1|0;e=f>>>0>=2147483644?1073741823:e>>>0<g>>>0?g:e;if(e>>>0>=1073741824){break l}f=e<<2;e=ka(f);F[d+96>>2]=e;F[d+104>>2]=e+f;if((h|0)!=(j|0)){f=e;e=(i-4&-4)+4|0;e=la(f,j,e)+e|0;}F[d+100>>2]=e;break k}na();v();}}F[c+8>>2]=9136;e=F[c+96>>2];if(e){F[c+100>>2]=e;ja(e);}e=F[c+80>>2];if(e){F[c+84>>2]=e;ja(e);}e=F[c+68>>2];if(e){F[c+72>>2]=e;ja(e);}e=F[c+56>>2];if(e){F[c+60>>2]=e;ja(e);}F[c+8>>2]=9372;e=F[c+44>>2];if(e){ja(e);}e=F[c+32>>2];if(e){ja(e);}Z=c+112|0;break d}if((l|0)>=0){break f}break a}if((l|0)<0){break a}}e=F[a+216>>2];c=F[m+44>>2];d=ka(80);F[d>>2]=9684;F[d+4>>2]=0;F[d+76>>2]=0;F[d+68>>2]=c;F[d+8>>2]=8624;F[d+12>>2]=0;F[d+16>>2]=0;F[d+20>>2]=0;F[d+24>>2]=0;F[d+28>>2]=0;F[d+32>>2]=0;F[d+36>>2]=0;F[d+40>>2]=0;F[d+44>>2]=0;F[d+48>>2]=0;F[d+52>>2]=0;e=e+L(h,144)|0;f=e+104|0;F[d+72>>2]=f;F[d- -64>>2]=0;F[d+56>>2]=0;F[d+60>>2]=0;F[n+24>>2]=c;c=n;F[c+68>>2]=0;F[c+72>>2]=0;F[c+60>>2]=0;F[c+64>>2]=0;F[c+52>>2]=0;F[c+56>>2]=0;F[c+44>>2]=0;F[c+48>>2]=0;F[c+84>>2]=0;F[c+88>>2]=0;F[c+76>>2]=0;F[c+80>>2]=0;F[c+28>>2]=d;g=F[c+28>>2];F[c+8>>2]=F[c+24>>2];F[c+12>>2]=g;F[c+20>>2]=f;f=e+4|0;F[c+16>>2]=f;F[c+36>>2]=0;F[c+40>>2]=0;F[c+32>>2]=8624;e=F[c+20>>2];F[c>>2]=F[c+16>>2];F[c+4>>2]=e;e=c+32|0;Fd(e,f,c);c=d+8|0;lc(c,e);if((c|0)!=(e|0)){gb(d+56|0,F[e+48>>2],F[e+52>>2]);}Ed(e);break c}c=Z+-64|0;Z=c;g=F[F[a+4>>2]+44>>2];d=ka(80);F[d>>2]=9392;F[d+4>>2]=0;F[d+76>>2]=0;F[d+72>>2]=e;F[d+68>>2]=g;F[d+8>>2]=9556;F[d+12>>2]=0;F[d+16>>2]=0;F[d+20>>2]=0;F[d+24>>2]=0;F[d+28>>2]=0;F[d+32>>2]=0;F[d+36>>2]=0;F[d+40>>2]=0;F[d+44>>2]=0;F[d+48>>2]=0;F[d+52>>2]=0;F[d- -64>>2]=0;j=d+56|0;f=j;F[f>>2]=0;F[f+4>>2]=0;f=F[a+8>>2];F[c+40>>2]=0;F[c+44>>2]=0;F[c+32>>2]=0;F[c+36>>2]=0;h=c+24|0;F[h>>2]=0;F[h+4>>2]=0;F[c+16>>2]=0;F[c+20>>2]=0;F[c+56>>2]=0;F[c+8>>2]=0;F[c+12>>2]=0;F[c+48>>2]=0;F[c+52>>2]=0;F[c>>2]=9556;F[c+4>>2]=f;i=F[f>>2];l=F[f+4>>2];D[c+63|0]=0;k=h;h=c+63|0;Ea(k,(l-i>>2>>>0)/3|0,h);i=F[c+4>>2];l=F[i+28>>2];i=F[i+24>>2];D[c+63|0]=0;Ea(c+36|0,l-i>>2,h);F[c+20>>2]=d;F[c+16>>2]=g;F[c+12>>2]=e;F[c+8>>2]=f;lc(d+8|0,c);gb(j,F[c+48>>2],F[c+52>>2]);F[c>>2]=9556;e=F[c+48>>2];if(e){F[c+52>>2]=e;ja(e);}F[c>>2]=9372;e=F[c+36>>2];if(e){ja(e);}e=F[c+24>>2];if(e){ja(e);}Z=c- -64|0;}if(!d){break a}}d=yc(ka(64),d);c=F[a+4>>2];a=d;d=b;m:{n:{if((d|0)>=0){g=c+8|0;b=F[c+12>>2];j=F[c+8>>2];e=b-j>>2;o:{if((e|0)>(d|0)){break o}f=d+1|0;if(d>>>0>=e>>>0){Pb(g,f-e|0);break o}if(e>>>0<=f>>>0){break o}f=j+(f<<2)|0;if((f|0)!=(b|0)){while(1){b=b-4|0;e=F[b>>2];F[b>>2]=0;if(e){$[F[F[e>>2]+4>>2]](e);}if((b|0)!=(f|0)){continue}break}}F[c+12>>2]=f;}c=F[g>>2]+(d<<2)|0;b=F[c>>2];F[c>>2]=a;if(b){break n}break m}b=a;if(!a){break m}}$[F[F[b>>2]+4>>2]](b);}q=(d^-1)>>>31|0;}Z=n+96|0;return q|0}function Ab(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=M(0),n=M(0),o=0;a:{b:{if(!d){break b}c:{switch(F[a+28>>2]-1|0){case 0:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}E[(g<<1)+d>>1]=D[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}E[(g<<1)+d>>1]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}E[(g<<1)+d>>1]=H[b>>1];b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){return 0}e=E[b>>1];if((e|0)<0){break b}E[(g<<1)+d>>1]=e;b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=F[b>>2];if(e+32768>>>0>65535){break b}E[(g<<1)+d>>1]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=F[b>>2];if(e>>>0>32767){break b}E[(g<<1)+d>>1]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;k=F[e+4>>2];while(1){if(b>>>0>=k>>>0){break b}h=F[b+4>>2];e=F[b>>2];i=e+32768|0;h=i>>>0<32768?h+1|0:h;if(!h&i>>>0>65535|h){break b}E[(g<<1)+d>>1]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}k=F[b+4>>2];e=F[b>>2];if(!k&e>>>0>32767|k){break b}E[(g<<1)+d>>1]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 8:d:{e:{e=G[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break e}e=F[a>>2];j=F[e>>2];g=j;f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=F[e+4>>2];e=f-j|0;if(!G[a+32|0]){j=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=J[g>>2];if(m>=M(32767)|m<M(-32768)|m!=m){break d}n=M(N(m));if(n==M(Infinity)){break d}e=(b<<1)+d|0;if(n<M(2147483648)){i=~~m;}else {i=-2147483648;}E[e>>1]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}j=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=J[g>>2];if(m>=M(32767)|m<M(-32768)|(M(N(m))==M(Infinity)|m!=m)){break d}if(m<M(0)|m>M(1)){break d}e=(b<<1)+d|0;l=R(+m*32767+.5);f:{if(N(l)<2147483648){i=~~l;break f}i=-2147483648;}E[e>>1]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}j=1;if(c>>>0<=e>>>0){break d}ma((e<<1)+d|0,0,c-e<<1);}return j;case 9:g:{h:{e=G[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break h}e=F[a>>2];j=F[e>>2];g=j;f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=F[e+4>>2];e=f-j|0;if(!G[a+32|0]){j=0;if((b|0)>=(e|0)){break g}b=0;while(1){l=K[g>>3];if(l>=32767|l<-32768|l!=l){break g}o=N(l);if(o==Infinity){break g}e=(b<<1)+d|0;if(o<2147483648){i=~~l;}else {i=-2147483648;}E[e>>1]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}j=0;if((b|0)>=(e|0)){break g}b=0;while(1){l=K[g>>3];if(l>=32767|l<-32768|(N(l)==Infinity|l!=l)){break g}if(l<0|l>1){break g}e=(b<<1)+d|0;l=R(l*32767+.5);i:{if(N(l)<2147483648){i=~~l;break i}i=-2147483648;}E[e>>1]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}j=1;if(c>>>0<=e>>>0){break g}ma((e<<1)+d|0,0,c-e<<1);}return j;case 10:break c;default:break b}}e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}E[(g<<1)+d>>1]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}ma((e<<1)+d|0,0,(c&255)-e<<1);}return j}ma((e<<1)+d|0,0,(c&255)-e<<1);return 1}function yb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=M(0),n=M(0),o=0;a:{b:{if(!d){break b}c:{switch(F[a+28>>2]-1|0){case 0:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=D[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=E[b>>1];b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=H[b>>1];b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=F[b>>2];b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){return 0}e=F[b>>2];if((e|0)<0){break b}F[(g<<2)+d>>2]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;k=F[e+4>>2];while(1){if(b>>>0>=k>>>0){break b}h=F[b+4>>2];e=F[b>>2];if(e- -2147483648>>>0<2147483648?h+1|0:h){break b}F[(g<<2)+d>>2]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}k=F[b+4>>2];e=F[b>>2];if(!k&e>>>0>2147483647|k){break b}F[(g<<2)+d>>2]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}break a;case 8:d:{e:{e=G[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break e}e=F[a>>2];j=F[e>>2];g=j;f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=F[e+4>>2];e=f-j|0;if(!G[a+32|0]){j=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=J[g>>2];if(m>=M(2147483648)|m<M(-2147483648)|m!=m){break d}n=M(N(m));if(n==M(Infinity)){break d}e=(b<<2)+d|0;if(n<M(2147483648)){i=~~m;}else {i=-2147483648;}F[e>>2]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}j=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=J[g>>2];if(m>=M(2147483648)|m<M(-2147483648)|(M(N(m))==M(Infinity)|m!=m)){break d}if(m<M(0)|m>M(1)){break d}e=(b<<2)+d|0;l=R(+m*2147483647+.5);f:{if(N(l)<2147483648){i=~~l;break f}i=-2147483648;}F[e>>2]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}j=1;if(c>>>0<=e>>>0){break d}ma((e<<2)+d|0,0,c-e<<2);}return j;case 9:g:{h:{e=G[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break h}e=F[a>>2];j=F[e>>2];g=j;f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=F[e+4>>2];e=f-j|0;if(!G[a+32|0]){j=0;if((b|0)>=(e|0)){break g}b=0;while(1){l=K[g>>3];if(l>=2147483647|l<-2147483648|l!=l){break g}o=N(l);if(o==Infinity){break g}e=(b<<2)+d|0;if(o<2147483648){i=~~l;}else {i=-2147483648;}F[e>>2]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}j=0;if((b|0)>=(e|0)){break g}b=0;while(1){l=K[g>>3];if(l>=2147483647|l<-2147483648|(N(l)==Infinity|l!=l)){break g}if(l<0|l>1){break g}e=(b<<2)+d|0;l=R(l*2147483647+.5);i:{if(N(l)<2147483648){i=~~l;break i}i=-2147483648;}F[e>>2]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}j=1;if(c>>>0<=e>>>0){break g}ma((e<<2)+d|0,0,c-e<<2);}return j;case 10:break c;default:break b}}e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}j=1;if(e>>>0>=f>>>0){break b}ma((e<<2)+d|0,0,(c&255)-e<<2);}return j}ma((e<<2)+d|0,0,(c&255)-e<<2);return 1}function zb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=M(0);a:{b:{if(!d){break b}c:{switch(F[a+28>>2]-1|0){case 0:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){return 0}e=D[b|0];if((e|0)<0){break b}E[(g<<1)+d>>1]=e&255;b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}E[(g<<1)+d>>1]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){return 0}e=E[b>>1];if((e|0)<0){break b}E[(g<<1)+d>>1]=e;b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}E[(g<<1)+d>>1]=H[b>>1];b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=F[b>>2];if(e>>>0>65535){break b}E[(g<<1)+d>>1]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=F[b>>2];if(e>>>0>65535){break b}E[(g<<1)+d>>1]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}k=F[b+4>>2];e=F[b>>2];if(!k&e>>>0>65535|k){break b}E[(g<<1)+d>>1]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}k=F[b+4>>2];e=F[b>>2];if(!k&e>>>0>65535|k){break b}E[(g<<1)+d>>1]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}break a;case 8:d:{e:{e=G[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break e}e=F[a>>2];l=F[e>>2];g=l;f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=F[e+4>>2];e=f-l|0;if(!G[a+32|0]){l=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=J[g>>2];if(m>=M(65535)|m<M(0)|(M(N(m))==M(Infinity)|m!=m)){break d}e=(b<<1)+d|0;if(m<M(4294967296)&m>=M(0)){i=~~m>>>0;}else {i=0;}E[e>>1]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}l=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=J[g>>2];if(m>=M(65535)|m<M(0)|(M(N(m))==M(Infinity)|m!=m)){break d}if(m>M(1)){break d}e=(b<<1)+d|0;j=R(+m*65535+.5);f:{if(j<4294967296&j>=0){i=~~j>>>0;break f}i=0;}E[e>>1]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}l=1;if(c>>>0<=e>>>0){break d}ma((e<<1)+d|0,0,c-e<<1);}return l;case 9:g:{h:{e=G[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break h}e=F[a>>2];l=F[e>>2];g=l;f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=F[e+4>>2];e=f-l|0;if(!G[a+32|0]){l=0;if((b|0)>=(e|0)){break g}b=0;while(1){j=K[g>>3];if(j>=65535|j<0|(N(j)==Infinity|j!=j)){break g}e=(b<<1)+d|0;if(j<4294967296&j>=0){i=~~j>>>0;}else {i=0;}E[e>>1]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}l=0;if((b|0)>=(e|0)){break g}b=0;while(1){j=K[g>>3];if(j>=65535|j<0|(N(j)==Infinity|j!=j)){break g}if(j>1){break g}e=(b<<1)+d|0;j=R(j*65535+.5);i:{if(j<4294967296&j>=0){i=~~j>>>0;break i}i=0;}E[e>>1]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}l=1;if(c>>>0<=e>>>0){break g}ma((e<<1)+d|0,0,c-e<<1);}return l;case 10:break c;default:break b}}e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];k=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+k|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}E[(g<<1)+d>>1]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break b}ma((e<<1)+d|0,0,(c&255)-e<<1);}return l}ma((e<<1)+d|0,0,(c&255)-e<<1);return 1}function Ga(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=M(0),l=0,m=0,n=M(0),o=0;a:{if(!d){break a}b:{c:{switch(F[a+28>>2]-1|0){case 0:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g<<3)+d|0;i=D[b|0];F[e>>2]=i;F[e+4>>2]=i>>31;b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 1:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g<<3)+d|0;F[e>>2]=G[b|0];F[e+4>>2]=0;b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 2:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g<<3)+d|0;i=E[b>>1];F[e>>2]=i;F[e+4>>2]=i>>31;b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 3:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g<<3)+d|0;F[e>>2]=H[b>>1];F[e+4>>2]=0;b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 4:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g<<3)+d|0;i=F[b>>2];F[e>>2]=i;F[e+4>>2]=i>>31;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 5:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g<<3)+d|0;F[e>>2]=F[b>>2];F[e+4>>2]=0;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 6:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}i=F[b+4>>2];e=(g<<3)+d|0;F[e>>2]=F[b>>2];F[e+4>>2]=i;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 7:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=F[b>>2];i=F[b+4>>2];if((i|0)<0){break a}j=(g<<3)+d|0;F[j>>2]=e;F[j+4>>2]=i;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 8:d:{e=G[a+24|0];f=c&255;if(!(e>>>0<f>>>0?e:f)){break d}if(G[a+32|0]){break a}e=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+e|0;e=F[a>>2];i=F[e+4>>2];e=F[e>>2];if((b|0)>=(i-e|0)){break a}g=b+e|0;h=c&255;b=0;while(1){k=J[g>>2];if(k>=M(0x8000000000000000)|k<M(-0x8000000000000000)|k!=k){break a}n=M(N(k));if(n==M(Infinity)){break a}e=(b<<3)+d|0;e:{if(n<M(0x8000000000000000)){j=M(N(k))>=M(1)?~~(k>M(0)?M(P(M(R(M(k*M(2.3283064365386963e-10)))),M(4294967296))):M(S(M(M(k-M(~~k>>>0>>>0))*M(2.3283064365386963e-10)))))>>>0:0;m=~~k>>>0;break e}j=-2147483648;m=0;}F[e>>2]=m;F[e+4>>2]=j;b=b+1|0;e=G[a+24|0];if(b>>>0>=(e>>>0<h>>>0?e:h)>>>0){break d}g=g+4|0;if(i>>>0>g>>>0){continue}break}break a}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 9:f:{e=G[a+24|0];f=c&255;if(!(e>>>0<f>>>0?e:f)){break f}if(G[a+32|0]){break a}e=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+e|0;e=F[a>>2];i=F[e+4>>2];e=F[e>>2];if((b|0)>=(i-e|0)){break a}g=b+e|0;h=c&255;b=0;while(1){l=K[g>>3];if(l>=0x8000000000000000|l<-0x8000000000000000|l!=l){break a}o=N(l);if(o==Infinity){break a}e=(b<<3)+d|0;g:{if(o<0x8000000000000000){j=N(l)>=1?~~(l>0?P(R(l*2.3283064365386963e-10),4294967295):S((l-+(~~l>>>0>>>0))*2.3283064365386963e-10))>>>0:0;m=~~l>>>0;break g}j=-2147483648;m=0;}F[e>>2]=m;F[e+4>>2]=j;b=b+1|0;e=G[a+24|0];if(b>>>0>=(e>>>0<h>>>0?e:h)>>>0){break f}g=g+8|0;if(i>>>0>g>>>0){continue}break}break a}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;break b;case 10:break c;default:break a}}e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);j=b;b=b+i|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break a}e=(g<<3)+d|0;F[e>>2]=G[b|0];F[e+4>>2]=0;b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}if(e>>>0>=f>>>0){break a}d=(e<<3)+d|0;a=(c&255)-e|0;}ma(d,0,a<<3);}}function le(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;j=a;a:{b:{c:{d:{e:{f:{g:{h:{a=F[a+8>>2];switch(F[a+28>>2]-1|0){case 4:break c;case 5:break d;case 2:break e;case 3:break f;case 0:break g;case 1:break h;default:break a}}f=G[a+24|0];c=ka(f);a=F[j+16>>2];if(F[a+80>>2]){g=F[F[a>>2]>>2]+F[a+48>>2]|0;}else {g=0;}if(!b){break b}if(f){o=f&252;l=f&3;h=f>>>0<4;while(1){a=0;e=0;if(!h){while(1){k=g+(d<<2)|0;D[a+c|0]=F[k>>2];D[(a|1)+c|0]=F[k+4>>2];D[(a|2)+c|0]=F[k+8>>2];D[(a|3)+c|0]=F[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){D[a+c|0]=F[g+(d<<2)>>2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}la(F[F[F[j+8>>2]+64>>2]>>2]+m|0,c,f);m=f+m|0;n=n+1|0;if((n|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,f);a=a+f|0;la(a+F[F[F[j+8>>2]+64>>2]>>2]|0,c,f);a=a+f|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,f);break b}f=G[a+24|0];c=ka(f);a=F[j+16>>2];if(F[a+80>>2]){g=F[F[a>>2]>>2]+F[a+48>>2]|0;}else {g=0;}if(!b){break b}if(f){o=f&252;l=f&3;h=f>>>0<4;while(1){a=0;e=0;if(!h){while(1){k=g+(d<<2)|0;D[a+c|0]=F[k>>2];D[(a|1)+c|0]=F[k+4>>2];D[(a|2)+c|0]=F[k+8>>2];D[(a|3)+c|0]=F[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){D[a+c|0]=F[g+(d<<2)>>2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}la(F[F[F[j+8>>2]+64>>2]>>2]+m|0,c,f);m=f+m|0;n=n+1|0;if((n|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,f);a=a+f|0;la(a+F[F[F[j+8>>2]+64>>2]>>2]|0,c,f);a=a+f|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,f);break b}h=G[a+24|0];i=h<<1;c=ka(i);a=F[j+16>>2];if(F[a+80>>2]){g=F[F[a>>2]>>2]+F[a+48>>2]|0;}else {g=0;}if(!b){break b}if(h){o=h&252;l=h&3;h=h>>>0<4;while(1){a=0;e=0;if(!h){while(1){f=a<<1;k=g+(d<<2)|0;E[f+c>>1]=F[k>>2];E[(f|2)+c>>1]=F[k+4>>2];E[(f|4)+c>>1]=F[k+8>>2];E[(f|6)+c>>1]=F[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){E[(a<<1)+c>>1]=F[g+(d<<2)>>2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}la(F[F[F[j+8>>2]+64>>2]>>2]+n|0,c,i);n=i+n|0;m=m+1|0;if((m|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,i);a=a+i|0;la(a+F[F[F[j+8>>2]+64>>2]>>2]|0,c,i);a=a+i|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,i);break b}h=G[a+24|0];i=h<<1;c=ka(i);a=F[j+16>>2];if(F[a+80>>2]){g=F[F[a>>2]>>2]+F[a+48>>2]|0;}else {g=0;}if(!b){break b}if(h){o=h&252;l=h&3;h=h>>>0<4;while(1){a=0;e=0;if(!h){while(1){f=a<<1;k=g+(d<<2)|0;E[f+c>>1]=F[k>>2];E[(f|2)+c>>1]=F[k+4>>2];E[(f|4)+c>>1]=F[k+8>>2];E[(f|6)+c>>1]=F[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){E[(a<<1)+c>>1]=F[g+(d<<2)>>2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}la(F[F[F[j+8>>2]+64>>2]>>2]+n|0,c,i);n=i+n|0;m=m+1|0;if((m|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,i);a=a+i|0;la(a+F[F[F[j+8>>2]+64>>2]>>2]|0,c,i);a=a+i|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,i);break b}h=G[a+24|0];i=h<<2;c=ka(i);a=F[j+16>>2];if(F[a+80>>2]){g=F[F[a>>2]>>2]+F[a+48>>2]|0;}else {g=0;}if(!b){break b}if(h){o=h&252;l=h&3;h=h>>>0<4;while(1){a=0;e=0;if(!h){while(1){f=a<<2;k=g+(d<<2)|0;F[f+c>>2]=F[k>>2];F[(f|4)+c>>2]=F[k+4>>2];F[(f|8)+c>>2]=F[k+8>>2];F[(f|12)+c>>2]=F[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){F[(a<<2)+c>>2]=F[g+(d<<2)>>2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}la(F[F[F[j+8>>2]+64>>2]>>2]+n|0,c,i);n=i+n|0;m=m+1|0;if((m|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,i);a=a+i|0;la(a+F[F[F[j+8>>2]+64>>2]>>2]|0,c,i);a=a+i|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,i);break b}h=G[a+24|0];i=h<<2;c=ka(i);a=F[j+16>>2];if(F[a+80>>2]){g=F[F[a>>2]>>2]+F[a+48>>2]|0;}else {g=0;}if(!b){break b}if(h){o=h&252;l=h&3;h=h>>>0<4;while(1){a=0;e=0;if(!h){while(1){f=a<<2;k=g+(d<<2)|0;F[f+c>>2]=F[k>>2];F[(f|4)+c>>2]=F[k+4>>2];F[(f|8)+c>>2]=F[k+8>>2];F[(f|12)+c>>2]=F[k+12>>2];a=a+4|0;d=d+4|0;e=e+4|0;if((o|0)!=(e|0)){continue}break}}e=0;if(l){while(1){F[(a<<2)+c>>2]=F[g+(d<<2)>>2];a=a+1|0;d=d+1|0;e=e+1|0;if((l|0)!=(e|0)){continue}break}}la(F[F[F[j+8>>2]+64>>2]>>2]+n|0,c,i);n=i+n|0;m=m+1|0;if((m|0)!=(b|0)){continue}break}break b}a=0;if((b|0)!=1){g=b&-2;while(1){la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,i);a=a+i|0;la(a+F[F[F[j+8>>2]+64>>2]>>2]|0,c,i);a=a+i|0;d=d+2|0;if((g|0)!=(d|0)){continue}break}}if(!(b&1)){break b}la(F[F[F[j+8>>2]+64>>2]>>2]+a|0,c,i);}ja(c);c=1;}return c|0}function xb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=M(0);a:{b:{if(!d){break b}c:{switch(F[a+28>>2]-1|0){case 0:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=D[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=E[b>>1];b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=H[b>>1];b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=F[b>>2];b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=F[b>>2];b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=F[b>>2];if(F[b+4>>2]){break b}F[(g<<2)+d>>2]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}e=F[b>>2];if(F[b+4>>2]){break b}F[(g<<2)+d>>2]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 8:d:{e:{e=G[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break e}e=F[a>>2];k=F[e>>2];g=k;f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=F[e+4>>2];e=f-k|0;if(!G[a+32|0]){k=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=J[g>>2];if(m>=M(4294967296)|m<M(0)|(M(N(m))==M(Infinity)|m!=m)){break d}e=(b<<2)+d|0;if(m<M(4294967296)&m>=M(0)){i=~~m>>>0;}else {i=0;}F[e>>2]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}k=0;if((b|0)>=(e|0)){break d}b=0;while(1){m=J[g>>2];if(m>=M(4294967296)|m<M(0)|(M(N(m))==M(Infinity)|m!=m)){break d}if(m>M(1)){break d}e=(b<<2)+d|0;j=R(+m*4294967295+.5);f:{if(j<4294967296&j>=0){i=~~j>>>0;break f}i=0;}F[e>>2]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break e}g=g+4|0;if(f>>>0>g>>>0){continue}break}break d}k=1;if(c>>>0<=e>>>0){break d}ma((e<<2)+d|0,0,c-e<<2);}return k;case 9:g:{h:{e=G[a+24|0];c=c&255;if(!(c>>>0>e>>>0?e:c)){break h}e=F[a>>2];k=F[e>>2];g=k;f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+f|0;g=b+g|0;f=F[e+4>>2];e=f-k|0;if(!G[a+32|0]){k=0;if((b|0)>=(e|0)){break g}b=0;while(1){j=K[g>>3];if(j>=4294967295|j<0|(N(j)==Infinity|j!=j)){break g}e=(b<<2)+d|0;if(j<4294967296&j>=0){i=~~j>>>0;}else {i=0;}F[e>>2]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}k=0;if((b|0)>=(e|0)){break g}b=0;while(1){j=K[g>>3];if(j>=4294967295|j<0|(N(j)==Infinity|j!=j)){break g}if(j>1){break g}e=(b<<2)+d|0;j=R(j*4294967295+.5);i:{if(j<4294967296&j>=0){i=~~j>>>0;break i}i=0;}F[e>>2]=i;b=b+1|0;e=G[a+24|0];if(b>>>0>=(c>>>0>e>>>0?e:c)>>>0){break h}g=g+8|0;if(f>>>0>g>>>0){continue}break}break g}k=1;if(c>>>0<=e>>>0){break g}ma((e<<2)+d|0,0,c-e<<2);}return k;case 10:break c;default:break b}}e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];h=F[e>>2];l=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);i=b;b=b+l|0;b=b+h|0;h=F[e+4>>2];while(1){if(b>>>0>=h>>>0){break b}F[(g<<2)+d>>2]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}ma((e<<2)+d|0,0,(c&255)-e<<2);}return k}ma((e<<2)+d|0,0,(c&255)-e<<2);return 1}function rd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;a:{b:{c:{d:{e:{if(F[a+92>>2]==F[a+88>>2]){break e}c=F[a+52>>2];f:{if((c|0)!=F[a+56>>2]){F[c>>2]=b;F[a+52>>2]=c+4;break f}h=F[a+48>>2];g=c-h|0;d=g>>2;f=d+1|0;if(f>>>0>=1073741824){break a}e=g>>>1|0;g=g>>>0>=2147483644?1073741823:f>>>0<e>>>0?e:f;if(g){if(g>>>0>=1073741824){break d}e=ka(g<<2);}else {e=0;}f=e+(d<<2)|0;F[f>>2]=b;d=f+4|0;if((c|0)!=(h|0)){while(1){f=f-4|0;c=c-4|0;F[f>>2]=F[c>>2];if((c|0)!=(h|0)){continue}break}}F[a+56>>2]=e+(g<<2);F[a+52>>2]=d;F[a+48>>2]=f;if(!h){break f}ja(h);}F[a+84>>2]=0;c=-1;e=-1;g:{if((b|0)==-1){break g}d=F[a+4>>2];e=b+1|0;e=(e>>>0)%3|0?e:b-2|0;if((e|0)!=-1){c=F[F[d>>2]+(e<<2)>>2];}h:{if((b>>>0)%3|0){l=b-1|0;break h}l=b+2|0;e=-1;if((l|0)==-1){break g}}e=F[F[d>>2]+(l<<2)>>2];}i=e>>>3&536870908;d=F[a+36>>2];h=d+(c>>>3&536870908)|0;g=F[h>>2];f=1<<c;if(!(g&f)){F[h>>2]=f|g;f=a+8|0;if((b|0)!=-1){d=b+1|0;d=(d>>>0)%3|0?d:b-2|0;}else {d=-1;}Ka(f,c,d);d=F[a+36>>2];}f=d+i|0;d=F[f>>2];c=1<<e;if(!(d&c)){F[f>>2]=c|d;d=a+8|0;c=-1;i:{if((b|0)==-1){break i}c=b-1|0;if((b>>>0)%3|0){break i}c=b+2|0;}Ka(d,e,c);}c=-1;c=(b|0)!=-1?F[F[F[a+4>>2]>>2]+(b<<2)>>2]:c;f=F[a+36>>2]+(c>>>3&536870908)|0;d=F[f>>2];e=1<<c;if(!(d&e)){F[f>>2]=d|e;Ka(a+8|0,c,b);}d=F[a+84>>2];if((d|0)>2){break e}while(1){e=L(d,12)+a|0;b=F[e+52>>2];if((b|0)==F[e+48>>2]){d=d+1|0;if((d|0)!=3){continue}break e}b=b-4|0;c=F[b>>2];F[e+52>>2]=b;F[a+84>>2]=d;if((c|0)==-1){break e}f=F[a+24>>2];b=(c>>>0)/3|0;j:{if(F[f+(b>>>3&268435452)>>2]>>>b&1){break j}k:{while(1){k=(c>>>0)/3|0;b=(k>>>3&268435452)+f|0;F[b>>2]=F[b>>2]|1<<k;d=-1;l:{m:{n:{o:{p:{q:{r:{s:{d=(c|0)!=-1?F[F[F[a+4>>2]>>2]+(c<<2)>>2]:d;f=F[a+36>>2]+(d>>>3&536870908)|0;e=F[f>>2];b=1<<d;if(!(e&b)){F[f>>2]=b|e;i=F[(F[F[a+16>>2]+96>>2]+L(k,12)|0)+((c>>>0)%3<<2)>>2];l=F[F[a+20>>2]+4>>2];f=F[l+4>>2];t:{if((f|0)!=F[l+8>>2]){F[f>>2]=i;F[l+4>>2]=f+4;break t}j=F[l>>2];h=f-j|0;g=h>>2;e=g+1|0;if(e>>>0>=1073741824){break s}b=h>>>1|0;h=h>>>0>=2147483644?1073741823:b>>>0>e>>>0?b:e;if(h){if(h>>>0>=1073741824){break d}e=ka(h<<2);}else {e=0;}b=e+(g<<2)|0;F[b>>2]=i;g=b+4|0;if((f|0)!=(j|0)){while(1){b=b-4|0;f=f-4|0;F[b>>2]=F[f>>2];if((f|0)!=(j|0)){continue}break}}F[l+8>>2]=e+(h<<2);F[l+4>>2]=g;F[l>>2]=b;if(!j){break t}ja(j);}j=F[a+12>>2];f=F[j+4>>2];u:{if((f|0)!=F[j+8>>2]){F[f>>2]=c;F[j+4>>2]=f+4;break u}i=F[j>>2];h=f-i|0;g=h>>2;e=g+1|0;if(e>>>0>=1073741824){break r}b=h>>>1|0;h=h>>>0>=2147483644?1073741823:b>>>0>e>>>0?b:e;if(h){if(h>>>0>=1073741824){break d}e=ka(h<<2);}else {e=0;}b=e+(g<<2)|0;F[b>>2]=c;g=b+4|0;if((f|0)!=(i|0)){while(1){b=b-4|0;f=f-4|0;F[b>>2]=F[f>>2];if((f|0)!=(i|0)){continue}break}}F[j+8>>2]=e+(h<<2);F[j+4>>2]=g;F[j>>2]=b;if(!i){break u}ja(i);}b=F[a+12>>2];F[F[b+12>>2]+(d<<2)>>2]=F[b+24>>2];F[b+24>>2]=F[b+24>>2]+1;}if((c|0)==-1){break k}g=F[a+4>>2];f=-1;b=c+1|0;b=(b>>>0)%3|0?b:c-2|0;if((b|0)!=-1){f=F[F[g+12>>2]+(b<<2)>>2];}v:{w:{if((L(k,3)|0)!=(c|0)){d=c-1|0;break w}d=c+2|0;c=-1;if((d|0)==-1){break v}}c=F[F[g+12>>2]+(d<<2)>>2];}d=(c|0)==-1;e=(c>>>0)/3|0;if((f|0)!=-1){b=(f>>>0)/3|0;b=F[F[a+24>>2]+(b>>>3&268435452)>>2]&1<<b;if(d){break q}l=(b|0)!=0;break p}l=1;if(!d){break p}break k}na();v();}na();v();}if(!b){break o}break k}b=d?-1:e;x:{if(F[F[a+24>>2]+(b>>>3&536870908)>>2]>>>b&1){break x}k=0;b=F[F[g>>2]+(c<<2)>>2];if(!(F[F[a+36>>2]+(b>>>3&536870908)>>2]>>>b&1)){b=F[a+88>>2]+(b<<2)|0;e=F[b>>2];F[b>>2]=e+1;k=(e|0)<=0?2:1;}if(F[a+84>>2]>=(k|0)&l){break m}j=L(k,12)+a|0;b=F[j+52>>2];y:{if((b|0)!=F[j+56>>2]){F[b>>2]=c;F[j+52>>2]=b+4;break y}i=F[j+48>>2];h=b-i|0;d=h>>2;g=d+1|0;if(g>>>0>=1073741824){break c}e=h>>>1|0;g=h>>>0>=2147483644?1073741823:e>>>0>g>>>0?e:g;if(g){if(g>>>0>=1073741824){break d}e=ka(g<<2);}else {e=0;}d=e+(d<<2)|0;F[d>>2]=c;c=d+4|0;if((b|0)!=(i|0)){while(1){d=d-4|0;b=b-4|0;F[d>>2]=F[b>>2];if((b|0)!=(i|0)){continue}break}}F[j+48>>2]=d;F[j+52>>2]=c;F[j+56>>2]=e+(g<<2);if(!i){break y}ja(i);}if(F[a+84>>2]<=(k|0)){break x}F[a+84>>2]=k;}if(l){break k}c=-1;if((f|0)==-1){break n}}c=F[F[F[a+4>>2]>>2]+(f<<2)>>2];}b=0;if(!(F[F[a+36>>2]+(c>>>3&536870908)>>2]>>>c&1)){b=F[a+88>>2]+(c<<2)|0;c=F[b>>2];F[b>>2]=c+1;b=(c|0)<=0?2:1;}if(F[a+84>>2]<(b|0)){break l}c=f;}f=F[a+24>>2];continue}break}k=L(b,12)+a|0;c=F[k+52>>2];z:{if((c|0)!=F[k+56>>2]){F[c>>2]=f;F[k+52>>2]=c+4;break z}i=F[k+48>>2];h=c-i|0;d=h>>2;g=d+1|0;if(g>>>0>=1073741824){break b}e=h>>>1|0;g=h>>>0>=2147483644?1073741823:e>>>0>g>>>0?e:g;if(g){if(g>>>0>=1073741824){break d}e=ka(g<<2);}else {e=0;}d=e+(d<<2)|0;F[d>>2]=f;f=d+4|0;if((c|0)!=(i|0)){while(1){d=d-4|0;c=c-4|0;F[d>>2]=F[c>>2];if((c|0)!=(i|0)){continue}break}}F[k+48>>2]=d;F[k+52>>2]=f;F[k+56>>2]=e+(g<<2);if(!i){break z}ja(i);}d=F[a+84>>2];if((d|0)<=(b|0)){break j}F[a+84>>2]=b;d=b;break j}d=F[a+84>>2];}if((d|0)<3){continue}break}}return 1}oa();v();}na();v();}na();v();}na();v();}function Mc(a){var b=0,c=0,d=0,e=0,f=0,g=0;e=Z-16|0;Z=e;F[e+12>>2]=a;a:{if(a>>>0<=211){d=F[Lc(10352,10544,e+12|0)>>2];break a}if(a>>>0>=4294967292){V();v();}f=(a>>>0)/210|0;d=L(f,210);F[e+8>>2]=a-d;g=Lc(10544,10736,e+8|0)-10544>>2;while(1){d=F[(g<<2)+10544>>2]+d|0;a=5;while(1){b:{if((a|0)==47){a=211;while(1){b=(d>>>0)/(a>>>0)|0;if(b>>>0<a>>>0){break a}if((L(a,b)|0)==(d|0)){break b}b=a+10|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+12|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+16|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+18|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+22|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+28|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+30|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+36|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+40|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+42|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+46|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+52|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+58|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+60|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+66|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+70|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+72|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+78|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+82|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+88|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+96|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+100|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+102|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+106|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+108|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+112|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+120|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+126|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+130|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+136|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+138|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+142|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+148|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+150|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+156|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+162|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+166|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+168|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+172|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+178|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+180|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+186|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+190|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+192|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+196|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+198|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}if((L(b,c)|0)==(d|0)){break b}b=a+208|0;c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}a=a+210|0;if((L(b,c)|0)!=(d|0)){continue}break}break b}b=F[(a<<2)+10352>>2];c=(d>>>0)/(b>>>0)|0;if(b>>>0>c>>>0){break a}a=a+1|0;if((L(b,c)|0)!=(d|0)){continue}}break}d=g+1|0;a=(d|0)==48;g=a?0:d;f=a+f|0;d=L(f,210);continue}}Z=e+16|0;return d}function lb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=M(0),l=0;a:{if(!d){break a}b:{c:{switch(F[a+28>>2]-1|0){case 0:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];i=G[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=M(D[b|0]);J[(h<<2)+d>>2]=i?M(j/M(127)):j;b=b+1|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 1:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];i=G[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=M(G[b|0]);J[(h<<2)+d>>2]=i?M(j/M(255)):j;b=b+1|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 2:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];i=G[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=M(E[b>>1]);J[(h<<2)+d>>2]=i?M(j/M(32767)):j;b=b+2|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 3:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];i=G[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=M(H[b>>1]);J[(h<<2)+d>>2]=i?M(j/M(65535)):j;b=b+2|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 4:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];i=G[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=M(F[b>>2]);J[(h<<2)+d>>2]=i?M(j*M(4.656612873077393e-10)):j;b=b+4|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 5:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];i=G[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=M(I[b>>2]);J[(h<<2)+d>>2]=i?M(j*M(2.3283064365386963e-10)):j;b=b+4|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 6:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];i=G[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=M(+I[b>>2]+ +F[b+4>>2]*4294967296);J[(h<<2)+d>>2]=i?M(j*M(10842021724855044e-35)):j;b=b+8|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 7:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];i=G[a+32|0];while(1){if(b>>>0>=g>>>0){break a}j=M(+I[b>>2]+ +I[b+4>>2]*4294967296);J[(h<<2)+d>>2]=i?M(j*M(5.421010862427522e-20)):j;b=b+8|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 8:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];while(1){if(b>>>0>=g>>>0){break a}J[(h<<2)+d>>2]=J[b>>2];b=b+4|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 9:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];while(1){if(b>>>0>=g>>>0){break a}J[(h<<2)+d>>2]=K[b>>3];b=b+8|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;break b;case 10:break c;default:break a}}e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[a>>2];g=F[e>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);b=b+i|0;b=b+g|0;g=F[e+4>>2];while(1){if(b>>>0>=g>>>0){break a}J[(h<<2)+d>>2]=G[b|0]?M(1):M(0);b=b+1|0;h=h+1|0;e=G[a+24|0];if(h>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}l=1;if(e>>>0>=f>>>0){break a}d=(e<<2)+d|0;a=(c&255)-e|0;}ma(d,0,a<<2);}return l}function Cb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=M(0),m=M(0);a:{b:{if(!d){break b}c:{switch(F[a+28>>2]-1|0){case 0:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}D[d+g|0]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){return 0}e=D[b|0];if((e|0)<0){break b}D[d+g|0]=e;b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}e=H[b>>1];if((e+128&65535)>>>0>255){break b}D[d+g|0]=e;b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}e=H[b>>1];if(e>>>0>127){break b}D[d+g|0]=e;b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}e=F[b>>2];if(e+128>>>0>255){break b}D[d+g|0]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}e=F[b>>2];if(e>>>0>127){break b}D[d+g|0]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}i=F[b+4>>2];e=F[b>>2];h=e+128|0;i=h>>>0<128?i+1|0:i;if(!i&h>>>0>255|i){break b}D[d+g|0]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}i=F[b+4>>2];e=F[b>>2];if(!i&e>>>0>127|i){break b}D[d+g|0]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 8:e=G[a+24|0];c=c&255;d:{if(c>>>0>e>>>0?e:c){e=F[F[a>>2]>>2];f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+f|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break d}l=J[b>>2];if(l>=M(127)|l<M(-128)|l!=l){break d}m=M(N(l));if(m==M(Infinity)){break d}e=d+g|0;e:{f:{if(G[a+32|0]){if(l<M(0)|l>M(1)){break d}j=R(+l*127+.5);if(!(N(j)<2147483648)){break f}h=~~j;break e}if(!(m<M(2147483648))){break f}h=~~l;break e}h=-2147483648;}D[e|0]=h;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(c>>>0>e>>>0?e:c)>>>0){continue}break}}k=1;if(c>>>0<=e>>>0){break d}ma(d+e|0,0,c-e|0);}return k;case 9:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}j=K[b>>3];if(j>=127|j<-128|(N(j)==Infinity|j!=j)){break b}e=d+g|0;if(G[a+32|0]){if(j<0|j>1){break b}j=R(j*127+.5);}g:{if(N(j)<2147483648){h=~~j;break g}h=-2147483648;}D[e|0]=h;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 10:break c;default:break b}}e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}D[d+g|0]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}ma(d+e|0,0,(c&255)-e|0);}return k}ma(d+e|0,0,(c&255)-e|0);return 1}function Bb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=M(0);a:{b:{if(!d){break b}c:{switch(F[a+28>>2]-1|0){case 0:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){return 0}e=D[b|0];if((e|0)<0){break b}D[d+g|0]=e;b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 1:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}D[d+g|0]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 2:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}e=H[b>>1];if(e>>>0>255){break b}D[d+g|0]=e;b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 3:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}e=H[b>>1];if(e>>>0>255){break b}D[d+g|0]=e;b=b+2|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 4:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}e=F[b>>2];if(e>>>0>255){break b}D[d+g|0]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 5:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}e=F[b>>2];if(e>>>0>255){break b}D[d+g|0]=e;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 6:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}i=F[b+4>>2];e=F[b>>2];if(!i&e>>>0>255|i){break b}D[d+g|0]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 7:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}i=F[b+4>>2];e=F[b>>2];if(!i&e>>>0>255|i){break b}D[d+g|0]=e;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 8:e=G[a+24|0];c=c&255;d:{if(c>>>0>e>>>0?e:c){e=F[F[a>>2]>>2];f=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+f|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break d}l=J[b>>2];if(l>=M(255)|l<M(0)|(M(N(l))==M(Infinity)|l!=l)){break d}e=d+g|0;e:{f:{if(G[a+32|0]){if(l>M(1)){break d}j=R(+l*255+.5);if(!(j<4294967296&j>=0)){break f}h=~~j>>>0;break e}if(!(l<M(4294967296)&l>=M(0))){break f}h=~~l>>>0;break e}h=0;}D[e|0]=h;b=b+4|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(c>>>0>e>>>0?e:c)>>>0){continue}break}}k=1;if(c>>>0<=e>>>0){break d}ma(d+e|0,0,c-e|0);}return k;case 9:e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}j=K[b>>3];if(j>=255|j<0|(N(j)==Infinity|j!=j)){break b}e=d+g|0;if(G[a+32|0]){if(j>1){break b}j=R(j*255+.5);}g:{if(j<4294967296&j>=0){h=~~j>>>0;break g}h=0;}D[e|0]=h;b=b+8|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}break a;case 10:break c;default:break b}}e=G[a+24|0];f=c&255;if(e>>>0<f>>>0?e:f){e=F[F[a>>2]>>2];i=F[a+48>>2];b=ki(F[a+40>>2],F[a+44>>2],b,0);h=b;b=b+i|0;b=b+e|0;while(1){if(I[F[a>>2]+4>>2]<=b>>>0){break b}D[d+g|0]=G[b|0];b=b+1|0;g=g+1|0;e=G[a+24|0];if(g>>>0<(e>>>0<f>>>0?e:f)>>>0){continue}break}}k=1;if(e>>>0>=f>>>0){break b}ma(d+e|0,0,(c&255)-e|0);}return k}ma(d+e|0,0,(c&255)-e|0);return 1}function jc(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;e=Z-48|0;Z=e;f=H[5053]|H[5054]<<16;d=H[5051]|H[5052]<<16;E[e+38>>1]=d;E[e+40>>1]=d>>>16;E[e+42>>1]=f;E[e+44>>1]=f>>>16;d=F[2525];F[e+32>>2]=F[2524];F[e+36>>2]=d;d=F[2523];F[e+24>>2]=F[2522];F[e+28>>2]=d;d=F[2521];F[e+16>>2]=F[2520];F[e+20>>2]=d;g=F[b+8>>2];i=F[b+12>>2];h=F[b+20>>2];d=F[b+16>>2];f=d+5|0;h=f>>>0<5?h+1|0:h;a:{b:{if(g>>>0<f>>>0&(h|0)>=(i|0)|(h|0)>(i|0)){d=ya(e+16|0);if(d>>>0>=2147483632){break a}c:{d:{if(d>>>0>=11){b=(d|15)+1|0;c=ka(b);F[e+8>>2]=b|-2147483648;F[e>>2]=c;F[e+4>>2]=d;b=c+d|0;break d}D[e+11|0]=d;b=d+e|0;c=e;if(!d){break c}}la(c,e+16|0,d);}D[b|0]=0;F[a>>2]=-2;b=a+4|0;if(D[e+11|0]>=0){a=F[e+4>>2];F[b>>2]=F[e>>2];F[b+4>>2]=a;F[b+8>>2]=F[e+8>>2];break b}ra(b,F[e>>2],F[e+4>>2]);if(D[e+11|0]>=0){break b}ja(F[e>>2]);break b}f=d+F[b>>2]|0;d=G[f|0]|G[f+1|0]<<8|(G[f+2|0]<<16|G[f+3|0]<<24);D[c|0]=d;D[c+1|0]=d>>>8;D[c+2|0]=d>>>16;D[c+3|0]=d>>>24;D[c+4|0]=G[f+4|0];d=F[b+20>>2];f=F[b+16>>2]+5|0;d=f>>>0<5?d+1|0:d;F[b+16>>2]=f;F[b+20>>2]=d;if(sa(c,1250,5)){d=ka(32);D[d+17|0]=0;D[d+16|0]=G[1494];c=G[1490]|G[1491]<<8|(G[1492]<<16|G[1493]<<24);b=G[1486]|G[1487]<<8|(G[1488]<<16|G[1489]<<24);D[d+8|0]=b;D[d+9|0]=b>>>8;D[d+10|0]=b>>>16;D[d+11|0]=b>>>24;D[d+12|0]=c;D[d+13|0]=c>>>8;D[d+14|0]=c>>>16;D[d+15|0]=c>>>24;c=G[1482]|G[1483]<<8|(G[1484]<<16|G[1485]<<24);b=G[1478]|G[1479]<<8|(G[1480]<<16|G[1481]<<24);D[d|0]=b;D[d+1|0]=b>>>8;D[d+2|0]=b>>>16;D[d+3|0]=b>>>24;D[d+4|0]=c;D[d+5|0]=c>>>8;D[d+6|0]=c>>>16;D[d+7|0]=c>>>24;F[a>>2]=-1;ra(a+4|0,d,17);ja(d);break b}g=F[b+12>>2];if((g|0)<=(d|0)&I[b+8>>2]<=f>>>0|(d|0)>(g|0)){d=ya(e+16|0);if(d>>>0>=2147483632){break a}e:{f:{if(d>>>0>=11){b=(d|15)+1|0;c=ka(b);F[e+8>>2]=b|-2147483648;F[e>>2]=c;F[e+4>>2]=d;b=c+d|0;break f}D[e+11|0]=d;b=d+e|0;c=e;if(!d){break e}}la(c,e+16|0,d);}D[b|0]=0;F[a>>2]=-2;b=a+4|0;if(D[e+11|0]>=0){a=F[e+4>>2];F[b>>2]=F[e>>2];F[b+4>>2]=a;F[b+8>>2]=F[e+8>>2];break b}ra(b,F[e>>2],F[e+4>>2]);if(D[e+11|0]>=0){break b}ja(F[e>>2]);break b}D[c+5|0]=G[f+F[b>>2]|0];g=F[b+20>>2];d=F[b+16>>2]+1|0;g=d?g:g+1|0;F[b+16>>2]=d;F[b+20>>2]=g;f=F[b+12>>2];if((f|0)<=(g|0)&I[b+8>>2]<=d>>>0|(g|0)>(f|0)){d=ya(e+16|0);if(d>>>0>=2147483632){break a}g:{h:{if(d>>>0>=11){b=(d|15)+1|0;c=ka(b);F[e+8>>2]=b|-2147483648;F[e>>2]=c;F[e+4>>2]=d;b=c+d|0;break h}D[e+11|0]=d;b=d+e|0;c=e;if(!d){break g}}la(c,e+16|0,d);}D[b|0]=0;F[a>>2]=-2;b=a+4|0;if(D[e+11|0]>=0){a=F[e+4>>2];F[b>>2]=F[e>>2];F[b+4>>2]=a;F[b+8>>2]=F[e+8>>2];break b}ra(b,F[e>>2],F[e+4>>2]);if(D[e+11|0]>=0){break b}ja(F[e>>2]);break b}D[c+6|0]=G[d+F[b>>2]|0];h=F[b+20>>2];d=F[b+16>>2]+1|0;h=d?h:h+1|0;F[b+16>>2]=d;F[b+20>>2]=h;f=F[b+12>>2];if((f|0)<=(h|0)&I[b+8>>2]<=d>>>0|(f|0)<(h|0)){d=ya(e+16|0);if(d>>>0>=2147483632){break a}i:{j:{if(d>>>0>=11){b=(d|15)+1|0;c=ka(b);F[e+8>>2]=b|-2147483648;F[e>>2]=c;F[e+4>>2]=d;b=c+d|0;break j}D[e+11|0]=d;b=d+e|0;c=e;if(!d){break i}}la(c,e+16|0,d);}D[b|0]=0;F[a>>2]=-2;b=a+4|0;if(D[e+11|0]>=0){a=F[e+4>>2];F[b>>2]=F[e>>2];F[b+4>>2]=a;F[b+8>>2]=F[e+8>>2];break b}ra(b,F[e>>2],F[e+4>>2]);if(D[e+11|0]>=0){break b}ja(F[e>>2]);break b}D[c+7|0]=G[d+F[b>>2]|0];g=F[b+20>>2];d=F[b+16>>2]+1|0;g=d?g:g+1|0;F[b+16>>2]=d;F[b+20>>2]=g;f=F[b+12>>2];if((f|0)<=(g|0)&I[b+8>>2]<=d>>>0|(g|0)>(f|0)){c=Eb(e,e+16|0);F[a>>2]=-2;b=a+4|0;if(D[c+11|0]>=0){a=F[c+4>>2];F[b>>2]=F[c>>2];F[b+4>>2]=a;F[b+8>>2]=F[c+8>>2];break b}ra(b,F[c>>2],F[c+4>>2]);if(D[c+11|0]>=0){break b}ja(F[c>>2]);break b}D[c+8|0]=G[d+F[b>>2]|0];d=F[b+20>>2];g=F[b+16>>2];f=g+1|0;i=f?d:d+1|0;F[b+16>>2]=f;F[b+20>>2]=i;i=F[b+8>>2];h=F[b+12>>2];g=g+3|0;d=g>>>0<3?d+1|0:d;if(g>>>0>i>>>0&(d|0)>=(h|0)|(d|0)>(h|0)){c=Eb(e,e+16|0);F[a>>2]=-2;b=a+4|0;if(D[c+11|0]>=0){a=F[c+4>>2];F[b>>2]=F[c>>2];F[b+4>>2]=a;F[b+8>>2]=F[c+8>>2];break b}ra(b,F[c>>2],F[c+4>>2]);if(D[c+11|0]>=0){break b}ja(F[c>>2]);break b}d=c;c=F[b>>2]+f|0;E[d+10>>1]=G[c|0]|G[c+1|0]<<8;g=F[b+20>>2];c=F[b+16>>2]+2|0;g=c>>>0<2?g+1|0:g;F[b+16>>2]=c;F[b+20>>2]=g;F[a+8>>2]=0;F[a+12>>2]=0;F[a>>2]=0;F[a+4>>2]=0;}Z=e+48|0;return}za();v();}function Mb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0;e=Z-96|0;Z=e;f=F[a+16>>2];D[e+92|0]=1;F[e+88>>2]=b;F[e+84>>2]=b;F[e+80>>2]=f;j=F[a+20>>2];d=F[j>>2];a:{b:{f=F[F[f+28>>2]+(b<<2)>>2];if(f>>>0<F[j+4>>2]-d>>2>>>0){d=F[F[a+8>>2]+(F[d+(f<<2)>>2]<<2)>>2];f=F[a+4>>2];if(!G[f+84|0]){d=F[F[f+68>>2]+(d<<2)>>2];}F[e+72>>2]=0;F[e+76>>2]=0;j=e- -64|0;F[j>>2]=0;F[j+4>>2]=0;F[e+56>>2]=0;F[e+60>>2]=0;Ga(f,d,D[f+24|0],e+56|0);if((b|0)!=-1){f=b+1|0;j=(f>>>0)%3|0?f:b-2|0;m=((b>>>0)%3|0?-1:2)+b|0;while(1){d=j;f=m;c:{if(!F[a+28>>2]){break c}f=b+1|0;d=(f>>>0)%3|0?f:b-2|0;f=b-1|0;if((b>>>0)%3|0){break c}f=b+2|0;}n=F[a+20>>2];b=F[n>>2];d=F[F[F[a+16>>2]+28>>2]+(d<<2)>>2];if(d>>>0>=F[n+4>>2]-b>>2>>>0){break b}d=F[F[a+8>>2]+(F[b+(d<<2)>>2]<<2)>>2];b=F[a+4>>2];if(!G[b+84|0]){d=F[F[b+68>>2]+(d<<2)>>2];}F[e+48>>2]=0;F[e+52>>2]=0;F[e+40>>2]=0;F[e+44>>2]=0;F[e+32>>2]=0;F[e+36>>2]=0;Ga(b,d,D[b+24|0],e+32|0);d=F[a+20>>2];b=F[d>>2];f=F[F[F[a+16>>2]+28>>2]+(f<<2)>>2];if(f>>>0>=F[d+4>>2]-b>>2>>>0){break a}d=F[F[a+8>>2]+(F[b+(f<<2)>>2]<<2)>>2];b=F[a+4>>2];if(!G[b+84|0]){d=F[F[b+68>>2]+(d<<2)>>2];}F[e+24>>2]=0;F[e+28>>2]=0;F[e+16>>2]=0;F[e+20>>2]=0;F[e+8>>2]=0;F[e+12>>2]=0;Ga(b,d,D[b+24|0],e+8|0);g=F[e+8>>2];b=F[e+56>>2];d=g-b|0;p=F[e+60>>2];t=F[e+12>>2]-(p+(b>>>0>g>>>0)|0)|0;h=F[e+40>>2];f=F[e+64>>2];n=h-f|0;u=F[e+68>>2];y=F[e+44>>2]-(u+(f>>>0>h>>>0)|0)|0;g=ki(d,t,n,y);w=o-g|0;x=i-(_+(g>>>0>o>>>0)|0)|0;i=w;h=F[e+16>>2];g=h-f|0;u=F[e+20>>2]-((f>>>0>h>>>0)+u|0)|0;k=F[e+32>>2];h=k-b|0;w=F[e+36>>2]-((b>>>0>k>>>0)+p|0)|0;b=ki(g,u,h,w);o=i+b|0;i=_+x|0;i=b>>>0>o>>>0?i+1|0:i;b=l;l=d;p=t;k=F[e+48>>2];f=F[e+72>>2];d=k-f|0;t=F[e+76>>2];x=F[e+52>>2]-(t+(f>>>0>k>>>0)|0)|0;l=ki(l,p,d,x);k=b+l|0;b=_+q|0;b=k>>>0<l>>>0?b+1|0:b;l=F[e+24>>2];p=l-f|0;f=F[e+28>>2]-((f>>>0>l>>>0)+t|0)|0;q=ki(p,f,h,w);l=k-q|0;q=b-(_+(k>>>0<q>>>0)|0)|0;b=ki(g,u,d,x);d=r-b|0;b=s-(_+(b>>>0>r>>>0)|0)|0;s=ki(p,f,n,y);r=s+d|0;b=_+b|0;s=r>>>0<s>>>0?b+1|0:b;b=F[e+88>>2];f=F[e+80>>2];d:{if(G[e+92|0]){e:{f:{g:{h:{if((b|0)==-1){break h}d=b+1|0;b=(d>>>0)%3|0?d:b-2|0;if((b|0)==-1|F[F[f>>2]+(b>>>3&536870908)>>2]>>>b&1){break h}b=F[F[F[f+64>>2]+12>>2]+(b<<2)>>2];if((b|0)!=-1){break g}}F[e+88>>2]=-1;break f}d=b+1|0;b=(d>>>0)%3|0?d:b-2|0;F[e+88>>2]=b;if((b|0)!=-1){break e}}b=F[e+84>>2];d=-1;i:{if((b|0)==-1){break i}j:{if((b>>>0)%3|0){b=b-1|0;break j}b=b+2|0;d=-1;if((b|0)==-1){break i}}d=-1;if(F[F[f>>2]+(b>>>3&536870908)>>2]>>>b&1){break i}b=F[F[F[f+64>>2]+12>>2]+(b<<2)>>2];d=-1;if((b|0)==-1){break i}d=b-1|0;if((b>>>0)%3|0){break i}d=b+2|0;}D[e+92|0]=0;F[e+88>>2]=d;break d}if((b|0)!=F[e+84>>2]){break d}F[e+88>>2]=-1;break d}d=-1;k:{if((b|0)==-1){break k}l:{if((b>>>0)%3|0){b=b-1|0;break l}b=b+2|0;d=-1;if((b|0)==-1){break k}}d=-1;if(F[F[f>>2]+(b>>>3&536870908)>>2]>>>b&1){break k}b=F[F[F[f+64>>2]+12>>2]+(b<<2)>>2];d=-1;if((b|0)==-1){break k}d=b-1|0;if((b>>>0)%3|0){break k}d=b+2|0;}F[e+88>>2]=d;}b=F[e+88>>2];if((b|0)!=-1){continue}break}}b=s>>31;f=b^r;d=f-b|0;b=(b^s)-((b>>>0>f>>>0)+b|0)|0;m=-1;f=2147483647;g=q>>31;h=g^l;j=h-g|0;n=(g^q)-((h>>>0<g>>>0)+g|0)|0;h=n;k=j^-1;g=h^2147483647;n=i;m:{n:{if(!F[a+28>>2]){if((b|0)==(g|0)&d>>>0>k>>>0|b>>>0>g>>>0){break m}b=b+h|0;a=d+j|0;b=a>>>0<j>>>0?b+1|0:b;f=a;g=i;a=g>>31;d=a;m=d^o;a=m-d|0;i=a;d=(d^g)-((d>>>0>m>>>0)+d|0)|0;a=a+f|0;d=d^2147483647;i=(d|0)==(b|0)&(i^-1)>>>0<f>>>0|b>>>0>d>>>0;a=i?-1:a;if(!(i&0)&(a|0)<=536870912|(a|0)<536870912){break m}b=0;a=a>>>29|0;break n}o:{if((b|0)==(g|0)&d>>>0>k>>>0|b>>>0>g>>>0){break o}b=b+h|0;a=d+j|0;b=a>>>0<j>>>0?b+1|0:b;k=i;d=i>>31;h=d^o;i=h-d|0;j=(d^k)-((d>>>0>h>>>0)+d|0)|0;g=j^2147483647;d=a;a=i;if((g|0)==(b|0)&d>>>0>(a^-1)>>>0|b>>>0>g>>>0){break o}b=b+j|0;m=a+d|0;b=m>>>0<a>>>0?b+1|0:b;f=b;if(!b&m>>>0<536870913){break m}}b=f>>>29|0;a=(f&536870911)<<3|m>>>29;}o=li(o,n,a,b);l=li(l,q,a,b);r=li(r,s,a,b);}F[c+8>>2]=o;F[c+4>>2]=l;F[c>>2]=r;Z=e+96|0;return}ta();v();}ta();v();}ta();v();}function Jg(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;e=Z-32|0;Z=e;a:{if(!hb(1,e+28|0,F[a+32>>2])){break a}if(!hb(1,e+24|0,F[a+32>>2])){break a}l=F[e+28>>2];if(l>>>0>1431655765){break a}d=F[a+32>>2];c=d;g=F[c+8>>2];b=F[c+16>>2];f=F[c+12>>2];c=F[c+20>>2];i=li(g-b|0,f-(c+(b>>>0>g>>>0)|0)|0,3,0);if(!_&i>>>0<l>>>0|((c|0)>=(f|0)&b>>>0>=g>>>0|(c|0)>(f|0))){break a}g=G[b+F[d>>2]|0];b=b+1|0;c=b?c:c+1|0;F[d+16>>2]=b;F[d+20>>2]=c;b:{c:{if(!g){c=Z-32|0;Z=c;F[c+24>>2]=0;F[c+16>>2]=0;F[c+20>>2]=0;d:{e:{b=L(l,3);if(b){if(b>>>0>=1073741824){break e}d=L(l,12);n=ka(d);ma(n,0,d);}b=mc(b,1,F[a+32>>2],n);f:{g:{if(!(!l|!b)){d=0;while(1){h:{g=F[(d<<2)+n>>2];b=g>>>1|0;i:{if(g&1){if((b|0)>(h|0)){break h}b=0-b|0;break i}if((h^2147483647)>>>0<b>>>0){break h}}g=b+h|0;F[c>>2]=g;h=F[(d+1<<2)+n>>2];b=h>>>1|0;j:{if(h&1){if((b|0)>(g|0)){break h}b=0-b|0;break j}if((g^2147483647)>>>0<b>>>0){break h}}g=b+g|0;F[c+4>>2]=g;h=F[(d+2<<2)+n>>2];b=h>>>1|0;k:{if(h&1){if((b|0)>(g|0)){break h}b=0-b|0;break k}if((g^2147483647)>>>0<b>>>0){break h}}d=d+3|0;h=b+g|0;F[c+8>>2]=h;mb(F[a+44>>2]+96|0,c);b=1;j=j+1|0;if((j|0)!=(l|0)){continue}break g}break}b=0;break g}if(!n){break f}}ja(n);}Z=c+32|0;break d}na();v();}if(!b){break a}n=F[e+24>>2];break c}n=F[e+24>>2];if(n>>>0<=255){if(!l){break c}while(1){l:{F[e+16>>2]=0;F[e+8>>2]=0;F[e+12>>2]=0;d=F[a+32>>2];b=d;g=F[b+16>>2];f=F[b+8>>2];c=F[b+20>>2];i=F[b+12>>2];b=i;if(f>>>0<=g>>>0&(c|0)>=(b|0)|(b|0)<(c|0)){break l}j=F[d>>2];m=G[j+g|0];b=c;h=g+1|0;b=h?b:b+1|0;F[d+16>>2]=h;F[d+20>>2]=b;F[e+8>>2]=m;m=f>>>0<g>>>0&(c|0)>=(i|0)|(c|0)>(i|0);f=m?g:f;i=m?c:i;if((f|0)==(h|0)&(i|0)==(b|0)){break l}m=G[h+j|0];b=c;h=g+2|0;b=h>>>0<2?b+1|0:b;F[d+16>>2]=h;F[d+20>>2]=b;F[e+12>>2]=m;if((f|0)==(h|0)&(b|0)==(i|0)){break l}h=G[h+j|0];b=c;c=g+3|0;b=c>>>0<3?b+1|0:b;F[d+16>>2]=c;F[d+20>>2]=b;F[e+16>>2]=h;mb(F[a+44>>2]+96|0,e+8|0);k=k+1|0;if((k|0)!=(l|0)){continue}break c}break}k=0;break a}if(n>>>0<=65535){if(!l){break c}while(1){m:{F[e+16>>2]=0;F[e+8>>2]=0;F[e+12>>2]=0;j=F[a+32>>2];b=j;c=F[b+8>>2];d=F[b+12>>2];h=F[b+16>>2];b=F[b+20>>2];g=b;f=h+2|0;b=f>>>0<2?b+1|0:b;if(c>>>0<f>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break m}m=F[j>>2];i=m+h|0;i=G[i|0]|G[i+1|0]<<8;F[j+16>>2]=f;F[j+20>>2]=b;F[e+8>>2]=i;b=g;i=h+4|0;b=i>>>0<4?b+1|0:b;if(c>>>0<i>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break m}f=f+m|0;f=G[f|0]|G[f+1|0]<<8;F[j+16>>2]=i;F[j+20>>2]=b;F[e+12>>2]=f;f=c;b=g;c=h+6|0;b=c>>>0<6?b+1|0:b;if(c>>>0>f>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break m}d=i+m|0;d=G[d|0]|G[d+1|0]<<8;F[j+16>>2]=c;F[j+20>>2]=b;F[e+16>>2]=d;mb(F[a+44>>2]+96|0,e+8|0);k=k+1|0;if((k|0)!=(l|0)){continue}break c}break}k=0;break a}n:{if(n>>>0>2097151){break n}b=H[a+36>>1];if(((b<<8|b>>>8)&65535)>>>0<514){break n}if(!l){break c}while(1){o:{F[e+16>>2]=0;F[e+8>>2]=0;F[e+12>>2]=0;if(!hb(1,e+4|0,F[a+32>>2])){break o}F[e+8>>2]=F[e+4>>2];if(!hb(1,e+4|0,F[a+32>>2])){break o}F[e+12>>2]=F[e+4>>2];if(!hb(1,e+4|0,F[a+32>>2])){break o}F[e+16>>2]=F[e+4>>2];mb(F[a+44>>2]+96|0,e+8|0);k=k+1|0;if((k|0)!=(l|0)){continue}break c}break}k=0;break a}if(!l){break c}while(1){F[e+16>>2]=0;F[e+8>>2]=0;F[e+12>>2]=0;j=F[a+32>>2];b=j;c=F[b+8>>2];d=F[b+12>>2];h=F[b+16>>2];b=F[b+20>>2];g=b;f=h+4|0;b=f>>>0<4?b+1|0:b;if(c>>>0<f>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break b}m=F[j>>2];i=m+h|0;i=G[i|0]|G[i+1|0]<<8|(G[i+2|0]<<16|G[i+3|0]<<24);F[j+16>>2]=f;F[j+20>>2]=b;F[e+8>>2]=i;b=g;i=h+8|0;b=i>>>0<8?b+1|0:b;if(c>>>0<i>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break b}f=f+m|0;f=G[f|0]|G[f+1|0]<<8|(G[f+2|0]<<16|G[f+3|0]<<24);F[j+16>>2]=i;F[j+20>>2]=b;F[e+12>>2]=f;f=c;b=g;c=h+12|0;b=c>>>0<12?b+1|0:b;if(c>>>0>f>>>0&(b|0)>=(d|0)|(b|0)>(d|0)){break b}d=i+m|0;d=G[d|0]|G[d+1|0]<<8|(G[d+2|0]<<16|G[d+3|0]<<24);F[j+16>>2]=c;F[j+20>>2]=b;F[e+16>>2]=d;mb(F[a+44>>2]+96|0,e+8|0);k=k+1|0;if((k|0)!=(l|0)){continue}break}}F[F[a+4>>2]+80>>2]=n;k=1;break a}k=0;}Z=e+32|0;return k|0}function te(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;g=Z-16|0;Z=g;f=1;m=$[F[F[a>>2]+24>>2]](a)|0;a:{if((m|0)<=0){break a}r=a+48|0;f=0;while(1){b:{c:{if(!F[($[F[F[a>>2]+28>>2]](a)|0)+40>>2]){break c}o=l<<2;d=F[o+F[a+36>>2]>>2];c=F[d+8>>2];e=bb(d);if(!e){break c}h=F[($[F[F[a>>2]+28>>2]](a)|0)+40>>2];F[g+12>>2]=F[c+56>>2];d=ka(32);F[g>>2]=d;F[g+4>>2]=24;F[g+8>>2]=-2147483616;c=G[1196]|G[1197]<<8|(G[1198]<<16|G[1199]<<24);b=G[1192]|G[1193]<<8|(G[1194]<<16|G[1195]<<24);D[d+16|0]=b;D[d+17|0]=b>>>8;D[d+18|0]=b>>>16;D[d+19|0]=b>>>24;D[d+20|0]=c;D[d+21|0]=c>>>8;D[d+22|0]=c>>>16;D[d+23|0]=c>>>24;c=G[1188]|G[1189]<<8|(G[1190]<<16|G[1191]<<24);b=G[1184]|G[1185]<<8|(G[1186]<<16|G[1187]<<24);D[d+8|0]=b;D[d+9|0]=b>>>8;D[d+10|0]=b>>>16;D[d+11|0]=b>>>24;D[d+12|0]=c;D[d+13|0]=c>>>8;D[d+14|0]=c>>>16;D[d+15|0]=c>>>24;c=G[1180]|G[1181]<<8|(G[1182]<<16|G[1183]<<24);b=G[1176]|G[1177]<<8|(G[1178]<<16|G[1179]<<24);D[d|0]=b;D[d+1|0]=b>>>8;D[d+2|0]=b>>>16;D[d+3|0]=b>>>24;D[d+4|0]=c;D[d+5|0]=c>>>8;D[d+6|0]=c>>>16;D[d+7|0]=c>>>24;D[d+24|0]=0;c=h+16|0;b=F[c>>2];d:{e:{if(!b){break e}i=F[g+12>>2];d=c;while(1){k=(i|0)>F[b+16>>2];d=k?d:b;b=F[(k?b+4|0:b)>>2];if(b){continue}break}if((c|0)==(d|0)|(i|0)<F[d+16>>2]){break e}b=F[d+24>>2];if(!b){break e}i=d+20|0;d=G[g+11|0];c=d<<24>>24<0;k=c?F[g>>2]:g;d=c?F[g+4>>2]:d;while(1){c=G[b+27|0];j=c<<24>>24<0;c=j?F[b+20>>2]:c;p=c>>>0<d>>>0;f:{g:{h:{i:{j:{k:{n=p?c:d;if(n){j=j?F[b+16>>2]:b+16|0;q=sa(k,j,n);if(q){break k}if(c>>>0<=d>>>0){break j}break f}if(c>>>0<=d>>>0){break i}break f}if((q|0)<0){break f}}c=sa(j,k,n);if(c){break h}}if(p){break g}d=gc(i,g);break d}if((c|0)<0){break g}d=gc(i,g);break d}b=b+4|0;}b=F[b>>2];if(b){continue}break}}d=gc(h,g);}if(D[g+11|0]<0){ja(F[g>>2]);}if(!d){break c}d=0;c=F[F[o+F[a+36>>2]>>2]+8>>2];if(!F[c+64>>2]){b=ka(32);F[b+16>>2]=0;F[b+20>>2]=0;F[b+8>>2]=0;F[b>>2]=0;F[b+4>>2]=0;F[b+24>>2]=0;F[b+28>>2]=0;f=F[c+64>>2];F[c+64>>2]=b;if(f){b=F[f>>2];if(b){F[f+4>>2]=b;ja(b);}ja(f);b=F[c+64>>2];}F[c>>2]=b;f=F[b+20>>2];F[c+8>>2]=F[b+16>>2];F[c+12>>2]=f;f=F[b+24>>2];b=F[b+28>>2];F[c+48>>2]=0;F[c+52>>2]=0;F[c+40>>2]=0;F[c+44>>2]=0;F[c+16>>2]=f;F[c+20>>2]=b;}l:{D[c+24|0]=G[e+24|0];F[c+28>>2]=F[e+28>>2];D[c+32|0]=G[e+32|0];b=F[e+44>>2];F[c+40>>2]=F[e+40>>2];F[c+44>>2]=b;b=F[e+52>>2];F[c+48>>2]=F[e+48>>2];F[c+52>>2]=b;F[c+56>>2]=F[e+56>>2];b=F[e+12>>2];F[c+8>>2]=F[e+8>>2];F[c+12>>2]=b;b=F[e+20>>2];F[c+16>>2]=F[e+16>>2];F[c+20>>2]=b;F[c+60>>2]=F[e+60>>2];f=F[e>>2];m:{if(!f){F[c>>2]=0;b=1;break m}h=F[c>>2];b=0;if(!h){break m}b=F[f>>2];f=F[f+4>>2]-b|0;md(h,b,f,0);b=1;}if(!b){break l}D[c+84|0]=G[e+84|0];F[c+80>>2]=F[e+80>>2];if((c|0)!=(e|0)){gb(c+68|0,F[e+68>>2],F[e+72>>2]);}n:{h=F[e+88>>2];o:{if(h){f=ka(40);e=F[h>>2];F[f+16>>2]=0;F[f+8>>2]=0;F[f+12>>2]=0;F[f>>2]=e;e=F[h+12>>2];b=F[h+8>>2];if((e|0)!=(b|0)){b=e-b|0;if((b|0)<0){break n}e=ka(b);F[f+12>>2]=e;F[f+8>>2]=e;F[f+16>>2]=b+e;b=F[h+8>>2];i=F[h+12>>2];p:{if((b|0)==(i|0)){break p}k=i+(b^-1)|0;j=i-b&7;if(j){while(1){D[e|0]=G[b|0];e=e+1|0;b=b+1|0;d=d+1|0;if((j|0)!=(d|0)){continue}break}}if(k>>>0<7){break p}while(1){D[e|0]=G[b|0];D[e+1|0]=G[b+1|0];D[e+2|0]=G[b+2|0];D[e+3|0]=G[b+3|0];D[e+4|0]=G[b+4|0];D[e+5|0]=G[b+5|0];D[e+6|0]=G[b+6|0];D[e+7|0]=G[b+7|0];e=e+8|0;b=b+8|0;if((i|0)!=(b|0)){continue}break}}F[f+12>>2]=e;}d=F[h+36>>2];F[f+32>>2]=F[h+32>>2];F[f+36>>2]=d;d=F[h+28>>2];F[f+24>>2]=F[h+24>>2];F[f+28>>2]=d;e=F[c+88>>2];F[c+88>>2]=f;if(e){break o}break l}e=F[c+88>>2];F[c+88>>2]=0;if(!e){break l}}d=F[e+8>>2];if(d){F[e+12>>2]=d;ja(d);}ja(e);break l}na();v();}break b}d=F[F[a+36>>2]+(l<<2)>>2];if(!($[F[F[d>>2]+24>>2]](d,r)|0)){break a}}l=l+1|0;f=(m|0)<=(l|0);if((l|0)!=(m|0)){continue}break}}Z=g+16|0;return f|0}function Ld(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;g=Z+-64|0;Z=g;F[g+56>>2]=0;F[g+48>>2]=0;F[g+52>>2]=0;F[g+40>>2]=0;F[g+44>>2]=0;F[g+32>>2]=0;F[g+36>>2]=0;F[g+24>>2]=0;F[g+28>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;F[g+8>>2]=0;F[g+12>>2]=0;h=g+8|0;a:{b:{if(!H[b+38>>1]){break b}if(!Ta(1,h+12|0,b)){break b}e=F[b+8>>2];f=F[b+16>>2];j=e-f|0;k=F[h+12>>2];e=F[b+12>>2]-(F[b+20>>2]+(e>>>0<f>>>0)|0)|0;if(j>>>0<k>>>6>>>0&(e|0)<=0|(e|0)<0){break b}e=F[h>>2];d=F[h+4>>2]-e>>2;c:{if(d>>>0<k>>>0){qa(h,k-d|0);k=F[h+12>>2];break c}if(d>>>0<=k>>>0){break c}F[h+4>>2]=e+(k<<2);}i=1;if(!k){break a}e=F[b+16>>2];d=F[b+20>>2];r=F[h>>2];l=F[b+8>>2];o=F[b+12>>2];j=0;while(1){i=0;if((d|0)>=(o|0)&e>>>0>=l>>>0|(d|0)>(o|0)){break a}i=F[b>>2];p=G[i+e|0];e=e+1|0;d=e?d:d+1|0;F[b+16>>2]=e;F[b+20>>2]=d;f=p>>>2|0;m=0;d:{e:{f:{g:{s=p&3;switch(s|0){case 3:break g;case 0:break e;default:break f}}f=f+j|0;i=0;if(f>>>0>=k>>>0){break a}ma(r+(j<<2)|0,0,(p&252)+4|0);j=f;break d}while(1){if((e|0)==(l|0)&(d|0)==(o|0)){break b}k=G[e+i|0];e=e+1|0;d=e?d:d+1|0;F[b+16>>2]=e;F[b+20>>2]=d;f=k<<(m<<3|6)|f;m=m+1|0;if((s|0)!=(m|0)){continue}break}}F[r+(j<<2)>>2]=f;}j=j+1|0;k=F[h+12>>2];if(j>>>0<k>>>0){continue}break}d=h+16|0;o=F[h>>2];f=F[h+16>>2];e=F[h+20>>2]-f|0;h:{if(e>>>0<=4194303){qa(d,1048576-(e>>>2|0)|0);break h}if((e|0)==4194304){break h}F[h+20>>2]=f+4194304;}e=h+28|0;j=F[e>>2];f=F[h+32>>2]-j>>3;i:{if(f>>>0<k>>>0){_a(e,k-f|0);j=F[e>>2];break i}if(f>>>0>k>>>0){F[h+32>>2]=(k<<3)+j;}if(!k){break b}}l=F[d>>2];d=0;i=0;while(1){e=o+(d<<2)|0;h=F[e>>2];m=(d<<3)+j|0;f=i;F[m+4>>2]=f;F[m>>2]=h;e=F[e>>2];i=e+f|0;if(i>>>0>1048576){break b}j:{if(f>>>0>=i>>>0){break j}m=0;h=e&7;if(h){while(1){F[l+(f<<2)>>2]=d;f=f+1|0;m=m+1|0;if((h|0)!=(m|0)){continue}break}}if(e-1>>>0<=6){break j}while(1){e=l+(f<<2)|0;F[e>>2]=d;F[e+28>>2]=d;F[e+24>>2]=d;F[e+20>>2]=d;F[e+16>>2]=d;F[e+12>>2]=d;F[e+8>>2]=d;F[e+4>>2]=d;f=f+8|0;if((i|0)!=(f|0)){continue}break}}d=d+1|0;if((k|0)!=(d|0)){continue}break}n=(i|0)==1048576;}i=n;}k:{if(!i|(F[g+20>>2]?0:a)){break k}i=0;j=Z-16|0;Z=j;l:{if(!Sa(1,j+8|0,b)){break l}d=F[b+8>>2];f=F[b+16>>2];l=d-f|0;n=F[j+12>>2];h=F[b+20>>2];d=F[b+12>>2]-(h+(d>>>0<f>>>0)|0)|0;e=F[j+8>>2];if((n|0)==(d|0)&e>>>0>l>>>0|d>>>0<n>>>0){break l}d=h+n|0;l=e+f|0;d=l>>>0<f>>>0?d+1|0:d;F[b+16>>2]=l;F[b+20>>2]=d;if((e|0)<=0){break l}b=f+F[b>>2]|0;F[g+48>>2]=b;d=e-1|0;f=d+b|0;l=G[f|0];m:{if(l>>>0<=63){F[g+52>>2]=d;b=G[f|0]&63;break m}n:{switch((l>>>6|0)-1|0){case 0:if(e>>>0<2){break l}d=e-2|0;F[g+52>>2]=d;b=b+d|0;b=G[b+1|0]<<8&16128|G[b|0];break m;case 1:if(e>>>0<3){break l}d=e-3|0;F[g+52>>2]=d;b=b+d|0;b=G[b+1|0]<<8|G[b+2|0]<<16&4128768|G[b|0];break m;default:break n}}d=e-4|0;F[g+52>>2]=d;b=b+d|0;b=(G[b|0]|G[b+1|0]<<8|(G[b+2|0]<<16|G[b+3|0]<<24))&1073741823;}F[g+56>>2]=b+4194304;i=b>>>0<1069547520;}Z=j+16|0;if(!i){break k}if(!a){t=1;break k}b=F[g+52>>2];f=F[g+56>>2];d=F[g+36>>2];e=F[g+48>>2];j=F[g+24>>2];while(1){o:{if(f>>>0>4194303){break o}while(1){if((b|0)<=0){break o}b=b-1|0;F[g+52>>2]=b;f=G[b+e|0]|f<<8;F[g+56>>2]=f;if(f>>>0<4194304){continue}break}}i=f&1048575;l=F[j+(i<<2)>>2];n=d+(l<<3)|0;f=(L(F[n>>2],f>>>20|0)+i|0)-F[n+4>>2]|0;F[g+56>>2]=f;F[(q<<2)+c>>2]=l;t=1;q=q+1|0;if((q|0)!=(a|0)){continue}break}}a=F[g+36>>2];if(a){F[g+40>>2]=a;ja(a);}a=F[g+24>>2];if(a){F[g+28>>2]=a;ja(a);}a=F[g+8>>2];if(a){F[g+12>>2]=a;ja(a);}Z=g- -64|0;return t}function kh(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=M(0),f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=M(0),p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;if(F[c>>2]==F[c+4>>2]){m=F[d+80>>2];u=Z-16|0;Z=u;g=F[a+4>>2];k=G[b+24|0];h=F[d+48>>2];n=F[F[d>>2]>>2];c=u+8|0;F[c>>2]=1065353216;d=c;J[c>>2]=M(-1<<g^-1)/J[a+20>>2];c=ka(k<<2);a:{if(!m|!k){break a}p=h+n|0;o=J[d>>2];n=F[a+8>>2];v=F[b>>2];d=F[b+48>>2];g=F[b+40>>2];w=F[b+44>>2];if(!G[b+84|0]){f=F[b+68>>2];s=k&254;t=k&1;a=0;while(1){b=F[v>>2];l=ki(g,w,F[f+(i<<2)>>2],0)+d|0;h=la(c,b+l|0,g);b=0;q=0;if((k|0)!=1){while(1){l=p+(a<<2)|0;j=b<<2;e=M(R(M(M(o*M(J[j+h>>2]-J[n+j>>2]))+M(.5))));b:{if(M(N(e))<M(2147483648)){r=~~e;break b}r=-2147483648;}F[l>>2]=r;j=j|4;e=M(R(M(M(o*M(J[j+h>>2]-J[n+j>>2]))+M(.5))));c:{if(M(N(e))<M(2147483648)){j=~~e;break c}j=-2147483648;}F[l+4>>2]=j;b=b+2|0;a=a+2|0;q=q+2|0;if((s|0)!=(q|0)){continue}break}}if(t){l=p+(a<<2)|0;b=b<<2;e=M(R(M(M(o*M(J[b+h>>2]-J[b+n>>2]))+M(.5))));d:{if(M(N(e))<M(2147483648)){b=~~e;break d}b=-2147483648;}F[l>>2]=b;a=a+1|0;}i=i+1|0;if((m|0)!=(i|0)){continue}break}break a}s=k&254;t=k&1;a=0;while(1){b=F[v>>2];h=ki(g,w,i,l)+d|0;j=la(c,b+h|0,g);b=0;q=0;if((k|0)!=1){while(1){h=p+(a<<2)|0;f=b<<2;e=M(R(M(M(o*M(J[f+j>>2]-J[f+n>>2]))+M(.5))));e:{if(M(N(e))<M(2147483648)){r=~~e;break e}r=-2147483648;}F[h>>2]=r;f=f|4;e=M(R(M(M(o*M(J[f+j>>2]-J[f+n>>2]))+M(.5))));f:{if(M(N(e))<M(2147483648)){f=~~e;break f}f=-2147483648;}F[h+4>>2]=f;b=b+2|0;a=a+2|0;q=q+2|0;if((s|0)!=(q|0)){continue}break}}if(t){h=p+(a<<2)|0;b=b<<2;e=M(R(M(M(o*M(J[b+j>>2]-J[b+n>>2]))+M(.5))));g:{if(M(N(e))<M(2147483648)){b=~~e;break g}b=-2147483648;}F[h>>2]=b;a=a+1|0;}b=l;i=i+1|0;b=i?b:b+1|0;l=b;if((i|0)!=(m|0)|b){continue}break}}ja(c);Z=u+16|0;return 1}j=Z-16|0;Z=j;m=F[a+4>>2];i=G[b+24|0];g=F[d+48>>2];h=F[F[d>>2]>>2];d=j+8|0;F[d>>2]=1065353216;l=d;J[d>>2]=M(-1<<m^-1)/J[a+20>>2];d=ka(i<<2);m=F[c+4>>2];q=F[c>>2];h:{if(!i|(m|0)==(q|0)){break h}n=h+g|0;c=m-q>>2;u=c>>>0<=1?1:c;o=J[l>>2];h=F[a+8>>2];v=F[b>>2];l=F[b+48>>2];m=F[b+40>>2];w=F[b+44>>2];if(G[b+84|0]){s=i&254;t=i&1;a=0;c=0;while(1){b=F[v>>2];g=ki(m,w,F[q+(c<<2)>>2],0)+l|0;p=la(d,b+g|0,m);b=0;k=0;if((i|0)!=1){while(1){g=n+(a<<2)|0;f=b<<2;e=M(R(M(M(o*M(J[f+p>>2]-J[h+f>>2]))+M(.5))));i:{if(M(N(e))<M(2147483648)){r=~~e;break i}r=-2147483648;}F[g>>2]=r;f=f|4;e=M(R(M(M(o*M(J[f+p>>2]-J[h+f>>2]))+M(.5))));j:{if(M(N(e))<M(2147483648)){f=~~e;break j}f=-2147483648;}F[g+4>>2]=f;b=b+2|0;a=a+2|0;k=k+2|0;if((s|0)!=(k|0)){continue}break}}if(t){g=n+(a<<2)|0;b=b<<2;e=M(R(M(M(o*M(J[b+p>>2]-J[b+h>>2]))+M(.5))));k:{if(M(N(e))<M(2147483648)){b=~~e;break k}b=-2147483648;}F[g>>2]=b;a=a+1|0;}c=c+1|0;if((u|0)!=(c|0)){continue}break}break h}s=F[b+68>>2];t=i&254;x=i&1;a=0;c=0;while(1){b=F[v>>2];g=ki(m,w,F[s+(F[q+(c<<2)>>2]<<2)>>2],0)+l|0;p=la(d,b+g|0,m);b=0;k=0;if((i|0)!=1){while(1){g=n+(a<<2)|0;f=b<<2;e=M(R(M(M(o*M(J[f+p>>2]-J[h+f>>2]))+M(.5))));l:{if(M(N(e))<M(2147483648)){r=~~e;break l}r=-2147483648;}F[g>>2]=r;f=f|4;e=M(R(M(M(o*M(J[f+p>>2]-J[h+f>>2]))+M(.5))));m:{if(M(N(e))<M(2147483648)){f=~~e;break m}f=-2147483648;}F[g+4>>2]=f;b=b+2|0;a=a+2|0;k=k+2|0;if((t|0)!=(k|0)){continue}break}}if(x){g=n+(a<<2)|0;b=b<<2;e=M(R(M(M(o*M(J[b+p>>2]-J[b+h>>2]))+M(.5))));n:{if(M(N(e))<M(2147483648)){b=~~e;break n}b=-2147483648;}F[g>>2]=b;a=a+1|0;}c=c+1|0;if((u|0)!=(c|0)){continue}break}}ja(d);Z=j+16|0;return 1}
function Cd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=F[a+4>>2];e=F[a>>2];f=(c-e|0)/144|0;if(f>>>0<b>>>0){e=a;b=b-f|0;h=F[a+8>>2];c=F[a+4>>2];a:{if(b>>>0<=(h-c|0)/144>>>0){b:{if(!b){break b}a=c;f=b&7;if(f){while(1){va(a);a=a+144|0;d=d+1|0;if((f|0)!=(d|0)){continue}break}}c=L(b,144)+c|0;if((b-1&268435455)>>>0<7){break b}while(1){va(a);va(a+144|0);va(a+288|0);va(a+432|0);va(a+576|0);va(a+720|0);va(a+864|0);va(a+1008|0);a=a+1152|0;if((c|0)!=(a|0)){continue}break}}F[e+4>>2]=c;break a}c:{d:{e:{a=c;c=F[e>>2];i=(a-c|0)/144|0;a=i+b|0;if(a>>>0<29826162){c=(h-c|0)/144|0;f=c<<1;f=c>>>0>=14913080?29826161:a>>>0<f>>>0?f:a;if(f){if(f>>>0>=29826162){break e}g=ka(L(f,144));}c=L(i,144)+g|0;a=c;h=b&7;if(h){while(1){va(a);a=a+144|0;d=d+1|0;if((h|0)!=(d|0)){continue}break}}h=L(b,144)+c|0;if((b-1&268435455)>>>0>=7){while(1){va(a);va(a+144|0);va(a+288|0);va(a+432|0);va(a+576|0);va(a+720|0);va(a+864|0);va(a+1008|0);a=a+1152|0;if((h|0)!=(a|0)){continue}break}}b=L(f,144)+g|0;d=F[e+4>>2];f=F[e>>2];if((d|0)==(f|0)){break d}while(1){c=c-144|0;d=d-144|0;a=d;F[c>>2]=F[a>>2];F[c+4>>2]=F[a+4>>2];F[c+8>>2]=F[a+8>>2];F[c+12>>2]=F[a+12>>2];F[a+12>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[c+16>>2]=F[a+16>>2];F[c+20>>2]=F[a+20>>2];F[c+24>>2]=F[a+24>>2];F[a+24>>2]=0;F[a+16>>2]=0;F[a+20>>2]=0;g=G[a+28|0];F[c+40>>2]=0;F[c+32>>2]=0;F[c+36>>2]=0;D[c+28|0]=g;F[c+32>>2]=F[a+32>>2];F[c+36>>2]=F[a+36>>2];F[c+40>>2]=F[a+40>>2];F[a+40>>2]=0;F[a+32>>2]=0;F[a+36>>2]=0;F[c+52>>2]=0;F[c+44>>2]=0;F[c+48>>2]=0;F[c+44>>2]=F[a+44>>2];F[c+48>>2]=F[a+48>>2];F[c+52>>2]=F[a+52>>2];F[a+52>>2]=0;F[a+44>>2]=0;F[a+48>>2]=0;g=c- -64|0;F[g>>2]=0;F[c+56>>2]=0;F[c+60>>2]=0;F[c+56>>2]=F[a+56>>2];F[c+60>>2]=F[a+60>>2];i=g;g=a- -64|0;F[i>>2]=F[g>>2];F[g>>2]=0;F[a+56>>2]=0;F[a+60>>2]=0;F[c+68>>2]=F[a+68>>2];g=F[a+72>>2];F[c+84>>2]=0;F[c+76>>2]=0;F[c+80>>2]=0;F[c+72>>2]=g;F[c+76>>2]=F[a+76>>2];F[c+80>>2]=F[a+80>>2];F[c+84>>2]=F[a+84>>2];F[a+84>>2]=0;F[a+76>>2]=0;F[a+80>>2]=0;F[c+96>>2]=0;F[c+88>>2]=0;F[c+92>>2]=0;F[c+88>>2]=F[a+88>>2];F[c+92>>2]=F[a+92>>2];F[c+96>>2]=F[a+96>>2];F[a+96>>2]=0;F[a+88>>2]=0;F[a+92>>2]=0;g=G[a+100|0];F[c+112>>2]=0;F[c+104>>2]=0;F[c+108>>2]=0;D[c+100|0]=g;F[c+104>>2]=F[a+104>>2];F[c+108>>2]=F[a+108>>2];F[c+112>>2]=F[a+112>>2];F[a+112>>2]=0;F[a+104>>2]=0;F[a+108>>2]=0;F[c+124>>2]=0;F[c+116>>2]=0;F[c+120>>2]=0;F[c+116>>2]=F[a+116>>2];F[c+120>>2]=F[a+120>>2];F[c+124>>2]=F[a+124>>2];F[a+124>>2]=0;F[a+116>>2]=0;F[a+120>>2]=0;g=F[a+128>>2];F[c+140>>2]=0;F[c+132>>2]=0;F[c+136>>2]=0;F[c+128>>2]=g;F[c+132>>2]=F[a+132>>2];F[c+136>>2]=F[a+136>>2];F[c+140>>2]=F[a+140>>2];F[a+140>>2]=0;F[a+132>>2]=0;F[a+136>>2]=0;if((a|0)!=(f|0)){continue}break}F[e+8>>2]=b;a=F[e+4>>2];F[e+4>>2]=h;d=F[e>>2];F[e>>2]=c;if((a|0)==(d|0)){break c}while(1){b=a-144|0;c=F[b+132>>2];if(c){F[a-8>>2]=c;ja(c);}c=F[a-28>>2];if(c){F[a-24>>2]=c;ja(c);}c=F[a-40>>2];if(c){F[a-36>>2]=c;ja(c);}Gb(a-140|0);a=b;if((d|0)!=(a|0)){continue}break}break c}na();v();}oa();v();}F[e+8>>2]=b;F[e+4>>2]=h;F[e>>2]=c;}if(d){ja(d);}}return}if(b>>>0<f>>>0){e=e+L(b,144)|0;if((e|0)!=(c|0)){while(1){b=c-144|0;d=F[b+132>>2];if(d){F[c-8>>2]=d;ja(d);}d=F[c-28>>2];if(d){F[c-24>>2]=d;ja(d);}d=F[c-40>>2];if(d){F[c-36>>2]=d;ja(d);}Gb(c-140|0);c=b;if((e|0)!=(c|0)){continue}break}}F[a+4>>2]=e;}}function Yc(a){var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;F[a+56>>2]=F[a+52>>2];F[a+44>>2]=F[a+40>>2];b=F[a+64>>2];c=F[b+24>>2];if((c|0)==F[b+28>>2]){return 1}a:{b:{c:{while(1){g=i;i=F[(k<<2)+c>>2];d:{if((i|0)==-1){i=g;break d}b=F[a+56>>2];e:{if((b|0)!=F[a+60>>2]){F[b>>2]=g;F[a+56>>2]=b+4;break e}d=F[a+52>>2];e=b-d|0;h=e>>2;c=h+1|0;if(c>>>0>=1073741824){break c}f=e>>>1|0;f=e>>>0>=2147483644?1073741823:c>>>0<f>>>0?f:c;if(f){if(f>>>0>=1073741824){break b}e=ka(f<<2);}else {e=0;}c=e+(h<<2)|0;F[c>>2]=g;h=c+4|0;if((b|0)!=(d|0)){while(1){c=c-4|0;b=b-4|0;F[c>>2]=F[b>>2];if((b|0)!=(d|0)){continue}break}}F[a+60>>2]=e+(f<<2);F[a+56>>2]=h;F[a+52>>2]=c;if(!d){break e}ja(d);}f:{g:{if(!(F[F[a+12>>2]+(k>>>3&536870908)>>2]>>>k&1)){break g}e=i+1|0;e=(e>>>0)%3|0?e:i-2|0;if((e|0)==-1|F[F[a>>2]+(e>>>3&536870908)>>2]>>>e&1){break g}e=F[F[F[a+64>>2]+12>>2]+(e<<2)>>2];if((e|0)==-1){break g}b=e+1|0;b=(b>>>0)%3|0?b:e-2|0;if((b|0)==-1){break g}c=F[a+64>>2];f=F[a>>2];while(1){e=b;b=-1;d=e+1|0;d=(d>>>0)%3|0?d:e-2|0;h:{if((d|0)==-1|F[f+(d>>>3&536870908)>>2]>>>d&1){break h}d=F[F[c+12>>2]+(d<<2)>>2];if((d|0)==-1){break h}b=d+1|0;b=(b>>>0)%3|0?b:d-2|0;}if((b|0)!=(i|0)){if((b|0)==-1){break f}continue}break}return 0}e=i;}F[F[a+28>>2]+(e<<2)>>2]=g;b=F[a+44>>2];i:{if((b|0)!=F[a+48>>2]){F[b>>2]=e;F[a+44>>2]=b+4;break i}d=F[a+40>>2];i=b-d|0;h=i>>2;c=h+1|0;if(c>>>0>=1073741824){break a}f=i>>>1|0;f=i>>>0>=2147483644?1073741823:c>>>0<f>>>0?f:c;if(f){if(f>>>0>=1073741824){break b}i=ka(f<<2);}else {i=0;}c=i+(h<<2)|0;F[c>>2]=e;h=c+4|0;if((b|0)!=(d|0)){while(1){c=c-4|0;b=b-4|0;F[c>>2]=F[b>>2];if((b|0)!=(d|0)){continue}break}}F[a+48>>2]=i+(f<<2);F[a+44>>2]=h;F[a+40>>2]=c;if(!d){break i}ja(d);}i=g+1|0;b=F[a+64>>2];if((e|0)==-1){break d}j:{if((e>>>0)%3|0){c=e-1|0;break j}c=e+2|0;if((c|0)==-1){break d}}d=F[F[b+12>>2]+(c<<2)>>2];if((d|0)==-1){break d}f=d+((d>>>0)%3|0?-1:2)|0;if((f|0)==-1|(e|0)==(f|0)){break d}while(1){b=f+1|0;b=(b>>>0)%3|0?b:f-2|0;if(F[F[a>>2]+(b>>>3&536870908)>>2]>>>b&1){b=F[a+56>>2];k:{if((b|0)!=F[a+60>>2]){F[b>>2]=i;F[a+56>>2]=b+4;break k}d=F[a+52>>2];g=b-d|0;j=g>>2;c=j+1|0;if(c>>>0>=1073741824){break c}h=g>>>1|0;h=g>>>0>=2147483644?1073741823:c>>>0<h>>>0?h:c;if(h){if(h>>>0>=1073741824){break b}g=ka(h<<2);}else {g=0;}c=g+(j<<2)|0;F[c>>2]=i;j=c+4|0;if((b|0)!=(d|0)){while(1){c=c-4|0;b=b-4|0;F[c>>2]=F[b>>2];if((b|0)!=(d|0)){continue}break}}F[a+60>>2]=g+(h<<2);F[a+56>>2]=j;F[a+52>>2]=c;if(!d){break k}ja(d);}d=i+1|0;b=F[a+44>>2];l:{if((b|0)!=F[a+48>>2]){F[b>>2]=f;F[a+44>>2]=b+4;break l}h=F[a+40>>2];g=b-h|0;l=g>>2;c=l+1|0;if(c>>>0>=1073741824){break a}j=g>>>1|0;j=g>>>0>=2147483644?1073741823:c>>>0<j>>>0?j:c;if(j){if(j>>>0>=1073741824){break b}g=ka(j<<2);}else {g=0;}c=g+(l<<2)|0;F[c>>2]=f;l=c+4|0;if((b|0)!=(h|0)){while(1){c=c-4|0;b=b-4|0;F[c>>2]=F[b>>2];if((b|0)!=(h|0)){continue}break}}F[a+48>>2]=g+(j<<2);F[a+44>>2]=l;F[a+40>>2]=c;if(!h){break l}ja(h);}g=i;i=d;}F[F[a+28>>2]+(f<<2)>>2]=g;b=F[a+64>>2];m:{if((f>>>0)%3|0){c=f-1|0;break m}c=f+2|0;if((c|0)==-1){break d}}d=F[F[b+12>>2]+(c<<2)>>2];if((d|0)==-1){break d}f=d+((d>>>0)%3|0?-1:2)|0;if((f|0)==-1){break d}if((e|0)!=(f|0)){continue}break}}k=k+1|0;c=F[b+24>>2];if(k>>>0<F[b+28>>2]-c>>2>>>0){continue}break}return 1}na();v();}oa();v();}na();v();}function Kb(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0,x=0,y=0;f=Z-96|0;Z=f;e=F[a+16>>2];D[f+92|0]=1;F[f+88>>2]=b;F[f+84>>2]=b;F[f+80>>2]=e;a:{if((b|0)==-1){break a}j=F[a+20>>2];d=F[j>>2];e=F[F[e>>2]+(b<<2)>>2];if(e>>>0>=F[j+4>>2]-d>>2>>>0){break a}e=F[F[a+8>>2]+(F[d+(e<<2)>>2]<<2)>>2];d=F[a+4>>2];if(!G[d+84|0]){e=F[F[d+68>>2]+(e<<2)>>2];}F[f+72>>2]=0;F[f+76>>2]=0;j=f- -64|0;F[j>>2]=0;F[j+4>>2]=0;F[f+56>>2]=0;F[f+60>>2]=0;Ga(d,e,D[d+24|0],f+56|0);e=b+1|0;j=(e>>>0)%3|0?e:b-2|0;n=((b>>>0)%3|0?-1:2)+b|0;b:{c:{while(1){d=j;e=n;d:{if(!F[a+28>>2]){break d}e=b+1|0;d=(e>>>0)%3|0?e:b-2|0;e=b-1|0;if((b>>>0)%3|0){break d}e=b+2|0;}if((d|0)==-1){break b}m=F[a+20>>2];b=F[m>>2];d=F[F[F[a+16>>2]>>2]+(d<<2)>>2];if(d>>>0>=F[m+4>>2]-b>>2>>>0){break b}d=F[F[a+8>>2]+(F[(d<<2)+b>>2]<<2)>>2];b=F[a+4>>2];if(!G[b+84|0]){d=F[F[b+68>>2]+(d<<2)>>2];}F[f+48>>2]=0;F[f+52>>2]=0;F[f+40>>2]=0;F[f+44>>2]=0;F[f+32>>2]=0;F[f+36>>2]=0;Ga(b,d,D[b+24|0],f+32|0);if((e|0)==-1){break c}d=F[a+20>>2];b=F[d>>2];e=F[F[F[a+16>>2]>>2]+(e<<2)>>2];if(e>>>0>=F[d+4>>2]-b>>2>>>0){break c}d=F[F[a+8>>2]+(F[b+(e<<2)>>2]<<2)>>2];b=F[a+4>>2];if(!G[b+84|0]){d=F[F[b+68>>2]+(d<<2)>>2];}F[f+24>>2]=0;F[f+28>>2]=0;F[f+16>>2]=0;F[f+20>>2]=0;F[f+8>>2]=0;F[f+12>>2]=0;Ga(b,d,D[b+24|0],f+8|0);g=F[f+8>>2];b=F[f+56>>2];d=g-b|0;p=F[f+60>>2];t=F[f+12>>2]-(p+(b>>>0>g>>>0)|0)|0;i=F[f+40>>2];e=F[f+64>>2];m=i-e|0;u=F[f+68>>2];y=F[f+44>>2]-(u+(e>>>0>i>>>0)|0)|0;g=ki(d,t,m,y);w=o-g|0;x=h-(_+(g>>>0>o>>>0)|0)|0;h=w;i=F[f+16>>2];g=i-e|0;u=F[f+20>>2]-((e>>>0>i>>>0)+u|0)|0;k=F[f+32>>2];i=k-b|0;w=F[f+36>>2]-((b>>>0>k>>>0)+p|0)|0;b=ki(g,u,i,w);o=h+b|0;h=_+x|0;h=b>>>0>o>>>0?h+1|0:h;b=l;l=d;p=t;k=F[f+48>>2];e=F[f+72>>2];d=k-e|0;t=F[f+76>>2];x=F[f+52>>2]-(t+(e>>>0>k>>>0)|0)|0;l=ki(l,p,d,x);k=b+l|0;b=_+q|0;b=k>>>0<l>>>0?b+1|0:b;l=F[f+24>>2];p=l-e|0;e=F[f+28>>2]-((e>>>0>l>>>0)+t|0)|0;q=ki(p,e,i,w);l=k-q|0;q=b-(_+(k>>>0<q>>>0)|0)|0;b=ki(g,u,d,x);d=r-b|0;b=s-(_+(b>>>0>r>>>0)|0)|0;s=ki(p,e,m,y);r=s+d|0;b=_+b|0;s=r>>>0<s>>>0?b+1|0:b;nc(f+80|0);b=F[f+88>>2];if((b|0)!=-1){continue}break}b=s>>31;e=b^r;d=e-b|0;b=(b^s)-((b>>>0>e>>>0)+b|0)|0;n=-1;e=2147483647;m=q>>31;g=m;i=g^l;j=i-g|0;m=(g^q)-((i>>>0<g>>>0)+g|0)|0;i=m;k=j^-1;g=i^2147483647;m=h;e:{f:{if(!F[a+28>>2]){if((b|0)==(g|0)&d>>>0>k>>>0|b>>>0>g>>>0){break e}b=b+i|0;a=d+j|0;b=a>>>0<j>>>0?b+1|0:b;e=a;g=h;a=g>>31;d=a;n=d^o;a=n-d|0;h=a;d=(d^g)-((d>>>0>n>>>0)+d|0)|0;a=a+e|0;d=d^2147483647;h=(d|0)==(b|0)&(h^-1)>>>0<e>>>0|b>>>0>d>>>0;a=h?-1:a;if(!(h&0)&(a|0)<=536870912|(a|0)<536870912){break e}b=0;a=a>>>29|0;break f}g:{if((b|0)==(g|0)&d>>>0>k>>>0|b>>>0>g>>>0){break g}b=b+i|0;a=d+j|0;b=a>>>0<j>>>0?b+1|0:b;k=h;h=h>>31;g=h;i=g^o;h=i-g|0;j=(g^k)-((g>>>0>i>>>0)+g|0)|0;g=j^2147483647;d=a;a=h;if((g|0)==(b|0)&d>>>0>(a^-1)>>>0|b>>>0>g>>>0){break g}b=b+j|0;n=a+d|0;b=n>>>0<a>>>0?b+1|0:b;e=b;if(!b&n>>>0<536870913){break e}}b=e>>>29|0;a=(e&536870911)<<3|n>>>29;}o=li(o,m,a,b);l=li(l,q,a,b);r=li(r,s,a,b);}F[c+8>>2]=o;F[c+4>>2]=l;F[c>>2]=r;Z=f+96|0;return}ta();v();}ta();v();}ta();v();}function Nc(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{if((b|0)<0){break a}c=F[a+12>>2];d=F[a+8>>2];if(c-d>>2>>>0<=b>>>0){break a}d=d+(b<<2)|0;e=F[d>>2];i=F[e+60>>2];f=F[e+56>>2];e=d+4|0;if((e|0)!=(c|0)){while(1){h=F[e>>2];F[e>>2]=0;g=F[d>>2];F[d>>2]=h;if(g){xa(g);}d=d+4|0;e=e+4|0;if((e|0)!=(c|0)){continue}break}c=F[a+12>>2];}if((c|0)!=(d|0)){while(1){c=c-4|0;e=F[c>>2];F[c>>2]=0;if(e){xa(e);}if((c|0)!=(d|0)){continue}break}}F[a+12>>2]=d;g=F[a+4>>2];b:{if(!g|(i|0)<0){break b}c=F[g+24>>2];d=F[g+28>>2];if((c|0)==(d|0)){break b}while(1){if((i|0)==F[F[c>>2]+24>>2]){d=c+4|0;i=F[g+28>>2];if((d|0)!=(i|0)){while(1){h=F[d>>2];F[d>>2]=0;e=F[c>>2];F[c>>2]=h;if(e){Ca(e+12|0,F[e+16>>2]);Ba(e,F[e+4>>2]);ja(e);}c=c+4|0;d=d+4|0;if((i|0)!=(d|0)){continue}break}d=F[g+28>>2];}if((c|0)!=(d|0)){while(1){d=d-4|0;e=F[d>>2];F[d>>2]=0;if(e){Ca(e+12|0,F[e+16>>2]);Ba(e,F[e+4>>2]);ja(e);}if((c|0)!=(d|0)){continue}break}}F[g+28>>2]=c;break b}c=c+4|0;if((d|0)!=(c|0)){continue}break}}c:{if((f|0)>4){break c}d:{e=L(f,12)+a|0;c=F[e+20>>2];d=F[e+24>>2];if((c|0)==(d|0)){break d}while(1){if(F[c>>2]==(b|0)){break d}c=c+4|0;if((d|0)!=(c|0)){continue}break}break c}if((c|0)==(d|0)){break c}f=c;c=c+4|0;pa(f,c,d-c|0);F[e+24>>2]=d-4;}c=F[a+24>>2];d=F[a+20>>2];e:{if((c|0)==(d|0)){break e}e=c-d|0;c=e>>2;g=c>>>0<=1?1:c;i=g&1;c=0;if(e>>>0>=8){g=g&-2;e=0;while(1){f=c<<2;h=f+d|0;j=F[h>>2];if((j|0)>(b|0)){F[h>>2]=j-1;}f=d+(f|4)|0;h=F[f>>2];if((h|0)>(b|0)){F[f>>2]=h-1;}c=c+2|0;e=e+2|0;if((g|0)!=(e|0)){continue}break}}if(!i){break e}c=d+(c<<2)|0;d=F[c>>2];if((d|0)<=(b|0)){break e}F[c>>2]=d-1;}c=F[a+36>>2];d=F[a+32>>2];f:{if((c|0)==(d|0)){break f}e=c-d|0;c=e>>2;g=c>>>0<=1?1:c;i=g&1;c=0;if(e>>>0>=8){g=g&-2;e=0;while(1){f=c<<2;h=f+d|0;j=F[h>>2];if((j|0)>(b|0)){F[h>>2]=j-1;}f=d+(f|4)|0;h=F[f>>2];if((h|0)>(b|0)){F[f>>2]=h-1;}c=c+2|0;e=e+2|0;if((g|0)!=(e|0)){continue}break}}if(!i){break f}c=d+(c<<2)|0;d=F[c>>2];if((d|0)<=(b|0)){break f}F[c>>2]=d-1;}c=F[a+48>>2];d=F[a+44>>2];g:{if((c|0)==(d|0)){break g}e=c-d|0;c=e>>2;g=c>>>0<=1?1:c;i=g&1;c=0;if(e>>>0>=8){g=g&-2;e=0;while(1){f=c<<2;h=f+d|0;j=F[h>>2];if((j|0)>(b|0)){F[h>>2]=j-1;}f=d+(f|4)|0;h=F[f>>2];if((h|0)>(b|0)){F[f>>2]=h-1;}c=c+2|0;e=e+2|0;if((g|0)!=(e|0)){continue}break}}if(!i){break g}c=d+(c<<2)|0;d=F[c>>2];if((d|0)<=(b|0)){break g}F[c>>2]=d-1;}c=F[a+60>>2];d=F[a+56>>2];h:{if((c|0)==(d|0)){break h}e=c-d|0;c=e>>2;g=c>>>0<=1?1:c;i=g&1;c=0;if(e>>>0>=8){g=g&-2;e=0;while(1){f=c<<2;h=f+d|0;j=F[h>>2];if((j|0)>(b|0)){F[h>>2]=j-1;}f=d+(f|4)|0;h=F[f>>2];if((h|0)>(b|0)){F[f>>2]=h-1;}c=c+2|0;e=e+2|0;if((g|0)!=(e|0)){continue}break}}if(!i){break h}c=d+(c<<2)|0;d=F[c>>2];if((d|0)<=(b|0)){break h}F[c>>2]=d-1;}c=F[a+72>>2];a=F[a+68>>2];if((c|0)==(a|0)){break a}d=c-a|0;c=d>>2;e=c>>>0<=1?1:c;g=e&1;c=0;if(d>>>0>=8){d=e&-2;e=0;while(1){i=c<<2;f=i+a|0;h=F[f>>2];if((h|0)>(b|0)){F[f>>2]=h-1;}i=a+(i|4)|0;f=F[i>>2];if((f|0)>(b|0)){F[i>>2]=f-1;}c=c+2|0;e=e+2|0;if((d|0)!=(e|0)){continue}break}}if(!g){break a}f=b;a=a+(c<<2)|0;b=F[a>>2];if((f|0)>=(b|0)){break a}F[a>>2]=b-1;}}function ja(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;a:{if(!a){break a}d=a-8|0;b=F[a-4>>2];a=b&-8;f=d+a|0;b:{if(b&1){break b}if(!(b&3)){break a}b=F[d>>2];d=d-b|0;if(d>>>0<I[2945]){break a}a=a+b|0;if(F[2946]!=(d|0)){if(b>>>0<=255){e=F[d+8>>2];b=b>>>3|0;c=F[d+12>>2];if((c|0)==(e|0)){i=11764,j=F[2941]&oi(b),F[i>>2]=j;break b}F[e+12>>2]=c;F[c+8>>2]=e;break b}h=F[d+24>>2];b=F[d+12>>2];c:{if((d|0)!=(b|0)){c=F[d+8>>2];F[c+12>>2]=b;F[b+8>>2]=c;break c}d:{e=d+20|0;c=F[e>>2];if(c){break d}e=d+16|0;c=F[e>>2];if(c){break d}b=0;break c}while(1){g=e;b=c;e=b+20|0;c=F[e>>2];if(c){continue}e=b+16|0;c=F[b+16>>2];if(c){continue}break}F[g>>2]=0;}if(!h){break b}e=F[d+28>>2];c=(e<<2)+12068|0;e:{if(F[c>>2]==(d|0)){F[c>>2]=b;if(b){break e}i=11768,j=F[2942]&oi(e),F[i>>2]=j;break b}F[h+(F[h+16>>2]==(d|0)?16:20)>>2]=b;if(!b){break b}}F[b+24>>2]=h;c=F[d+16>>2];if(c){F[b+16>>2]=c;F[c+24>>2]=b;}c=F[d+20>>2];if(!c){break b}F[b+20>>2]=c;F[c+24>>2]=b;break b}b=F[f+4>>2];if((b&3)!=3){break b}F[2943]=a;F[f+4>>2]=b&-2;F[d+4>>2]=a|1;F[a+d>>2]=a;return}if(d>>>0>=f>>>0){break a}b=F[f+4>>2];if(!(b&1)){break a}f:{if(!(b&2)){if(F[2947]==(f|0)){F[2947]=d;a=F[2944]+a|0;F[2944]=a;F[d+4>>2]=a|1;if(F[2946]!=(d|0)){break a}F[2943]=0;F[2946]=0;return}if(F[2946]==(f|0)){F[2946]=d;a=F[2943]+a|0;F[2943]=a;F[d+4>>2]=a|1;F[a+d>>2]=a;return}a=(b&-8)+a|0;g:{if(b>>>0<=255){e=F[f+8>>2];b=b>>>3|0;c=F[f+12>>2];if((c|0)==(e|0)){i=11764,j=F[2941]&oi(b),F[i>>2]=j;break g}F[e+12>>2]=c;F[c+8>>2]=e;break g}h=F[f+24>>2];b=F[f+12>>2];h:{if((f|0)!=(b|0)){c=F[f+8>>2];F[c+12>>2]=b;F[b+8>>2]=c;break h}i:{e=f+20|0;c=F[e>>2];if(c){break i}e=f+16|0;c=F[e>>2];if(c){break i}b=0;break h}while(1){g=e;b=c;e=b+20|0;c=F[e>>2];if(c){continue}e=b+16|0;c=F[b+16>>2];if(c){continue}break}F[g>>2]=0;}if(!h){break g}e=F[f+28>>2];c=(e<<2)+12068|0;j:{if(F[c>>2]==(f|0)){F[c>>2]=b;if(b){break j}i=11768,j=F[2942]&oi(e),F[i>>2]=j;break g}F[h+(F[h+16>>2]==(f|0)?16:20)>>2]=b;if(!b){break g}}F[b+24>>2]=h;c=F[f+16>>2];if(c){F[b+16>>2]=c;F[c+24>>2]=b;}c=F[f+20>>2];if(!c){break g}F[b+20>>2]=c;F[c+24>>2]=b;}F[d+4>>2]=a|1;F[a+d>>2]=a;if(F[2946]!=(d|0)){break f}F[2943]=a;return}F[f+4>>2]=b&-2;F[d+4>>2]=a|1;F[a+d>>2]=a;}if(a>>>0<=255){b=(a&-8)+11804|0;c=F[2941];a=1<<(a>>>3);k:{if(!(c&a)){F[2941]=a|c;a=b;break k}a=F[b+8>>2];}F[b+8>>2]=d;F[a+12>>2]=d;F[d+12>>2]=b;F[d+8>>2]=a;return}e=31;if(a>>>0<=16777215){b=O(a>>>8|0);e=((a>>>38-b&1)-(b<<1)|0)+62|0;}F[d+28>>2]=e;F[d+16>>2]=0;F[d+20>>2]=0;g=(e<<2)+12068|0;l:{m:{c=F[2942];b=1<<e;n:{if(!(c&b)){F[2942]=b|c;F[g>>2]=d;F[d+24>>2]=g;break n}e=a<<((e|0)!=31?25-(e>>>1|0)|0:0);b=F[g>>2];while(1){c=b;if((F[b+4>>2]&-8)==(a|0)){break m}b=e>>>29|0;e=e<<1;g=c+(b&4)|0;b=F[g+16>>2];if(b){continue}break}F[g+16>>2]=d;F[d+24>>2]=c;}F[d+12>>2]=d;F[d+8>>2]=d;break l}a=F[c+8>>2];F[a+12>>2]=d;F[c+8>>2]=d;F[d+24>>2]=0;F[d+12>>2]=c;F[d+8>>2]=a;}a=F[2949]-1|0;F[2949]=a?a:-1;}}function di(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;F[a+8>>2]=e;n=a+32|0;h=F[n>>2];f=F[a+36>>2]-h>>2;a:{if(f>>>0<e>>>0){qa(n,e-f|0);d=F[a+8>>2];break a}d=e;if(d>>>0>=f>>>0){break a}F[a+36>>2]=h+(e<<2);d=e;}s=F[a+52>>2];p=F[a+48>>2];f=0;h=e>>>0>1073741823?-1:e<<2;m=ma(ka(h),0,h);b:{if((d|0)<=0){break b}g=F[a+32>>2];while(1){d=f<<2;h=F[d+m>>2];j=F[a+16>>2];c:{if((h|0)>(j|0)){F[d+g>>2]=j;break c}d=d+g|0;j=F[a+12>>2];if((j|0)>(h|0)){F[d>>2]=j;break c}F[d>>2]=h;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}if((d|0)<=0){break b}f=0;while(1){h=f<<2;d=h+c|0;h=F[b+h>>2]+F[g+h>>2]|0;F[d>>2]=h;d:{if((h|0)>F[a+16>>2]){i=h-F[a+20>>2]|0;}else {if((h|0)>=F[a+12>>2]){break d}i=h+F[a+20>>2]|0;}F[d>>2]=i;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}f=F[a+56>>2];q=F[f>>2];f=F[f+4>>2]-q|0;if((f|0)>=5){o=f>>>2|0;t=o>>>0<=2?2:o;u=e&-2;w=e&1;h=1;while(1){e:{f:{if((h|0)!=(o|0)){r=L(e,h);f=F[(h<<2)+q>>2];if((f|0)==-1){break f}f=F[F[p+12>>2]+(f<<2)>>2];if((f|0)==-1){break f}j=F[s>>2];g=F[p>>2];k=F[j+(F[g+(f<<2)>>2]<<2)>>2];i=f+1|0;i=(i>>>0)%3|0?i:f-2|0;if((i|0)!=-1){i=F[g+(i<<2)>>2];}else {i=-1;}g:{h:{if((f>>>0)%3|0){f=f-1|0;break h}f=f+2|0;l=-1;if((f|0)==-1){break g}}l=F[g+(f<<2)>>2];}if((h|0)<=(k|0)){break f}f=F[(i<<2)+j>>2];if((f|0)>=(h|0)){break f}g=F[j+(l<<2)>>2];if((g|0)>=(h|0)){break f}i:{if((e|0)<=0){break i}g=L(e,g);j=L(e,f);k=L(e,k);f=0;l=0;if((e|0)!=1){while(1){F[(f<<2)+m>>2]=(F[(f+g<<2)+c>>2]+F[(f+j<<2)+c>>2]|0)-F[(f+k<<2)+c>>2];i=f|1;F[(i<<2)+m>>2]=(F[(g+i<<2)+c>>2]+F[(j+i<<2)+c>>2]|0)-F[(i+k<<2)+c>>2];f=f+2|0;l=l+2|0;if((u|0)!=(l|0)){continue}break}}if(!w){break i}F[(f<<2)+m>>2]=(F[(f+g<<2)+c>>2]+F[(f+j<<2)+c>>2]|0)-F[(f+k<<2)+c>>2];}if((d|0)<=0){break e}j=F[n>>2];f=0;while(1){d=f<<2;g=F[d+m>>2];k=F[a+16>>2];j:{if((g|0)>(k|0)){F[d+j>>2]=k;break j}d=d+j|0;k=F[a+12>>2];if((k|0)>(g|0)){F[d>>2]=k;break j}F[d>>2]=g;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}f=0;if((d|0)<=0){break e}d=r<<2;k=d+c|0;i=b+d|0;while(1){g=f<<2;d=g+k|0;g=F[g+i>>2]+F[g+j>>2]|0;F[d>>2]=g;k:{if((g|0)>F[a+16>>2]){l=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break k}l=g+F[a+20>>2]|0;}F[d>>2]=l;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}break e}ta();v();}if((d|0)<=0){break e}k=(L(h-1|0,e)<<2)+c|0;j=F[n>>2];f=0;while(1){d=f<<2;g=F[d+k>>2];i=F[a+16>>2];l:{if((g|0)>(i|0)){F[d+j>>2]=i;break l}d=d+j|0;i=F[a+12>>2];if((i|0)>(g|0)){F[d>>2]=i;break l}F[d>>2]=g;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}f=0;if((d|0)<=0){break e}d=r<<2;k=d+c|0;i=b+d|0;while(1){g=f<<2;d=g+k|0;g=F[g+i>>2]+F[g+j>>2]|0;F[d>>2]=g;m:{if((g|0)>F[a+16>>2]){l=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break m}l=g+F[a+20>>2]|0;}F[d>>2]=l;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}h=h+1|0;if((t|0)!=(h|0)){continue}break}}ja(m);return 1}function od(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;if((b|0)==-1){return 1}g=(b>>>0)/3|0;if(!(F[F[a+24>>2]+(g>>>3&268435452)>>2]>>>g&1)){e=F[a+48>>2];F[a+52>>2]=e;a:{if((e|0)!=F[a+56>>2]){F[e>>2]=b;F[a+52>>2]=e+4;break a}d=ka(4);F[d>>2]=b;c=d+4|0;F[a+56>>2]=c;F[a+52>>2]=c;F[a+48>>2]=d;if(!e){break a}ja(e);}c=b+1|0;i=(c>>>0)%3|0?c:b-2|0;c=F[F[a+4>>2]+28>>2];k=F[(i<<2)+c>>2];if((k|0)==-1){return 0}e=(b-L(g,3)|0?-1:2)+b|0;j=F[c+(e<<2)>>2];if((j|0)==-1){return 0}b=F[a+36>>2];g=b+(k>>>3&536870908)|0;d=F[g>>2];c=1<<k;if(!(d&c)){F[g>>2]=c|d;Ka(a+8|0,k,i);b=F[a+36>>2];}d=(j>>>3&536870908)+b|0;c=F[d>>2];b=1<<j;if(!(c&b)){F[d>>2]=b|c;Ka(a+8|0,j,e);}f=F[a+52>>2];if((f|0)==F[a+48>>2]){return 1}k=a+8|0;while(1){b:{c:{f=f-4|0;b=F[f>>2];if((b|0)==-1){break c}c=(b>>>0)/3|0;g=F[a+24>>2]+(c>>>3&268435452)|0;d=F[g>>2];c=1<<c;if(d&c){break c}F[g>>2]=c|d;h=F[a+4>>2];c=F[F[h+28>>2]+(b<<2)>>2];if((c|0)==-1){return 0}while(1){d=b;d:{e:{j=F[a+36>>2]+(c>>>3&536870908)|0;i=F[j>>2];e=1<<c;if(i&e){break e}f:{g=F[F[h+40>>2]+(c<<2)>>2];g:{if((g|0)==-1){break g}b=g+1|0;b=(b>>>0)%3|0?b:g-2|0;if((b|0)==-1|F[F[h>>2]+(b>>>3&536870908)>>2]>>>b&1){break g}g=F[F[F[h+64>>2]+12>>2]+(b<<2)>>2];if((g|0)!=-1){break f}}F[j>>2]=e|i;Ka(k,c,d);h=F[a+4>>2];break e}F[j>>2]=e|i;Ka(k,c,d);h=F[a+4>>2];b=g+1|0;if((((b>>>0)%3|0?b:g-2|0)|0)==-1){break e}b=-1;h:{if((d|0)==-1){break h}c=d+1|0;c=(c>>>0)%3|0?c:d-2|0;if((c|0)==-1|F[F[h>>2]+(c>>>3&536870908)>>2]>>>c&1){break h}b=F[F[F[h+64>>2]+12>>2]+(c<<2)>>2];}c=(b>>>0)/3|0;d=1<<c;f=F[a+24>>2];e=c>>>5|0;j=F[f+(e<<2)>>2];break d}i:{j:{if((d|0)==-1){break j}c=-1;b=d+1|0;b=(b>>>0)%3|0?b:d-2|0;if(!((b|0)==-1|F[F[h>>2]+(b>>>3&536870908)>>2]>>>b&1)){c=F[F[F[h+64>>2]+12>>2]+(b<<2)>>2];}k:{l:{if((d>>>0)%3|0){f=d-1|0;break l}f=d+2|0;b=-1;if((f|0)==-1){break k}}b=-1;if(F[F[h>>2]+(f>>>3&536870908)>>2]>>>f&1){break k}b=F[F[F[h+64>>2]+12>>2]+(f<<2)>>2];}g=(b|0)==-1;i=g?-1:(b>>>0)/3|0;if((c|0)!=-1){f=F[a+24>>2];d=(c>>>0)/3|0;e=d>>>5|0;j=F[f+(e<<2)>>2];d=1<<d;if(!(j&d)){break i}}if(g){break j}d=1<<i;f=F[a+24>>2];e=i>>>5|0;j=F[f+(e<<2)>>2];if(!(d&j)){break d}}f=F[a+52>>2]-4|0;F[a+52>>2]=f;break b}if(g){b=c;break d}if(F[(i>>>3&536870908)+f>>2]>>>i&1){b=c;break d}h=F[a+52>>2];F[h-4>>2]=b;if(F[a+56>>2]!=(h|0)){F[h>>2]=c;f=h+4|0;break c}m:{i=F[a+48>>2];e=h-i|0;g=e>>2;d=g+1|0;if(d>>>0<1073741824){b=e>>>1|0;e=e>>>0>=2147483644?1073741823:b>>>0>d>>>0?b:d;if(e){if(e>>>0>=1073741824){break m}d=ka(e<<2);}else {d=0;}b=d+(g<<2)|0;F[b>>2]=c;f=b+4|0;if((h|0)!=(i|0)){while(1){b=b-4|0;h=h-4|0;F[b>>2]=F[h>>2];if((h|0)!=(i|0)){continue}break}}F[a+56>>2]=d+(e<<2);F[a+52>>2]=f;F[a+48>>2]=b;if(!i){break b}ja(i);f=F[a+52>>2];break b}na();v();}oa();v();}F[(e<<2)+f>>2]=d|j;c=F[F[h+28>>2]+(b<<2)>>2];if((c|0)!=-1){continue}break}return 0}F[a+52>>2]=f;}if(F[a+48>>2]!=(f|0)){continue}break}}return 1}function he(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,w=0;F[a+8>>2]=e;m=a+32|0;h=F[m>>2];f=F[a+36>>2]-h>>2;a:{if(f>>>0<e>>>0){qa(m,e-f|0);d=F[a+8>>2];break a}d=e;if(d>>>0>=f>>>0){break a}F[a+36>>2]=h+(e<<2);d=e;}s=F[a+52>>2];n=F[a+48>>2];f=0;h=e>>>0>1073741823?-1:e<<2;l=ma(ka(h),0,h);b:{if((d|0)<=0){break b}g=F[a+32>>2];while(1){d=f<<2;h=F[d+l>>2];i=F[a+16>>2];c:{if((h|0)>(i|0)){F[d+g>>2]=i;break c}d=d+g|0;i=F[a+12>>2];if((i|0)>(h|0)){F[d>>2]=i;break c}F[d>>2]=h;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}if((d|0)<=0){break b}f=0;while(1){h=f<<2;d=h+c|0;h=F[b+h>>2]+F[g+h>>2]|0;F[d>>2]=h;d:{if((h|0)>F[a+16>>2]){h=h-F[a+20>>2]|0;}else {if((h|0)>=F[a+12>>2]){break d}h=h+F[a+20>>2]|0;}F[d>>2]=h;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}f=F[a+56>>2];q=F[f>>2];f=F[f+4>>2]-q|0;if((f|0)>=5){o=f>>>2|0;t=o>>>0<=2?2:o;u=e&-2;w=e&1;h=1;while(1){e:{f:{if((h|0)!=(o|0)){r=L(e,h);f=F[(h<<2)+q>>2];if((f|0)==-1|F[F[n>>2]+(f>>>3&536870908)>>2]>>>f&1){break f}f=F[F[F[n+64>>2]+12>>2]+(f<<2)>>2];if((f|0)==-1){break f}i=F[s>>2];g=F[n+28>>2];k=F[i+(F[g+(f<<2)>>2]<<2)>>2];if((k|0)>=(h|0)){break f}j=f+1|0;j=F[i+(F[g+(((j>>>0)%3|0?j:f-2|0)<<2)>>2]<<2)>>2];if((j|0)>=(h|0)){break f}f=F[i+(F[g+(f+((f>>>0)%3|0?-1:2)<<2)>>2]<<2)>>2];if((f|0)>=(h|0)){break f}g:{if((e|0)<=0){break g}g=L(e,f);i=L(e,j);k=L(e,k);f=0;p=0;if((e|0)!=1){while(1){F[(f<<2)+l>>2]=(F[(f+g<<2)+c>>2]+F[(f+i<<2)+c>>2]|0)-F[(f+k<<2)+c>>2];j=f|1;F[(j<<2)+l>>2]=(F[(g+j<<2)+c>>2]+F[(i+j<<2)+c>>2]|0)-F[(k+j<<2)+c>>2];f=f+2|0;p=p+2|0;if((u|0)!=(p|0)){continue}break}}if(!w){break g}F[(f<<2)+l>>2]=(F[(f+g<<2)+c>>2]+F[(f+i<<2)+c>>2]|0)-F[(f+k<<2)+c>>2];}if((d|0)<=0){break e}i=F[m>>2];f=0;while(1){d=f<<2;g=F[d+l>>2];k=F[a+16>>2];h:{if((g|0)>(k|0)){F[d+i>>2]=k;break h}d=d+i|0;k=F[a+12>>2];if((k|0)>(g|0)){F[d>>2]=k;break h}F[d>>2]=g;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}f=0;if((d|0)<=0){break e}d=r<<2;k=d+c|0;j=b+d|0;while(1){g=f<<2;d=g+k|0;g=F[g+j>>2]+F[g+i>>2]|0;F[d>>2]=g;i:{if((g|0)>F[a+16>>2]){g=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break i}g=g+F[a+20>>2]|0;}F[d>>2]=g;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}break e}ta();v();}if((d|0)<=0){break e}k=(L(h-1|0,e)<<2)+c|0;i=F[m>>2];f=0;while(1){d=f<<2;g=F[d+k>>2];j=F[a+16>>2];j:{if((g|0)>(j|0)){F[d+i>>2]=j;break j}d=d+i|0;j=F[a+12>>2];if((j|0)>(g|0)){F[d>>2]=j;break j}F[d>>2]=g;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}f=0;if((d|0)<=0){break e}d=r<<2;k=d+c|0;j=b+d|0;while(1){g=f<<2;d=g+k|0;g=F[g+j>>2]+F[g+i>>2]|0;F[d>>2]=g;k:{if((g|0)>F[a+16>>2]){g=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break k}g=g+F[a+20>>2]|0;}F[d>>2]=g;}d=F[a+8>>2];f=f+1|0;if((d|0)>(f|0)){continue}break}}h=h+1|0;if((t|0)!=(h|0)){continue}break}}ja(l);return 1}function Fb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=M(0),k=0,l=0,m=M(0);i=F[c>>2];a:{b:{f=F[b+4>>2];if(!f){break b}g=ni(f);c:{if(g>>>0>=2){e=i;if(f>>>0<=e>>>0){e=(i>>>0)%(f>>>0)|0;}c=F[F[b>>2]+(e<<2)>>2];if(!c){break b}if(g>>>0<=1){break c}while(1){c=F[c>>2];if(!c){break b}g=F[c+4>>2];if((g|0)!=(i|0)){if(f>>>0<=g>>>0){g=(g>>>0)%(f>>>0)|0;}if((e|0)!=(g|0)){break b}}if(F[c+8>>2]!=(i|0)){continue}break}b=0;break a}e=f-1&i;c=F[F[b>>2]+(e<<2)>>2];if(!c){break b}}h=f-1|0;while(1){c=F[c>>2];if(!c){break b}g=F[c+4>>2];if((g|0)!=(i|0)&(g&h)!=(e|0)){break b}if(F[c+8>>2]!=(i|0)){continue}break}b=0;break a}c=ka(16);d=F[F[d>>2]>>2];F[c+12>>2]=0;F[c+8>>2]=d;F[c+4>>2]=i;F[c>>2]=0;m=M(F[b+12>>2]+1>>>0);j=J[b+16>>2];d:{if(m>M(j*M(f>>>0))?0:f){break d}e=2;d=(f-1&f)!=0|f>>>0<3|f<<1;j=M(S(M(m/j)));e:{if(j<M(4294967296)&j>=M(0)){g=~~j>>>0;break e}g=0;}d=d>>>0>g>>>0?d:g;f:{if((d|0)==1){break f}if(!(d&d-1)){e=d;break f}e=Mc(d);f=F[b+4>>2];}g:{if(e>>>0<=f>>>0){if(e>>>0>=f>>>0){break g}g=f>>>0<3;j=M(S(M(M(I[b+12>>2])/J[b+16>>2])));h:{if(j<M(4294967296)&j>=M(0)){d=~~j>>>0;break h}d=0;}i:{j:{if(g){break j}if(ni(f)>>>0>1){break j}d=d>>>0<2?d:1<<32-O(d-1|0);break i}d=Mc(d);}e=d>>>0<e>>>0?e:d;if(f>>>0<=e>>>0){break g}}f=0;g=0;h=e;k:{l:{m:{n:{if(e){if(h>>>0>=1073741824){break n}d=ka(h<<2);e=F[b>>2];F[b>>2]=d;if(e){ja(e);}F[b+4>>2]=h;d=0;if(h>>>0>=4){e=h&-4;while(1){k=d<<2;F[k+F[b>>2]>>2]=0;F[F[b>>2]+(k|4)>>2]=0;F[F[b>>2]+(k|8)>>2]=0;F[F[b>>2]+(k|12)>>2]=0;d=d+4|0;g=g+4|0;if((e|0)!=(g|0)){continue}break}}e=h&3;if(e){while(1){F[F[b>>2]+(d<<2)>>2]=0;d=d+1|0;f=f+1|0;if((e|0)!=(f|0)){continue}break}}e=F[b+8>>2];if(!e){break k}d=b+8|0;f=F[e+4>>2];g=ni(h);if(g>>>0<2){break m}f=f>>>0>=h>>>0?(f>>>0)%(h>>>0)|0:f;F[F[b>>2]+(f<<2)>>2]=d;d=F[e>>2];if(!d){break k}if(g>>>0<=1){break l}while(1){g=F[d+4>>2];if(h>>>0<=g>>>0){g=(g>>>0)%(h>>>0)|0;}o:{if((f|0)==(g|0)){e=d;break o}l=g<<2;k=l+F[b>>2]|0;if(!F[k>>2]){F[k>>2]=e;e=d;f=g;break o}F[e>>2]=F[d>>2];F[d>>2]=F[F[l+F[b>>2]>>2]>>2];F[F[l+F[b>>2]>>2]>>2]=d;}d=F[e>>2];if(d){continue}break}break k}d=F[b>>2];F[b>>2]=0;if(d){ja(d);}F[b+4>>2]=0;break k}oa();v();}f=h-1&f;F[F[b>>2]+(f<<2)>>2]=d;d=F[e>>2];if(!d){break k}}k=h-1|0;while(1){g=k&F[d+4>>2];p:{if((g|0)==(f|0)){e=d;break p}l=g<<2;h=l+F[b>>2]|0;if(F[h>>2]){F[e>>2]=F[d>>2];F[d>>2]=F[F[l+F[b>>2]>>2]>>2];F[F[l+F[b>>2]>>2]>>2]=d;break p}F[h>>2]=e;e=d;f=g;}d=F[e>>2];if(d){continue}break}}}f=F[b+4>>2];d=f-1|0;if(!(d&f)){e=d&i;break d}if(f>>>0>i>>>0){e=i;break d}e=(i>>>0)%(f>>>0)|0;}e=F[b>>2]+(e<<2)|0;d=F[e>>2];q:{r:{if(!d){d=b+8|0;F[c>>2]=F[d>>2];F[b+8>>2]=c;F[e>>2]=d;d=F[c>>2];if(!d){break q}d=F[d+4>>2];e=f-1|0;s:{if(!(e&f)){d=d&e;break s}if(d>>>0<f>>>0){break s}d=(d>>>0)%(f>>>0)|0;}d=F[b>>2]+(d<<2)|0;break r}F[c>>2]=F[d>>2];}F[d>>2]=c;}F[b+12>>2]=F[b+12>>2]+1;b=1;}D[a+4|0]=b;F[a>>2]=c;}function Vb(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;j=L(b,12)+a|0;F[j+12>>2]=F[j+8>>2];m=(c|0)==-1?-1:(c>>>0)/3|0;d=1;k=c;a:{b:{c:{while(1){d:{l=d;if(!d){if((k|0)==-1){break d}if((Wc(a,((k>>>0)%3|0?-1:2)+k|0)|0)==-1){break a}c=k+1|0;d=(c>>>0)%3|0?c:k-2|0;if((d|0)==-1){break a}c=d+1|0;c=(c>>>0)%3|0?c:d-2|0;if((c|0)==-1){break a}d=F[F[F[a+4>>2]+12>>2]+(c<<2)>>2];if((d|0)==-1){break a}c=d+1|0;c=(c>>>0)%3|0?c:d-2|0;if((c|0)==-1){break a}m=(c>>>0)/3|0;}e:{d=F[a+56>>2]+(m>>>3&536870908)|0;h=F[d>>2];e=1<<m;if(h&e){break e}f=0;while(1){F[d>>2]=e|h;d=F[j+12>>2];f:{if((d|0)!=F[j+16>>2]){F[d>>2]=m;F[j+12>>2]=d+4;break f}n=F[j+8>>2];h=d-n|0;e=h>>2;i=e+1|0;if(i>>>0>=1073741824){break c}g=h>>>1|0;i=h>>>0>=2147483644?1073741823:i>>>0<g>>>0?g:i;if(i){if(i>>>0>=1073741824){break b}g=ka(i<<2);}else {g=0;}h=g+(e<<2)|0;F[h>>2]=m;e=h+4|0;if((d|0)!=(n|0)){while(1){h=h-4|0;d=d-4|0;F[h>>2]=F[d>>2];if((d|0)!=(n|0)){continue}break}}F[j+8>>2]=h;F[j+12>>2]=e;F[j+16>>2]=g+(i<<2);if(!n){break f}ja(n);}g=f+1|0;g:{h:{i:{if(!f){break i}if(g&1){if((c|0)==-1){c=-1;break g}d=c+1|0;c=(d>>>0)%3|0?d:c-2|0;break i}k=l?k:c;if((c|0)==-1){c=-1;break g}if((c>>>0)%3|0){d=c-1|0;break h}c=c+2|0;}d=c;c=-1;if((d|0)==-1){break g}}c=F[F[F[a+4>>2]+12>>2]+(d<<2)>>2];h=-1;f=-1;e=d+1|0;e=(e>>>0)%3|0?e:d-2|0;if((e|0)>=0){f=(e>>>0)/3|0;f=F[(F[F[a>>2]+96>>2]+L(f,12)|0)+(e-L(f,3)<<2)>>2];}j:{if((c|0)==-1){break j}i=((c>>>0)%3|0?-1:2)+c|0;if((i|0)<0){break j}e=(i>>>0)/3|0;h=F[(F[F[a>>2]+96>>2]+L(e,12)|0)+(i-L(e,3)<<2)>>2];}if((f|0)!=(h|0)){c=-1;break g}k:{l:{f=((d>>>0)%3|0?-1:2)+d|0;if((f|0)>=0){d=(f>>>0)/3|0;if((c|0)!=-1){break l}c=-1;break g}d=-1;if((c|0)!=-1){break k}c=-1;break g}d=F[(F[F[a>>2]+96>>2]+L(d,12)|0)+(f-L(d,3)<<2)>>2];}f=c+1|0;e=(f>>>0)%3|0?f:c-2|0;if((e|0)>=0){f=(e>>>0)/3|0;f=F[(F[F[a>>2]+96>>2]+L(f,12)|0)+(e-L(f,3)<<2)>>2];}else {f=-1;}if((f|0)!=(d|0)){c=-1;break g}f=g;m=(c>>>0)/3|0;d=F[a+56>>2]+(m>>>3&268435452)|0;h=F[d>>2];e=1<<m;if(!(h&e)){continue}}break}if(l|!(g&1)){break e}l=F[j+12>>2]-4|0;g=F[l>>2];d=F[a+56>>2]+(g>>>3&536870908)|0;c=F[d>>2];o=d,p=oi(g)&c,F[o>>2]=p;F[j+12>>2]=l;break a}d=0;if(l){continue}break a}break}k=-1;Wc(a,-1);break a}na();v();}oa();v();}F[((b<<2)+a|0)+44>>2]=k;b=F[j+12>>2];i=F[j+8>>2];m:{if((b|0)==(i|0)){break m}c=b-i|0;b=c>>2;b=b>>>0<=1?1:b;k=b&1;e=F[a+56>>2];d=0;if(c>>>0>=8){f=b&-2;c=0;while(1){l=d<<2;g=F[l+i>>2];b=e+(g>>>3&536870908)|0;a=F[b>>2];o=b,p=oi(g)&a,F[o>>2]=p;g=F[i+(l|4)>>2];b=e+(g>>>3&536870908)|0;a=F[b>>2];o=b,p=oi(g)&a,F[o>>2]=p;d=d+2|0;c=c+2|0;if((f|0)!=(c|0)){continue}break}}if(!k){break m}c=F[i+(d<<2)>>2];b=e+(c>>>3&536870908)|0;a=F[b>>2];o=b,p=oi(c)&a,F[o>>2]=p;}}function pd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;if((b|0)==-1){return 1}g=(b>>>0)/3|0;if(!(F[F[a+24>>2]+(g>>>3&268435452)>>2]>>>g&1)){f=F[a+48>>2];F[a+52>>2]=f;a:{if((f|0)!=F[a+56>>2]){F[f>>2]=b;F[a+52>>2]=f+4;break a}d=ka(4);F[d>>2]=b;c=d+4|0;F[a+56>>2]=c;F[a+52>>2]=c;F[a+48>>2]=d;if(!f){break a}ja(f);}e=-1;d=F[a+4>>2];c=b+1|0;i=(c>>>0)%3|0?c:b-2|0;if((i|0)!=-1){e=F[F[d>>2]+(i<<2)>>2];}b:{h=b-L(g,3)|0;if(h){c=b-1|0;break b}c=b+2|0;if((c|0)!=-1){break b}return 0}if((e|0)==-1){return 0}j=F[F[d>>2]+(c<<2)>>2];if((j|0)==-1){return 0}c=F[a+36>>2];f=c+(e>>>3&536870908)|0;g=F[f>>2];d=1<<e;if(!(g&d)){F[f>>2]=d|g;Ka(a+8|0,e,i);c=F[a+36>>2];}g=(j>>>3&536870908)+c|0;d=F[g>>2];c=1<<j;if(!(d&c)){F[g>>2]=c|d;Ka(a+8|0,j,(h?-1:2)+b|0);}c=F[a+52>>2];if((c|0)==F[a+48>>2]){return 1}j=a+8|0;while(1){c:{d:{c=c-4|0;b=F[c>>2];if((b|0)==-1){break d}d=(b>>>0)/3|0;f=F[a+24>>2]+(d>>>3&268435452)|0;g=F[f>>2];d=1<<d;if(g&d){break d}F[f>>2]=d|g;while(1){i=F[a+4>>2];e=F[F[i>>2]+(b<<2)>>2];if((e|0)==-1){return 0}e:{f:{h=F[a+36>>2]+(e>>>3&536870908)|0;f=F[h>>2];g=1<<e;if(f&g){break f}g:{d=F[F[i+24>>2]+(e<<2)>>2];h:{if((d|0)==-1){break h}c=d+1|0;c=(c>>>0)%3|0?c:d-2|0;if((c|0)==-1){break h}d=F[F[i+12>>2]+(c<<2)>>2];if((d|0)!=-1){break g}}F[h>>2]=f|g;Ka(j,e,b);break f}F[h>>2]=f|g;Ka(j,e,b);c=d+1|0;if((((c>>>0)%3|0?c:d-2|0)|0)==-1){break f}c=b-2|0;d=b+1|0;b=-1;c=(d>>>0)%3|0?d:c;if((c|0)!=-1){b=F[F[F[a+4>>2]+12>>2]+(c<<2)>>2];}c=(b>>>0)/3|0;d=1<<c;e=F[a+24>>2];f=c>>>5|0;i=F[e+(f<<2)>>2];break e}c=-1;g=F[a+4>>2];d=b+1|0;d=(d>>>0)%3|0?d:b-2|0;if((d|0)!=-1){c=F[F[g+12>>2]+(d<<2)>>2];}i:{j:{if((b>>>0)%3|0){e=b-1|0;break j}e=b+2|0;b=-1;if((e|0)==-1){break i}}b=F[F[g+12>>2]+(e<<2)>>2];}g=(b|0)==-1;h=g?-1:(b>>>0)/3|0;k:{if((c|0)!=-1){e=F[a+24>>2];d=(c>>>0)/3|0;f=d>>>5|0;i=F[e+(f<<2)>>2];d=1<<d;if(!(i&d)){break k}}if(!g){d=1<<h;e=F[a+24>>2];f=h>>>5|0;i=F[e+(f<<2)>>2];if(!(d&i)){break e}}c=F[a+52>>2]-4|0;F[a+52>>2]=c;break c}if(g){b=c;break e}if(F[(h>>>3&536870908)+e>>2]>>>h&1){b=c;break e}e=F[a+52>>2];F[e-4>>2]=b;if(F[a+56>>2]!=(e|0)){F[e>>2]=c;c=e+4|0;break d}l:{h=F[a+48>>2];f=e-h|0;g=f>>2;d=g+1|0;if(d>>>0<1073741824){b=f>>>1|0;f=f>>>0>=2147483644?1073741823:b>>>0>d>>>0?b:d;if(f){if(f>>>0>=1073741824){break l}d=ka(f<<2);}else {d=0;}b=d+(g<<2)|0;F[b>>2]=c;c=b+4|0;if((e|0)!=(h|0)){while(1){b=b-4|0;e=e-4|0;F[b>>2]=F[e>>2];if((e|0)!=(h|0)){continue}break}}F[a+56>>2]=d+(f<<2);F[a+52>>2]=c;F[a+48>>2]=b;if(!h){break c}ja(h);c=F[a+52>>2];break c}na();v();}oa();v();}F[(f<<2)+e>>2]=d|i;if((b|0)!=-1){continue}break}return 0}F[a+52>>2]=c;}if(F[a+48>>2]!=(c|0)){continue}break}}return 1}function ee(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=Z-32|0;Z=h;a:{b:{if(!Oa(1,h+28|0,b)){break b}d=F[h+28>>2];c=F[F[a+48>>2]+64>>2];if(d>>>0>F[c+4>>2]-F[c>>2]>>2>>>0){break b}c:{if(d){Na(a+60|0,d);c=h+8|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;if(!Aa(c,b)){break c}while(1){f=1<<e;j=wa(c);g=F[a+60>>2]+(e>>>3&536870908)|0;if(j){i=f|F[g>>2];}else {i=F[g>>2]&(f^-1);}F[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Oa(1,h+28|0,b)){break b}d=F[h+28>>2];c=F[F[a+48>>2]+64>>2];if(d>>>0>F[c+4>>2]-F[c>>2]>>2>>>0){break b}if(d){e=0;Na(a+72|0,d);c=h+8|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;if(!Aa(c,b)){break c}while(1){f=1<<e;j=wa(c);g=F[a+72>>2]+(e>>>3&536870908)|0;if(j){i=f|F[g>>2];}else {i=F[g>>2]&(f^-1);}F[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Oa(1,h+28|0,b)){break b}d=F[h+28>>2];c=F[F[a+48>>2]+64>>2];if(d>>>0>F[c+4>>2]-F[c>>2]>>2>>>0){break b}if(d){e=0;Na(a+84|0,d);c=h+8|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;if(!Aa(c,b)){break c}while(1){f=1<<e;j=wa(c);g=F[a+84>>2]+(e>>>3&536870908)|0;if(j){i=f|F[g>>2];}else {i=F[g>>2]&(f^-1);}F[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Oa(1,h+28|0,b)){break b}d=F[h+28>>2];c=F[F[a+48>>2]+64>>2];if(d>>>0>F[c+4>>2]-F[c>>2]>>2>>>0){break b}if(d){e=0;Na(a+96|0,d);c=h+8|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;if(!Aa(c,b)){break c}while(1){f=1<<e;j=wa(c);g=F[a+96>>2]+(e>>>3&536870908)|0;if(j){i=f|F[g>>2];}else {i=F[g>>2]&(f^-1);}F[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}e=0;c=F[b+8>>2];f=F[b+12>>2];d=c;c=F[b+20>>2];i=c;g=F[b+16>>2];j=g+4|0;c=j>>>0<4?c+1|0:c;if(d>>>0<j>>>0&(c|0)>=(f|0)|(c|0)>(f|0)){break a}m=F[b>>2];k=m+g|0;l=G[k|0]|G[k+1|0]<<8|(G[k+2|0]<<16|G[k+3|0]<<24);F[b+16>>2]=j;F[b+20>>2]=c;k=d;d=f;c=i;f=g+8|0;c=f>>>0<8?c+1|0:c;if(f>>>0>k>>>0&(c|0)>=(d|0)|(c|0)>(d|0)){break a}d=j+m|0;d=G[d|0]|G[d+1|0]<<8|(G[d+2|0]<<16|G[d+3|0]<<24);F[b+16>>2]=f;F[b+20>>2]=c;if((d|0)<(l|0)){break a}F[a+16>>2]=d;F[a+12>>2]=l;c=(d>>31)-((l>>31)+(d>>>0<l>>>0)|0)|0;b=d-l|0;if(!c&b>>>0>2147483646|c){break a}e=1;b=b+1|0;F[a+20>>2]=b;c=b>>>1|0;F[a+24>>2]=c;F[a+28>>2]=0-c;if(b&1){break a}F[a+24>>2]=c-1;break a}}e=0;}Z=h+32|0;return e|0}function ai(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=Z-32|0;Z=h;a:{b:{if(!Oa(1,h+28|0,b)){break b}d=F[h+28>>2];c=F[a+48>>2];if(d>>>0>F[c+4>>2]-F[c>>2]>>2>>>0){break b}c:{if(d){Na(a+60|0,d);c=h+8|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;if(!Aa(c,b)){break c}while(1){f=1<<e;j=wa(c);g=F[a+60>>2]+(e>>>3&536870908)|0;if(j){i=f|F[g>>2];}else {i=F[g>>2]&(f^-1);}F[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Oa(1,h+28|0,b)){break b}d=F[h+28>>2];c=F[a+48>>2];if(d>>>0>F[c+4>>2]-F[c>>2]>>2>>>0){break b}if(d){e=0;Na(a+72|0,d);c=h+8|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;if(!Aa(c,b)){break c}while(1){f=1<<e;j=wa(c);g=F[a+72>>2]+(e>>>3&536870908)|0;if(j){i=f|F[g>>2];}else {i=F[g>>2]&(f^-1);}F[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Oa(1,h+28|0,b)){break b}d=F[h+28>>2];c=F[a+48>>2];if(d>>>0>F[c+4>>2]-F[c>>2]>>2>>>0){break b}if(d){e=0;Na(a+84|0,d);c=h+8|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;if(!Aa(c,b)){break c}while(1){f=1<<e;j=wa(c);g=F[a+84>>2]+(e>>>3&536870908)|0;if(j){i=f|F[g>>2];}else {i=F[g>>2]&(f^-1);}F[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}if(!Oa(1,h+28|0,b)){break b}d=F[h+28>>2];c=F[a+48>>2];if(d>>>0>F[c+4>>2]-F[c>>2]>>2>>>0){break b}if(d){e=0;Na(a+96|0,d);c=h+8|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;if(!Aa(c,b)){break c}while(1){f=1<<e;j=wa(c);g=F[a+96>>2]+(e>>>3&536870908)|0;if(j){i=f|F[g>>2];}else {i=F[g>>2]&(f^-1);}F[g>>2]=i;e=e+1|0;if((d|0)!=(e|0)){continue}break}}e=0;c=F[b+8>>2];f=F[b+12>>2];d=c;c=F[b+20>>2];i=c;g=F[b+16>>2];j=g+4|0;c=j>>>0<4?c+1|0:c;if(d>>>0<j>>>0&(c|0)>=(f|0)|(c|0)>(f|0)){break a}m=F[b>>2];k=m+g|0;l=G[k|0]|G[k+1|0]<<8|(G[k+2|0]<<16|G[k+3|0]<<24);F[b+16>>2]=j;F[b+20>>2]=c;k=d;d=f;c=i;f=g+8|0;c=f>>>0<8?c+1|0:c;if(f>>>0>k>>>0&(c|0)>=(d|0)|(c|0)>(d|0)){break a}d=j+m|0;d=G[d|0]|G[d+1|0]<<8|(G[d+2|0]<<16|G[d+3|0]<<24);F[b+16>>2]=f;F[b+20>>2]=c;if((d|0)<(l|0)){break a}F[a+16>>2]=d;F[a+12>>2]=l;c=(d>>31)-((l>>31)+(d>>>0<l>>>0)|0)|0;b=d-l|0;if(!c&b>>>0>2147483646|c){break a}e=1;b=b+1|0;F[a+20>>2]=b;c=b>>>1|0;F[a+24>>2]=c;F[a+28>>2]=0-c;if(b&1){break a}F[a+24>>2]=c-1;break a}}e=0;}Z=h+32|0;return e|0}function uh(a){a=a|0;var b=0,c=0,d=0,e=0;c=F[a+32>>2];d=F[c+16>>2];e=F[c+12>>2];b=F[c+20>>2];if(I[c+8>>2]>d>>>0&(e|0)>=(b|0)|(b|0)<(e|0)){e=G[F[c>>2]+d|0];d=d+1|0;b=d?b:b+1|0;F[c+16>>2]=d;F[c+20>>2]=b;b=F[a+48>>2];F[a+48>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}a:{b:{c:{d:{switch(e|0){case 0:b=ka(384);F[b>>2]=8284;ma(b+4|0,0,80);F[b+96>>2]=0;F[b+100>>2]=0;F[b+92>>2]=-1;F[b+84>>2]=-1;F[b+88>>2]=-1;F[b+104>>2]=0;F[b+108>>2]=0;F[b+112>>2]=0;F[b+116>>2]=0;F[b+120>>2]=0;F[b+124>>2]=0;F[b+128>>2]=0;F[b+132>>2]=0;F[b+136>>2]=0;F[b+140>>2]=0;F[b+144>>2]=0;F[b+148>>2]=0;F[b+156>>2]=0;F[b+160>>2]=0;F[b+152>>2]=1065353216;F[b+164>>2]=0;F[b+168>>2]=0;F[b+172>>2]=0;F[b+176>>2]=0;F[b+180>>2]=0;F[b+184>>2]=0;F[b+188>>2]=0;F[b+192>>2]=0;F[b+196>>2]=0;F[b+200>>2]=0;F[b+204>>2]=0;F[b+208>>2]=0;F[b+212>>2]=-1;F[b+216>>2]=0;F[b+220>>2]=0;F[b+224>>2]=0;Ja(b+232|0);Ja(b+272|0);c=b+312|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;Ja(b+328|0);F[b+376>>2]=0;F[b+368>>2]=0;F[b+372>>2]=0;break c;case 2:break d;default:break b}}b=ka(440);F[b>>2]=8336;ma(b+4|0,0,80);F[b+96>>2]=0;F[b+100>>2]=0;F[b+92>>2]=-1;F[b+84>>2]=-1;F[b+88>>2]=-1;F[b+104>>2]=0;F[b+108>>2]=0;F[b+112>>2]=0;F[b+116>>2]=0;F[b+120>>2]=0;F[b+124>>2]=0;F[b+128>>2]=0;F[b+132>>2]=0;F[b+136>>2]=0;F[b+140>>2]=0;F[b+144>>2]=0;F[b+148>>2]=0;F[b+156>>2]=0;F[b+160>>2]=0;F[b+152>>2]=1065353216;F[b+164>>2]=0;F[b+168>>2]=0;F[b+172>>2]=0;F[b+176>>2]=0;F[b+180>>2]=0;F[b+184>>2]=0;F[b+188>>2]=0;F[b+192>>2]=0;F[b+196>>2]=0;F[b+200>>2]=0;F[b+204>>2]=0;F[b+208>>2]=0;F[b+212>>2]=-1;F[b+216>>2]=0;F[b+220>>2]=0;F[b+224>>2]=0;Ja(b+232|0);Ja(b+272|0);c=b+312|0;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;Ja(b+328|0);F[b+392>>2]=0;F[b+396>>2]=0;F[b+384>>2]=0;F[b+388>>2]=0;F[b+376>>2]=0;F[b+380>>2]=0;F[b+368>>2]=0;F[b+372>>2]=0;F[b+416>>2]=0;F[b+420>>2]=0;F[b+408>>2]=2;F[b+412>>2]=7;F[b+400>>2]=-1;F[b+404>>2]=-1;F[b+424>>2]=0;F[b+428>>2]=0;F[b+432>>2]=0;F[b+436>>2]=0;}c=F[a+48>>2];F[a+48>>2]=b;if(!c){break a}$[F[F[c>>2]+4>>2]](c);}b=F[a+48>>2];if(b){break a}return 0}a=$[F[F[b>>2]+8>>2]](b,a)|0;}else {a=0;}return a|0}function ei(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;g=Z-32|0;Z=g;F[a+68>>2]=f;d=F[a+56>>2];e=F[d>>2];d=F[d+4>>2];F[g+24>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+60|0;d=d>>>2|0;n=d>>>0<=1?1:d;o=a+112|0;while(1){e=F[a+56>>2];d=F[e>>2];if(F[e+4>>2]-d>>2>>>0<=j>>>0){break a}Mb(m,F[d+(j<<2)>>2],g+16|0);i=F[g+20>>2];d=i>>31;h=F[g+16>>2];e=h>>31;f=(d^i)-d+((e^h)-e)|0;k=F[g+24>>2];d=k>>31;e=(d^k)-d|0;d=0;l=e;e=e+f|0;d=l>>>0>e>>>0?1:d;b:{if(!(d|e)){F[g+16>>2]=F[a+108>>2];break b}f=F[a+108>>2];l=f>>31;h=li(ki(f,l,h,h>>31),_,e,d);F[g+16>>2]=h;d=li(ki(f,l,i,i>>31),_,e,d);F[g+20>>2]=d;e=d;d=d>>31;e=(e^d)-d|0;d=h>>31;d=e+((d^h)-d|0)|0;if((k|0)>=0){F[g+24>>2]=f-d;break b}F[g+24>>2]=d-f;}d=wa(o);f=F[g+16>>2];c:{if(d){F[g+24>>2]=0-F[g+24>>2];e=0-F[g+20>>2]|0;F[g+20>>2]=e;f=0-f|0;F[g+16>>2]=f;break c}e=F[g+20>>2];}d:{if((f|0)>=0){f=F[a+108>>2];d=f+F[g+24>>2]|0;f=e+f|0;break d}e:{if((e|0)<0){d=F[g+24>>2];f=d>>31;f=(d^f)-f|0;break e}d=F[g+24>>2];f=d>>31;f=F[a+100>>2]+(f-(d^f)|0)|0;}if((d|0)<0){d=e>>31;d=(d^e)-d|0;break d}d=e>>31;d=F[a+100>>2]+(d-(d^e)|0)|0;}e=F[a+100>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}i=F[a+108>>2];if((i|0)>=(d|0)){break g}d=(i<<1)-d|0;f=0;break f}h:{if((e|0)!=(f|0)){break h}i=F[a+108>>2];if((i|0)<=(d|0)){break h}d=(i<<1)-d|0;break f}i:{if((d|0)!=(e|0)){break i}e=F[a+108>>2];if((e|0)<=(f|0)){break i}f=(e<<1)-f|0;break f}if(d){break f}d=0;e=F[a+108>>2];if((e|0)>=(f|0)){break f}f=(e<<1)-f|0;}F[g+12>>2]=d;F[g+8>>2]=f;j:{if(F[a+8>>2]<=0){break j}i=F[a+32>>2];f=0;while(1){d=f<<2;e=F[d+(g+8|0)>>2];h=F[a+16>>2];k:{if((e|0)>(h|0)){F[d+i>>2]=h;break k}d=d+i|0;h=F[a+12>>2];if((h|0)>(e|0)){F[d>>2]=h;break k}F[d>>2]=e;}f=f+1|0;e=F[a+8>>2];if((f|0)<(e|0)){continue}break}d=0;if((e|0)<=0){break j}e=j<<3;h=e+c|0;k=b+e|0;while(1){f=d<<2;e=f+h|0;f=F[f+k>>2]+F[f+i>>2]|0;F[e>>2]=f;l:{if((f|0)>F[a+16>>2]){f=f-F[a+20>>2]|0;}else {if((f|0)>=F[a+12>>2]){break l}f=f+F[a+20>>2]|0;}F[e>>2]=f;}d=d+1|0;if((d|0)<F[a+8>>2]){continue}break}}j=j+1|0;if((n|0)!=(j|0)){continue}break}}Z=g+32|0;return 1}ta();v();}function Vh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;g=Z-32|0;Z=g;F[a+68>>2]=f;d=F[a+56>>2];e=F[d>>2];d=F[d+4>>2];F[g+24>>2]=0;F[g+16>>2]=0;F[g+20>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+60|0;d=d>>>2|0;n=d>>>0<=1?1:d;o=a+112|0;while(1){e=F[a+56>>2];d=F[e>>2];if(F[e+4>>2]-d>>2>>>0<=j>>>0){break a}Kb(m,F[d+(j<<2)>>2],g+16|0);i=F[g+20>>2];d=i>>31;h=F[g+16>>2];e=h>>31;f=(d^i)-d+((e^h)-e)|0;k=F[g+24>>2];d=k>>31;e=(d^k)-d|0;d=0;l=e;e=e+f|0;d=l>>>0>e>>>0?1:d;b:{if(!(d|e)){F[g+16>>2]=F[a+108>>2];break b}f=F[a+108>>2];l=f>>31;h=li(ki(f,l,h,h>>31),_,e,d);F[g+16>>2]=h;d=li(ki(f,l,i,i>>31),_,e,d);F[g+20>>2]=d;e=d;d=d>>31;e=(e^d)-d|0;d=h>>31;d=e+((d^h)-d|0)|0;if((k|0)>=0){F[g+24>>2]=f-d;break b}F[g+24>>2]=d-f;}d=wa(o);f=F[g+16>>2];c:{if(d){F[g+24>>2]=0-F[g+24>>2];e=0-F[g+20>>2]|0;F[g+20>>2]=e;f=0-f|0;F[g+16>>2]=f;break c}e=F[g+20>>2];}d:{if((f|0)>=0){f=F[a+108>>2];d=f+F[g+24>>2]|0;f=e+f|0;break d}e:{if((e|0)<0){d=F[g+24>>2];f=d>>31;f=(d^f)-f|0;break e}d=F[g+24>>2];f=d>>31;f=F[a+100>>2]+(f-(d^f)|0)|0;}if((d|0)<0){d=e>>31;d=(d^e)-d|0;break d}d=e>>31;d=F[a+100>>2]+(d-(d^e)|0)|0;}e=F[a+100>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}i=F[a+108>>2];if((i|0)>=(d|0)){break g}d=(i<<1)-d|0;f=0;break f}h:{if((e|0)!=(f|0)){break h}i=F[a+108>>2];if((i|0)<=(d|0)){break h}d=(i<<1)-d|0;break f}i:{if((d|0)!=(e|0)){break i}e=F[a+108>>2];if((e|0)<=(f|0)){break i}f=(e<<1)-f|0;break f}if(d){break f}d=0;e=F[a+108>>2];if((e|0)>=(f|0)){break f}f=(e<<1)-f|0;}F[g+12>>2]=d;F[g+8>>2]=f;j:{if(F[a+8>>2]<=0){break j}i=F[a+32>>2];f=0;while(1){d=f<<2;e=F[d+(g+8|0)>>2];h=F[a+16>>2];k:{if((e|0)>(h|0)){F[d+i>>2]=h;break k}d=d+i|0;h=F[a+12>>2];if((h|0)>(e|0)){F[d>>2]=h;break k}F[d>>2]=e;}f=f+1|0;e=F[a+8>>2];if((f|0)<(e|0)){continue}break}d=0;if((e|0)<=0){break j}e=j<<3;h=e+c|0;k=b+e|0;while(1){f=d<<2;e=f+h|0;f=F[f+k>>2]+F[f+i>>2]|0;F[e>>2]=f;l:{if((f|0)>F[a+16>>2]){f=f-F[a+20>>2]|0;}else {if((f|0)>=F[a+12>>2]){break l}f=f+F[a+20>>2]|0;}F[e>>2]=f;}d=d+1|0;if((d|0)<F[a+8>>2]){continue}break}}j=j+1|0;if((n|0)!=(j|0)){continue}break}}Z=g+32|0;return 1}ta();v();}function $a(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=Z-32|0;Z=h;a:{b:{if(F[a+8>>2]<<5>>>0>=b>>>0){break b}if((b|0)<0){break a}b=(b-1>>>5|0)+1|0;c=ka(b<<2);F[h+24>>2]=b;F[h+20>>2]=0;F[h+16>>2]=c;b=F[a>>2];F[h+12>>2]=0;F[h+8>>2]=b;c=F[a+4>>2];F[h+4>>2]=c&31;F[h>>2]=b+(c>>>3&536870908);e=Z-32|0;Z=e;i=F[h+4>>2];g=F[h+12>>2];j=F[h>>2];d=F[h+8>>2];b=(i-g|0)+(j-d<<3)|0;f=F[h+20>>2];c=b+f|0;F[h+20>>2]=c;if(!((c-1^f-1)>>>0<32?f:0)){F[F[h+16>>2]+((c>>>0>=33?c-1>>>5|0:0)<<2)>>2]=0;}c=F[h+16>>2]+(f>>>3&536870908)|0;f=f&31;c:{if((f|0)==(g|0)){if((b|0)<=0){break c}if(g){i=32-g|0;f=(b|0)<(i|0)?b:i;i=-1<<g&-1>>>i-f;F[c>>2]=F[c>>2]&(i^-1)|i&F[d>>2];d=d+4|0;c=(g+f>>>3&536870908)+c|0;b=b-f|0;}g=(b|0)/32|0;if(b+31>>>0>=63){pa(c,d,g<<2);}b=b-(g<<5)|0;if((b|0)<=0){break c}f=c;c=g<<2;g=f+c|0;b=-1>>>32-b|0;F[g>>2]=F[g>>2]&(b^-1)|b&F[c+d>>2];break c}F[e+28>>2]=g;F[e+24>>2]=d;F[e+20>>2]=i;F[e+16>>2]=j;F[e+12>>2]=f;F[e+8>>2]=c;b=F[e+28>>2];c=F[e+24>>2];g=(F[e+20>>2]-b|0)+(F[e+16>>2]-c<<3)|0;d:{if((g|0)<=0){b=F[e+12>>2];d=F[e+8>>2];break d}e:{if(!b){b=F[e+12>>2];break e}d=F[e+12>>2];j=32-d|0;k=32-b|0;f=(g|0)<(k|0)?g:k;i=f>>>0>j>>>0?j:f;l=F[e+8>>2];m=F[l>>2]&(-1<<d&-1>>>j-i^-1);j=F[c>>2]&(-1<<b&-1>>>k-f);F[l>>2]=m|(b>>>0<d>>>0?j<<d-b:j>>>b-d|0);c=d+i|0;b=c&31;F[e+12>>2]=b;d=l+(c>>>3&536870908)|0;F[e+8>>2]=d;c=f-i|0;if((c|0)>0){F[d>>2]=F[d>>2]&(-1>>>32-c^-1)|j>>>i+F[e+28>>2];F[e+12>>2]=c;b=c;}g=g-f|0;c=F[e+24>>2]+4|0;F[e+24>>2]=c;}i=-1<<b;f=32-b|0;if((g|0)>=32){j=i^-1;while(1){d=F[e+8>>2];c=F[c>>2];F[d>>2]=j&F[d>>2]|c<<b;F[e+8>>2]=d+4;F[d+4>>2]=i&F[d+4>>2]|c>>>f;c=F[e+24>>2]+4|0;F[e+24>>2]=c;d=g>>>0>63;g=g-32|0;if(d){continue}break}}d=F[e+8>>2];if((g|0)<=0){break d}j=f;f=(g|0)>(f|0)?f:g;j=F[d>>2]&(i&-1>>>j-f^-1);i=F[c>>2]&-1>>>32-g;F[d>>2]=j|i<<b;b=b+f|0;c=b&31;F[e+12>>2]=c;d=(b>>>3&536870908)+d|0;F[e+8>>2]=d;b=g-f|0;if((b|0)<=0){b=c;break d}F[d>>2]=F[d>>2]&(-1>>>32-b^-1)|i>>>f;F[e+12>>2]=b;}F[e+4>>2]=b;F[e>>2]=d;}Z=e+32|0;b=F[a>>2];F[a>>2]=F[h+16>>2];F[h+16>>2]=b;c=F[a+4>>2];F[a+4>>2]=F[h+20>>2];F[h+20>>2]=c;c=F[a+8>>2];F[a+8>>2]=F[h+24>>2];F[h+24>>2]=c;if(!b){break b}ja(b);}Z=h+32|0;return}na();v();}function xc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;n=$[F[F[a>>2]+44>>2]](a)|0;a:{if((n|0)<=0){break a}i=F[b+4>>2]-F[b>>2]>>2;e=Z+-64|0;Z=e;f=kb(e);d=L(F[2541],n);cc(f,F[F[a+8>>2]+56>>2],n&255,5,0,d,d>>31);f=bc(ka(96),f);D[f+84|0]=1;F[f+72>>2]=F[f+68>>2];ac(f,i);F[f+60>>2]=F[F[a+8>>2]+60>>2];d=F[a+16>>2];F[a+16>>2]=f;if(d){xa(d);}Z=e- -64|0;h=F[a+16>>2];if(!F[h+80>>2]){break a}j=F[F[h>>2]>>2];if(!j){break a}m=F[c+12>>2];e=m;d=F[c+20>>2];g=F[c+8>>2];k=F[c+16>>2];if((e|0)<=(d|0)&g>>>0<=k>>>0|(d|0)>(e|0)){break a}l=L(i,n);i=j+F[h+48>>2]|0;h=F[c>>2];j=G[h+k|0];e=k+1|0;f=e?d:d+1|0;F[c+16>>2]=e;F[c+20>>2]=f;b:{c:{if(j){if(mc(l,n,c,i)){break c}break a}if((f|0)>=(m|0)&e>>>0>=g>>>0|(f|0)>(m|0)){break a}g=G[e+h|0];f=k+2|0;d=f>>>0<2?d+1|0:d;F[c+16>>2]=f;F[c+20>>2]=d;d=F[F[a+16>>2]+64>>2];d=F[d+4>>2]-F[d>>2]|0;if((g|0)==F[2541]){e=l<<2;if(e>>>0>d>>>0){break a}g=F[c+8>>2];k=F[c+12>>2];j=F[c+20>>2];d=F[c+16>>2];f=e+d|0;j=f>>>0<e>>>0?j+1|0:j;if(f>>>0>g>>>0&(j|0)>=(k|0)|(j|0)>(k|0)){break a}la(i,d+F[c>>2]|0,e);f=F[c+20>>2];d=e+F[c+16>>2]|0;f=d>>>0<e>>>0?f+1|0:f;F[c+16>>2]=d;F[c+20>>2]=f;break c}if(d>>>0<L(g,l)>>>0){break a}d=F[c+8>>2];f=F[c+16>>2];e=d-f|0;m=d>>>0<f>>>0;d=F[c+20>>2];k=F[c+12>>2]-(m+d|0)|0;m=ki(g,0,l,0)>>>0>e>>>0;e=_;if(m&(e|0)>=(k|0)|(e|0)>(k|0)){break a}e=1;if(!l){break b}h=0;while(1){k=F[c+8>>2];j=F[c+12>>2];e=f+g|0;d=e>>>0<g>>>0?d+1|0:d;if(e>>>0>k>>>0&(d|0)>=(j|0)|(d|0)>(j|0)){return 0}la(i+(h<<2)|0,F[c>>2]+f|0,g);d=F[c+20>>2];f=g+F[c+16>>2]|0;d=f>>>0<g>>>0?d+1|0:d;F[c+16>>2]=f;F[c+20>>2]=d;h=h+1|0;if((l|0)!=(h|0)){continue}break}}e=1;if(!l){break b}d=F[a+20>>2];if(d){e=0;if($[F[F[d>>2]+32>>2]](d)|0){break b}}g=0;h=0;d:{if((l|0)<=0){break d}if((l|0)!=1){f=l&-2;while(1){e=g<<2;d=F[e+i>>2];F[e+i>>2]=0-(d&1)^d>>>1;d=e|4;e=F[d+i>>2];F[d+i>>2]=0-(e&1)^e>>>1;g=g+2|0;h=h+2|0;if((f|0)!=(h|0)){continue}break}}if(!(l&1)){break d}d=g<<2;f=F[d+i>>2];F[d+i>>2]=0-(f&1)^f>>>1;}e=0;}d=e;f=F[a+20>>2];e:{if(!f){break e}if(!($[F[F[f>>2]+40>>2]](f,c)|0)){break a}if(d){break e}a=F[a+20>>2];if(!($[F[F[a>>2]+44>>2]](a,i,i,l,n,F[b>>2])|0)){break a}}o=1;}return o|0}function Lh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=Z-48|0;Z=g;d=F[a+8>>2];if(d-2>>>0<=28){F[a+76>>2]=d;e=-1<<d;d=-2-e|0;F[a+84>>2]=d;F[a+80>>2]=e^-1;F[a+92>>2]=(d|0)/2;J[a+88>>2]=M(2)/M(d|0);}F[a+52>>2]=f;d=F[a+40>>2];e=F[d>>2];d=F[d+4>>2];F[g+16>>2]=0;F[g+8>>2]=0;F[g+12>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+8|0;n=a+44|0;d=d>>>2|0;o=d>>>0<=1?1:d;p=a+96|0;while(1){e=F[a+40>>2];d=F[e>>2];if(F[e+4>>2]-d>>2>>>0<=j>>>0){break a}Mb(n,F[d+(j<<2)>>2],g+8|0);h=F[g+12>>2];d=h>>31;i=F[g+8>>2];e=i>>31;f=(d^h)-d+((e^i)-e)|0;l=F[g+16>>2];d=l>>31;e=(d^l)-d|0;d=0;k=e;e=e+f|0;d=k>>>0>e>>>0?1:d;b:{if(!(d|e)){F[g+8>>2]=F[a+92>>2];break b}f=F[a+92>>2];k=f>>31;i=li(ki(f,k,i,i>>31),_,e,d);F[g+8>>2]=i;d=li(ki(f,k,h,h>>31),_,e,d);F[g+12>>2]=d;e=d>>31;e=(d^e)-e|0;d=i>>31;d=e+((d^i)-d|0)|0;if((l|0)>=0){F[g+16>>2]=f-d;break b}F[g+16>>2]=d-f;}d=wa(p);f=F[g+8>>2];c:{if(d){F[g+16>>2]=0-F[g+16>>2];e=0-F[g+12>>2]|0;F[g+12>>2]=e;f=0-f|0;F[g+8>>2]=f;break c}e=F[g+12>>2];}d:{if((f|0)>=0){f=F[a+92>>2];d=f+F[g+16>>2]|0;f=e+f|0;break d}e:{if((e|0)<0){d=F[g+16>>2];f=d>>31;f=(d^f)-f|0;break e}d=F[g+16>>2];f=d>>31;f=F[a+84>>2]+(f-(d^f)|0)|0;}if((d|0)<0){d=e>>31;d=(d^e)-d|0;break d}d=e>>31;d=F[a+84>>2]+(d-(d^e)|0)|0;}e=F[a+84>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}h=F[a+92>>2];if((h|0)>=(d|0)){break g}d=(h<<1)-d|0;f=0;break f}h:{if((e|0)!=(f|0)){break h}h=F[a+92>>2];if((h|0)<=(d|0)){break h}d=(h<<1)-d|0;break f}i:{if((d|0)!=(e|0)){break i}e=F[a+92>>2];if((e|0)<=(f|0)){break i}f=(e<<1)-f|0;break f}if(d){break f}d=0;e=F[a+92>>2];if((e|0)>=(f|0)){break f}f=(e<<1)-f|0;}e=j<<3;h=e+b|0;i=F[h>>2];h=F[h+4>>2];F[g+36>>2]=d;F[g+32>>2]=f;F[g+24>>2]=i;F[g+28>>2]=h;Jb(g+40|0,m,g+32|0,g+24|0);d=c+e|0;F[d>>2]=F[g+40>>2];F[d+4>>2]=F[g+44>>2];j=j+1|0;if((o|0)!=(j|0)){continue}break}}Z=g+48|0;return 1}ta();v();}function Hh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;g=Z-48|0;Z=g;d=F[a+8>>2];if(d-2>>>0<=28){F[a+76>>2]=d;e=-1<<d;d=-2-e|0;F[a+84>>2]=d;F[a+80>>2]=e^-1;F[a+92>>2]=(d|0)/2;J[a+88>>2]=M(2)/M(d|0);}F[a+52>>2]=f;d=F[a+40>>2];e=F[d>>2];d=F[d+4>>2];F[g+16>>2]=0;F[g+8>>2]=0;F[g+12>>2]=0;a:{d=d-e|0;if((d|0)>0){m=a+8|0;n=a+44|0;d=d>>>2|0;o=d>>>0<=1?1:d;p=a+96|0;while(1){e=F[a+40>>2];d=F[e>>2];if(F[e+4>>2]-d>>2>>>0<=j>>>0){break a}Kb(n,F[d+(j<<2)>>2],g+8|0);h=F[g+12>>2];d=h>>31;i=F[g+8>>2];e=i>>31;f=(d^h)-d+((e^i)-e)|0;l=F[g+16>>2];d=l>>31;e=(d^l)-d|0;d=0;k=e;e=e+f|0;d=k>>>0>e>>>0?1:d;b:{if(!(d|e)){F[g+8>>2]=F[a+92>>2];break b}f=F[a+92>>2];k=f>>31;i=li(ki(f,k,i,i>>31),_,e,d);F[g+8>>2]=i;d=li(ki(f,k,h,h>>31),_,e,d);F[g+12>>2]=d;e=d>>31;e=(d^e)-e|0;d=i>>31;d=e+((d^i)-d|0)|0;if((l|0)>=0){F[g+16>>2]=f-d;break b}F[g+16>>2]=d-f;}d=wa(p);f=F[g+8>>2];c:{if(d){F[g+16>>2]=0-F[g+16>>2];e=0-F[g+12>>2]|0;F[g+12>>2]=e;f=0-f|0;F[g+8>>2]=f;break c}e=F[g+12>>2];}d:{if((f|0)>=0){f=F[a+92>>2];d=f+F[g+16>>2]|0;f=e+f|0;break d}e:{if((e|0)<0){d=F[g+16>>2];f=d>>31;f=(d^f)-f|0;break e}d=F[g+16>>2];f=d>>31;f=F[a+84>>2]+(f-(d^f)|0)|0;}if((d|0)<0){d=e>>31;d=(d^e)-d|0;break d}d=e>>31;d=F[a+84>>2]+(d-(d^e)|0)|0;}e=F[a+84>>2];f:{if(!(d|f)){d=e;f=d;break f}if(!((d|0)!=(e|0)|f)){f=d;break f}if(!((e|0)!=(f|0)|d)){d=f;break f}g:{if(f){break g}h=F[a+92>>2];if((h|0)>=(d|0)){break g}d=(h<<1)-d|0;f=0;break f}h:{if((e|0)!=(f|0)){break h}h=F[a+92>>2];if((h|0)<=(d|0)){break h}d=(h<<1)-d|0;break f}i:{if((d|0)!=(e|0)){break i}e=F[a+92>>2];if((e|0)<=(f|0)){break i}f=(e<<1)-f|0;break f}if(d){break f}d=0;e=F[a+92>>2];if((e|0)>=(f|0)){break f}f=(e<<1)-f|0;}e=j<<3;h=e+b|0;i=F[h>>2];h=F[h+4>>2];F[g+36>>2]=d;F[g+32>>2]=f;F[g+24>>2]=i;F[g+28>>2]=h;Jb(g+40|0,m,g+32|0,g+24|0);d=c+e|0;F[d>>2]=F[g+40>>2];F[d+4>>2]=F[g+44>>2];j=j+1|0;if((o|0)!=(j|0)){continue}break}}Z=g+48|0;return 1}ta();v();}function Nd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;a:{if(!H[b+38>>1]){break a}if(!Ta(1,a+12|0,b)){break a}d=F[b+8>>2];e=F[b+16>>2];g=d-e|0;f=F[a+12>>2];d=F[b+12>>2]-(F[b+20>>2]+(d>>>0<e>>>0)|0)|0;if(g>>>0<f>>>6>>>0&(d|0)<=0|(d|0)<0){break a}d=F[a>>2];c=F[a+4>>2]-d>>2;b:{if(c>>>0<f>>>0){qa(a,f-c|0);f=F[a+12>>2];break b}if(c>>>0<=f>>>0){break b}F[a+4>>2]=d+(f<<2);}if(!f){return 1}d=F[b+16>>2];c=F[b+20>>2];l=F[a>>2];j=F[b+8>>2];i=F[b+12>>2];g=0;while(1){if((c|0)>=(i|0)&d>>>0>=j>>>0|(c|0)>(i|0)){return 0}m=F[b>>2];k=G[m+d|0];d=d+1|0;c=d?c:c+1|0;F[b+16>>2]=d;F[b+20>>2]=c;e=k>>>2|0;h=0;c:{d:{e:{f:{n=k&3;switch(n|0){case 3:break f;case 0:break d;default:break e}}e=e+g|0;if(e>>>0>=f>>>0){return 0}ma(l+(g<<2)|0,0,(k&252)+4|0);g=e;break c}while(1){if((d|0)==(j|0)&(c|0)==(i|0)){break a}f=G[d+m|0];d=d+1|0;c=d?c:c+1|0;F[b+16>>2]=d;F[b+20>>2]=c;e=f<<(h<<3|6)|e;h=h+1|0;if((n|0)!=(h|0)){continue}break}}F[l+(g<<2)>>2]=e;}f=F[a+12>>2];g=g+1|0;if(f>>>0>g>>>0){continue}break}b=a+16|0;j=F[a>>2];d=F[a+16>>2];c=F[a+20>>2]-d|0;g:{if(c>>>0<=16383){qa(b,4096-(c>>>2|0)|0);break g}if((c|0)==16384){break g}F[a+20>>2]=d+16384;}c=a+28|0;g=F[c>>2];d=F[a+32>>2]-g>>3;h:{if(d>>>0<f>>>0){_a(c,f-d|0);g=F[c>>2];break h}if(d>>>0>f>>>0){F[a+32>>2]=(f<<3)+g;}if(!f){break a}}d=F[b>>2];b=0;a=0;while(1){c=j+(b<<2)|0;h=F[c>>2];e=a;i=(b<<3)+g|0;F[i+4>>2]=a;F[i>>2]=h;c=F[c>>2];a=c+a|0;if(a>>>0>4096){break a}i:{if(a>>>0<=e>>>0){break i}h=0;i=c&7;if(i){while(1){F[d+(e<<2)>>2]=b;e=e+1|0;h=h+1|0;if((i|0)!=(h|0)){continue}break}}if(c-1>>>0<=6){break i}while(1){c=d+(e<<2)|0;F[c>>2]=b;F[c+28>>2]=b;F[c+24>>2]=b;F[c+20>>2]=b;F[c+16>>2]=b;F[c+12>>2]=b;F[c+8>>2]=b;F[c+4>>2]=b;e=e+8|0;if((e|0)!=(a|0)){continue}break}}b=b+1|0;if((f|0)!=(b|0)){continue}break}o=(a|0)==4096;}return o}function qf(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;f=Z-32|0;Z=f;e=f+8|0;c=Z-80|0;Z=c;a=F[b+36>>2];F[c+72>>2]=F[b+32>>2];F[c+76>>2]=a;d=F[b+28>>2];a=c- -64|0;F[a>>2]=F[b+24>>2];F[a+4>>2]=d;a=F[b+20>>2];F[c+56>>2]=F[b+16>>2];F[c+60>>2]=a;a=F[b+12>>2];F[c+48>>2]=F[b+8>>2];F[c+52>>2]=a;a=F[b+4>>2];F[c+40>>2]=F[b>>2];F[c+44>>2]=a;jc(c+8|0,c+40|0,c+24|0);a=F[c+8>>2];a:{if(a){F[e>>2]=a;a=e+4|0;if(D[c+23|0]>=0){b=c+8|4;e=F[b+4>>2];F[a>>2]=F[b>>2];F[a+4>>2]=e;F[a+8>>2]=F[b+8>>2];break a}ra(a,F[c+12>>2],F[c+16>>2]);if(D[c+23|0]>=0){break a}ja(F[c+12>>2]);break a}if(D[c+23|0]<0){ja(F[c+12>>2]);}a=G[c+31|0];if(a>>>0>=2){b=ka(32);D[b+26|0]=0;a=G[1475]|G[1476]<<8;D[b+24|0]=a;D[b+25|0]=a>>>8;a=G[1471]|G[1472]<<8|(G[1473]<<16|G[1474]<<24);d=G[1467]|G[1468]<<8|(G[1469]<<16|G[1470]<<24);D[b+16|0]=d;D[b+17|0]=d>>>8;D[b+18|0]=d>>>16;D[b+19|0]=d>>>24;D[b+20|0]=a;D[b+21|0]=a>>>8;D[b+22|0]=a>>>16;D[b+23|0]=a>>>24;a=G[1463]|G[1464]<<8|(G[1465]<<16|G[1466]<<24);d=G[1459]|G[1460]<<8|(G[1461]<<16|G[1462]<<24);D[b+8|0]=d;D[b+9|0]=d>>>8;D[b+10|0]=d>>>16;D[b+11|0]=d>>>24;D[b+12|0]=a;D[b+13|0]=a>>>8;D[b+14|0]=a>>>16;D[b+15|0]=a>>>24;a=G[1455]|G[1456]<<8|(G[1457]<<16|G[1458]<<24);d=G[1451]|G[1452]<<8|(G[1453]<<16|G[1454]<<24);D[b|0]=d;D[b+1|0]=d>>>8;D[b+2|0]=d>>>16;D[b+3|0]=d>>>24;D[b+4|0]=a;D[b+5|0]=a>>>8;D[b+6|0]=a>>>16;D[b+7|0]=a>>>24;F[c+8>>2]=-1;a=c+8|4;ra(a,b,26);d=D[c+23|0];F[e>>2]=F[c+8>>2];e=e+4|0;if((d|0)>=0){d=F[a+4>>2];F[e>>2]=F[a>>2];F[e+4>>2]=d;F[e+8>>2]=F[a+8>>2];ja(b);break a}ra(e,F[c+12>>2],F[c+16>>2]);if(D[c+23|0]<0){ja(F[c+12>>2]);}ja(b);break a}F[e>>2]=0;F[e+4>>2]=0;F[e+16>>2]=a;F[e+8>>2]=0;F[e+12>>2]=0;}Z=c+80|0;a=F[f+24>>2];if(D[f+23|0]<0){ja(F[f+12>>2]);}Z=f+32|0;return a|0}function Ph(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;e=Z-32|0;Z=e;a:{if((c|0)!=3){break a}c=F[a+4>>2];f=F[a+12>>2];F[e+24>>2]=-1;F[e+16>>2]=-1;F[e+20>>2]=1065353216;F[e+8>>2]=-1;F[e+12>>2]=-1;if((b|0)==-2){break a}i=F[F[F[c+4>>2]+8>>2]+(f<<2)>>2];if(($[F[F[c>>2]+8>>2]](c)|0)==1){h=F[F[F[c+4>>2]+8>>2]+(f<<2)>>2];b:{if(($[F[F[c>>2]+8>>2]](c)|0)!=1|b-1>>>0>5){break b}g=$[F[F[c>>2]+36>>2]](c)|0;a=$[F[F[c>>2]+44>>2]](c,f)|0;if(!g|!a){break b}f=$[F[F[c>>2]+40>>2]](c,f)|0;c:{if(f){if((b|0)!=6){break b}b=F[c+44>>2];d=ka(112);F[d+4>>2]=h;c=F[e+12>>2];F[d+8>>2]=F[e+8>>2];F[d+12>>2]=c;c=F[e+20>>2];F[d+16>>2]=F[e+16>>2];F[d+20>>2]=c;F[d+24>>2]=F[e+24>>2];F[d+40>>2]=a;c=a+12|0;F[d+36>>2]=c;F[d+32>>2]=f;F[d+28>>2]=b;F[d+68>>2]=a;F[d- -64>>2]=c;F[d+60>>2]=f;F[d+56>>2]=b;F[d+48>>2]=0;F[d+52>>2]=0;F[d>>2]=5928;F[d+88>>2]=1065353216;F[d+92>>2]=-1;F[d+80>>2]=-1;F[d+84>>2]=-1;F[d+72>>2]=1;F[d+76>>2]=-1;F[d+44>>2]=6492;a=d+96|0;break c}if((b|0)!=6){break b}b=F[c+44>>2];d=ka(112);F[d+4>>2]=h;c=F[e+12>>2];F[d+8>>2]=F[e+8>>2];F[d+12>>2]=c;c=F[e+20>>2];F[d+16>>2]=F[e+16>>2];F[d+20>>2]=c;F[d+24>>2]=F[e+24>>2];F[d+40>>2]=a;c=a+12|0;F[d+36>>2]=c;F[d+32>>2]=g;F[d+28>>2]=b;F[d+68>>2]=a;F[d- -64>>2]=c;F[d+60>>2]=g;F[d+56>>2]=b;F[d+48>>2]=0;F[d+52>>2]=0;F[d>>2]=6932;F[d+88>>2]=1065353216;F[d+92>>2]=-1;F[d+80>>2]=-1;F[d+84>>2]=-1;F[d+72>>2]=1;F[d+76>>2]=-1;F[d+44>>2]=7352;a=d+96|0;}F[a>>2]=0;F[a+4>>2]=0;D[a+5|0]=0;D[a+6|0]=0;D[a+7|0]=0;D[a+8|0]=0;D[a+9|0]=0;D[a+10|0]=0;D[a+11|0]=0;D[a+12|0]=0;}if(d){break a}}d=ka(28);F[d+4>>2]=i;a=F[e+12>>2];F[d+8>>2]=F[e+8>>2];F[d+12>>2]=a;a=F[e+20>>2];F[d+16>>2]=F[e+16>>2];F[d+20>>2]=a;F[d+24>>2]=F[e+24>>2];F[d>>2]=7764;}Z=e+32|0;return d|0}function $c(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;f=Z-80|0;Z=f;a:{if(!Wb(1,f+76|0,b)){break a}k=F[f+76>>2];if(!k){break a}c=F[b+8>>2];e=F[b+16>>2];c=ki(c-e|0,F[b+12>>2]-(F[b+20>>2]+(c>>>0<e>>>0)|0)|0,5,0);e=_;if(c>>>0<k>>>0&(e|0)<=0|(e|0)<0){break a}c=F[a+4>>2];d=F[a+8>>2]-c>>2;b:{if(d>>>0<k>>>0){qa(a+4|0,k-d|0);break b}if(d>>>0<=k>>>0){break b}F[a+8>>2]=c+(k<<2);}p=a+16|0;l=F[a+32>>2];while(1){g=F[b+12>>2];c=g;d=F[b+20>>2];h=F[b+8>>2];e=F[b+16>>2];if((c|0)<=(d|0)&h>>>0<=e>>>0|(c|0)<(d|0)){d=0;break a}m=F[b>>2];q=G[m+e|0];c=d;i=e+1|0;c=i?c:c+1|0;F[b+16>>2]=i;F[b+20>>2]=c;if(h>>>0<=i>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){d=0;break a}i=G[i+m|0];c=d;j=e+2|0;c=j>>>0<2?c+1|0:c;F[b+16>>2]=j;F[b+20>>2]=c;if(h>>>0<=j>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){d=0;break a}j=G[j+m|0];c=d;n=e+3|0;c=n>>>0<3?c+1|0:c;F[b+16>>2]=n;F[b+20>>2]=c;if(h>>>0<=n>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){d=0;break a}h=G[m+n|0];c=d;d=e+4|0;c=d>>>0<4?c+1|0:c;F[b+16>>2]=d;F[b+20>>2]=c;if(q>>>0>4){d=0;break a}if((i-12&255)>>>0<245){d=0;break a}if(!j){d=0;break a}c=kb(f+8|0);g=(h|0)!=0;d=i-1|0;if(d>>>0<=10){d=F[(d<<2)+10148>>2];}else {d=-1;}d=L(d,j);cc(c,q,j,i,g,d,d>>31);if(Wb(1,f+4|0,b)){e=F[f+4>>2];F[f+68>>2]=e;d=bc(ka(96),c);$[F[F[l>>2]+8>>2]](l,F[l+12>>2]-F[l+8>>2]>>2,d);d=(F[l+12>>2]-F[l+8>>2]>>2)-1|0;h=d<<2;F[F[h+F[l+8>>2]>>2]+60>>2]=e;F[F[a+4>>2]+(o<<2)>>2]=d;c=F[a+16>>2];e=F[a+20>>2]-c>>2;c:{if((e|0)>(d|0)){break c}F[f>>2]=-1;d=d+1|0;if(d>>>0>e>>>0){Fa(p,d-e|0,f);c=F[p>>2];break c}if(d>>>0>=e>>>0){break c}F[a+20>>2]=(d<<2)+c;}F[c+h>>2]=o;d=1;o=o+1|0;if((o|0)!=(k|0)){continue}break a}break}d=0;}Z=f+80|0;return d|0}function Oc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;k=Z-16|0;Z=k;F[k+8>>2]=c;h=F[a+12>>2];d=F[a+8>>2];g=h-d>>2;a:{if((g|0)>(b|0)){break a}e=b+1|0;if(e>>>0>g>>>0){l=e-g|0;f=F[a+16>>2];d=F[a+12>>2];if(l>>>0<=f-d>>2>>>0){if(l){e=d;d=l<<2;d=ma(e,0,d)+d|0;}F[a+12>>2]=d;break a}b:{c:{d:{m=F[a+8>>2];g=d-m>>2;i=g+l|0;if(i>>>0<1073741824){e=f-m|0;f=e>>>1|0;e=e>>>0>=2147483644?1073741823:f>>>0>i>>>0?f:i;if(e){if(e>>>0>=1073741824){break d}j=ka(e<<2);}h=(g<<2)+j|0;f=l<<2;i=ma(h,0,f);g=f+i|0;e=(e<<2)+j|0;if((d|0)==(m|0)){break c}while(1){d=d-4|0;f=F[d>>2];F[d>>2]=0;h=h-4|0;F[h>>2]=f;if((d|0)!=(m|0)){continue}break}F[a+16>>2]=e;e=F[a+12>>2];F[a+12>>2]=g;d=F[a+8>>2];F[a+8>>2]=h;if((d|0)==(e|0)){break b}while(1){e=e-4|0;f=F[e>>2];F[e>>2]=0;if(f){xa(f);}if((d|0)!=(e|0)){continue}break}break b}na();v();}oa();v();}F[a+16>>2]=e;F[a+12>>2]=g;F[a+8>>2]=i;}if(d){ja(d);}break a}if(e>>>0>=g>>>0){break a}d=d+(e<<2)|0;if((d|0)!=(h|0)){while(1){h=h-4|0;c=F[h>>2];F[h>>2]=0;if(c){xa(c);}if((d|0)!=(h|0)){continue}break}c=F[k+8>>2];}F[a+12>>2]=d;}e:{f:{d=F[c+56>>2];g:{if((d|0)>4){break g}j=L(d,12)+a|0;d=F[j+24>>2];if((d|0)!=F[j+28>>2]){F[d>>2]=b;F[j+24>>2]=d+4;break g}i=F[j+20>>2];g=d-i|0;f=g>>2;e=f+1|0;if(e>>>0>=1073741824){break f}d=g>>>1|0;e=g>>>0>=2147483644?1073741823:d>>>0>e>>>0?d:e;if(e){if(e>>>0>=1073741824){break e}d=ka(e<<2);}else {d=0;}f=d+(f<<2)|0;F[f>>2]=b;d=pa(d,i,g);F[j+20>>2]=d;F[j+24>>2]=f+4;F[j+28>>2]=d+(e<<2);if(!i){break g}ja(i);}F[c+60>>2]=b;a=F[a+8>>2];F[k+8>>2]=0;a=a+(b<<2)|0;b=F[a>>2];F[a>>2]=c;if(b){xa(b);}a=F[k+8>>2];F[k+8>>2]=0;if(a){xa(a);}Z=k+16|0;return}na();v();}oa();v();}function Pf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;i=c;d=a;a:{if(F[a+12>>2]==(b|0)){break a}a=b;b=F[d+4>>2];e=F[d>>2];if((b|0)!=(e|0)){while(1){c=b-12|0;if(D[b-1|0]<0){ja(F[c>>2]);}b=c;if((e|0)!=(b|0)){continue}break}}F[d+12>>2]=a;F[d+4>>2]=e;c=F[a>>2];j=a+4|0;if((c|0)==(j|0)){break a}while(1){a=F[d+4>>2];b:{if((a|0)!=F[d+8>>2]){c:{if(D[c+27|0]>=0){b=F[c+20>>2];F[a>>2]=F[c+16>>2];F[a+4>>2]=b;F[a+8>>2]=F[c+24>>2];break c}ra(a,F[c+16>>2],F[c+20>>2]);}F[d+4>>2]=a+12;break b}g=0;d:{e:{f:{a=F[d+4>>2];e=F[d>>2];f=(a-e|0)/12|0;b=f+1|0;if(b>>>0<357913942){h=(F[d+8>>2]-e|0)/12|0;k=h<<1;b=h>>>0>=178956970?357913941:b>>>0<k>>>0?k:b;if(b){if(b>>>0>=357913942){break f}g=ka(L(b,12));}h=L(b,12);b=L(f,12)+g|0;g:{if(D[c+27|0]>=0){f=F[c+20>>2];F[b>>2]=F[c+16>>2];F[b+4>>2]=f;F[b+8>>2]=F[c+24>>2];break g}ra(b,F[c+16>>2],F[c+20>>2]);e=F[d>>2];a=F[d+4>>2];}g=g+h|0;f=b+12|0;if((a|0)==(e|0)){break e}while(1){a=a-12|0;h=F[a+4>>2];b=b-12|0;F[b>>2]=F[a>>2];F[b+4>>2]=h;F[b+8>>2]=F[a+8>>2];F[a>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;if((a|0)!=(e|0)){continue}break}F[d+8>>2]=g;a=F[d+4>>2];F[d+4>>2]=f;e=F[d>>2];F[d>>2]=b;if((a|0)==(e|0)){break d}while(1){b=a-12|0;if(D[a-1|0]<0){ja(F[b>>2]);}a=b;if((e|0)!=(b|0)){continue}break}break d}na();v();}oa();v();}F[d+8>>2]=g;F[d+4>>2]=f;F[d>>2]=b;}if(e){ja(e);}}b=F[c+4>>2];h:{if(b){while(1){a=b;b=F[b>>2];if(b){continue}break h}}while(1){a=F[c+8>>2];b=F[a>>2]!=(c|0);c=a;if(b){continue}break}}c=a;if((j|0)!=(a|0)){continue}break}}a=0;i:{if((i|0)<0){break i}b=F[d>>2];if((F[d+4>>2]-b|0)/12>>>0<=i>>>0){break i}a=b+L(i,12)|0;a=D[a+11|0]<0?F[a>>2]:a;}return a|0}function Ad(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;i=Z-16|0;Z=i;F[i>>2]=b;f=-1;a:{if((b|0)==-1){F[i+4>>2]=-1;break a}f=b+1|0;F[i+4>>2]=(f>>>0)%3|0?f:b-2|0;if((b>>>0)%3|0){f=b-1|0;break a}f=b+2|0;}F[i+8>>2]=f;n=(b>>>0)/3|0;b:{c:{d:{while(1){e:{f:{j=F[(l<<2)+i>>2];if((j|0)!=-1){f=F[F[F[a+8>>2]+12>>2]+(j<<2)>>2];if((f|0)!=-1){break f}}f=0;g=F[a+216>>2];if((g|0)==F[a+220>>2]){break e}while(1){g=L(f,144)+g|0;d=F[g+136>>2];c=F[g+140>>2];g:{if(d>>>0<c>>>0){F[d>>2]=j;F[g+136>>2]=d+4;break g}e=d;d=F[g+132>>2];k=e-d|0;e=k>>2;h=e+1|0;if(h>>>0>=1073741824){break d}m=e<<2;c=c-d|0;e=c>>>1|0;h=c>>>0>=2147483644?1073741823:h>>>0<e>>>0?e:h;if(h){if(h>>>0>=1073741824){break c}c=ka(h<<2);}else {c=0;}e=m+c|0;F[e>>2]=j;c=pa(c,d,k);F[g+132>>2]=c;F[g+136>>2]=e+4;F[g+140>>2]=c+(h<<2);if(!d){break g}ja(d);}f=f+1|0;g=F[a+216>>2];if(f>>>0<(F[a+220>>2]-g|0)/144>>>0){continue}break}break e}if((b|0)==-1|(f>>>0)/3>>>0<n>>>0){break e}f=0;if(F[a+220>>2]==F[a+216>>2]){break e}while(1){h:{if(!wa(F[a+368>>2]+(f<<4)|0)){break h}g=F[a+216>>2]+L(f,144)|0;d=F[g+136>>2];c=F[g+140>>2];if(d>>>0<c>>>0){F[d>>2]=j;F[g+136>>2]=d+4;break h}e=d;d=F[g+132>>2];k=e-d|0;e=k>>2;h=e+1|0;if(h>>>0>=1073741824){break b}m=e<<2;c=c-d|0;e=c>>>1|0;h=c>>>0>=2147483644?1073741823:h>>>0<e>>>0?e:h;if(h){if(h>>>0>=1073741824){break c}c=ka(h<<2);}else {c=0;}e=m+c|0;F[e>>2]=j;c=pa(c,d,k);F[g+132>>2]=c;F[g+136>>2]=e+4;F[g+140>>2]=c+(h<<2);if(!d){break h}ja(d);}f=f+1|0;if(f>>>0<(F[a+220>>2]-F[a+216>>2]|0)/144>>>0){continue}break}}l=l+1|0;if((l|0)!=3){continue}break}Z=i+16|0;return 1}na();v();}oa();v();}na();v();}function Bd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=Z-16|0;Z=h;m=-1;a:{b:{c:{if(!Da(1,h+12|0,b)){break c}j=F[h+12>>2];if(j){c=F[a+8>>2];if((F[c+4>>2]-F[c>>2]>>2>>>0)/3>>>0<j>>>0){break c}while(1){if(!Da(1,h+8|0,b)){break c}c=F[h+8>>2];if(!Da(1,h+8|0,b)){break c}g=c+g|0;c=F[h+8>>2];if(g>>>0<c>>>0){break c}e=g-c|0;c=F[a+40>>2];d:{if((c|0)!=F[a+44>>2]){F[c+4>>2]=g;F[c>>2]=e;F[a+40>>2]=c+12;j=F[h+12>>2];break d}d=c;c=F[a+36>>2];l=d-c|0;d=(l|0)/12|0;f=d+1|0;if(f>>>0>=357913942){break b}i=d<<1;f=d>>>0>=178956970?357913941:f>>>0<i>>>0?i:f;if(f){if(f>>>0>=357913942){break a}i=ka(L(f,12));}else {i=0;}d=i+L(d,12)|0;F[d+4>>2]=g;F[d>>2]=e;e=pa(d+L((l|0)/-12|0,12)|0,c,l);F[a+44>>2]=i+L(f,12);F[a+40>>2]=d+12;F[a+36>>2]=e;if(!c){break d}ja(c);}k=k+1|0;if(k>>>0<j>>>0){continue}break}g=0;hc(b,0,0);if(j){while(1){c=G[b+36|0];d=H[F[a+4>>2]+36>>1];e:{f:{if(((d<<8|d>>>8)&65535)>>>0<=513){if(!c){break e}e=0;d=F[b+32>>2];k=d>>>3|0;f=F[b+24>>2];c=k+f|0;i=F[b+28>>2];g:{if(c>>>0>=i>>>0){c=d;break g}e=G[c|0];c=d+1|0;F[b+32>>2]=c;k=c>>>3|0;e=e>>>(d&7)&1;}if(i>>>0>f+k>>>0){break f}break e}if(!c){break e}e=0;c=F[b+32>>2];d=F[b+24>>2]+(c>>>3|0)|0;if(d>>>0>=I[b+28>>2]){break e}e=G[d|0]>>>(c&7)&1;}F[b+32>>2]=c+1;}c=F[a+36>>2]+L(g,12)|0;D[c+8|0]=G[c+8|0]&254|e&1;g=g+1|0;if((j|0)!=(g|0)){continue}break}}D[b+36|0]=0;d=F[b+20>>2];a=0;e=F[b+32>>2]+7|0;a=e>>>0<7?1:a;e=a<<29|e>>>3;c=e+F[b+16>>2]|0;a=(a>>>3|0)+d|0;F[b+16>>2]=c;F[b+20>>2]=c>>>0<e>>>0?a+1|0:a;}m=F[b+16>>2];}Z=h+16|0;return m}na();v();}oa();v();}function xf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Z-16|0;Z=m;l=F[b+80>>2];e=G[c+24|0];a=L(l,e);a:{b:{c:{d:{b=F[c+28>>2];if(!(!G[c+84|0]|(b|0)!=1&(b|0)!=2)){b=F[c+48>>2];c=F[F[c>>2]>>2];F[m+8>>2]=0;F[m>>2]=0;F[m+4>>2]=0;if(a){if((a|0)<0){break d}f=ka(a);h=la(f,b+c|0,a)+a|0;}a=F[d>>2];if(a){F[d+4>>2]=a;ja(a);}F[d+8>>2]=h;F[d+4>>2]=h;F[d>>2]=f;b=1;break a}if(e){f=ka(e);ma(f,0,e);}e:{i=F[d+4>>2];b=F[d>>2];g=i-b|0;f:{if(g>>>0<a>>>0){k=a-g|0;j=F[d+8>>2];if(k>>>0<=j-i>>>0){n=d,o=ma(i,0,k)+k|0,F[n+4>>2]=o;break f}if((a|0)<0){break e}i=j-b|0;j=i<<1;i=i>>>0>=1073741823?2147483647:a>>>0<j>>>0?j:a;j=ka(i);ma(j+g|0,0,k);g=pa(j,b,g);F[d+8>>2]=g+i;F[d+4>>2]=a+g;F[d>>2]=g;if(!b){break f}ja(b);break f}if(a>>>0>=g>>>0){break f}F[d+4>>2]=a+b;}if(!l){b=1;break c}if(!e){b=0;a=0;while(1){if(!Cb(c,G[c+84|0]?a:F[F[c+68>>2]+(a<<2)>>2],D[c+24|0],f)){break c}a=a+1|0;b=l>>>0<=a>>>0;if((a|0)!=(l|0)){continue}break}break c}i=e&252;g=e&3;b=0;j=e>>>0<4;e=0;while(1){if(!Cb(c,G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],D[c+24|0],f)){break c}b=0;a=0;k=0;if(!j){while(1){D[F[d>>2]+h|0]=G[a+f|0];D[(F[d>>2]+h|0)+1|0]=G[(a|1)+f|0];D[(F[d>>2]+h|0)+2|0]=G[(a|2)+f|0];D[(F[d>>2]+h|0)+3|0]=G[(a|3)+f|0];a=a+4|0;h=h+4|0;k=k+4|0;if((i|0)!=(k|0)){continue}break}}if(g){while(1){D[F[d>>2]+h|0]=G[a+f|0];a=a+1|0;h=h+1|0;b=b+1|0;if((g|0)!=(b|0)){continue}break}}e=e+1|0;b=l>>>0<=e>>>0;if((e|0)!=(l|0)){continue}break}break b}na();v();}na();v();}if(!f){break a}}ja(f);}Z=m+16|0;return b&1}function wf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;m=Z-16|0;Z=m;l=F[b+80>>2];e=G[c+24|0];a=L(l,e);a:{b:{c:{d:{b=F[c+28>>2];if(!(!G[c+84|0]|(b|0)!=1&(b|0)!=2)){b=F[c+48>>2];c=F[F[c>>2]>>2];F[m+8>>2]=0;F[m>>2]=0;F[m+4>>2]=0;if(a){if((a|0)<0){break d}f=ka(a);h=la(f,b+c|0,a)+a|0;}a=F[d>>2];if(a){F[d+4>>2]=a;ja(a);}F[d+8>>2]=h;F[d+4>>2]=h;F[d>>2]=f;b=1;break a}if(e){f=ka(e);ma(f,0,e);}e:{i=F[d+4>>2];b=F[d>>2];g=i-b|0;f:{if(g>>>0<a>>>0){k=a-g|0;j=F[d+8>>2];if(k>>>0<=j-i>>>0){n=d,o=ma(i,0,k)+k|0,F[n+4>>2]=o;break f}if((a|0)<0){break e}i=j-b|0;j=i<<1;i=i>>>0>=1073741823?2147483647:a>>>0<j>>>0?j:a;j=ka(i);ma(j+g|0,0,k);g=pa(j,b,g);F[d+8>>2]=g+i;F[d+4>>2]=a+g;F[d>>2]=g;if(!b){break f}ja(b);break f}if(a>>>0>=g>>>0){break f}F[d+4>>2]=a+b;}if(!l){b=1;break c}if(!e){b=0;a=0;while(1){if(!Bb(c,G[c+84|0]?a:F[F[c+68>>2]+(a<<2)>>2],D[c+24|0],f)){break c}a=a+1|0;b=l>>>0<=a>>>0;if((a|0)!=(l|0)){continue}break}break c}i=e&252;g=e&3;b=0;j=e>>>0<4;e=0;while(1){if(!Bb(c,G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],D[c+24|0],f)){break c}b=0;a=0;k=0;if(!j){while(1){D[F[d>>2]+h|0]=G[a+f|0];D[(F[d>>2]+h|0)+1|0]=G[(a|1)+f|0];D[(F[d>>2]+h|0)+2|0]=G[(a|2)+f|0];D[(F[d>>2]+h|0)+3|0]=G[(a|3)+f|0];a=a+4|0;h=h+4|0;k=k+4|0;if((i|0)!=(k|0)){continue}break}}if(g){while(1){D[F[d>>2]+h|0]=G[a+f|0];a=a+1|0;h=h+1|0;b=b+1|0;if((g|0)!=(b|0)){continue}break}}e=e+1|0;b=l>>>0<=e>>>0;if((e|0)!=(l|0)){continue}break}break b}na();v();}na();v();}if(!f){break a}}ja(f);}Z=m+16|0;return b&1}function Jb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;k=F[b+16>>2];h=F[c+4>>2]-k|0;e=F[c>>2]-k|0;F[c>>2]=e;f=h;F[c+4>>2]=f;l=F[b+16>>2];f=f>>31;g=(h^f)-f|0;f=e>>31;m=l>>>0>=g+((f^e)-f|0)>>>0;a:{if(m){f=h;break a}b:{c:{if((e|0)>=0){g=1;j=1;if((h|0)>=0){break b}i=1;g=-1;j=-1;if(e){break c}break b}i=-1;g=-1;j=-1;if((h|0)<=0){break b}}g=(h|0)<=0?-1:1;j=i;}n=L(j,l);f=(e<<1)-n|0;i=(L(g,j)|0)>=0;e=L(g,l);f=((i?0-f|0:f)+e|0)/2|0;F[c+4>>2]=f;e=(h<<1)-e|0;e=((i?0-e|0:e)+n|0)/2|0;F[c>>2]=e;}d:{e:{f:{g:{h:{i:{j:{if(e){if((e|0)<0){break j}if((f|0)>=0){break i}break f}if(f){break h}j=1;g=0;f=0;i=0;break d}j=1;if((f|0)>0){break g}i=(f|0)>0?3:0;g=f;f=e;break d}g=0-f|0;f=0-e|0;i=2;break e}if((f|0)<=0){break f}}f=0-f|0;g=e;i=3;break e}g=0-e|0;i=1;}F[c>>2]=f;F[c+4>>2]=g;j=0;}e=F[d>>2]+f|0;h=F[b+16>>2];k:{if((e|0)>(h|0)){e=e-F[b+4>>2]|0;break k}if((0-h|0)<=(e|0)){break k}e=F[b+4>>2]+e|0;}c=F[d+4>>2]+g|0;l:{if((h|0)<(c|0)){c=c-F[b+4>>2]|0;break l}if((0-h|0)<=(c|0)){break l}c=F[b+4>>2]+c|0;}m:{if(j){b=c;break m}b=c;n:{o:{p:{d=4-i|0;switch((d>>>0<4?d:0-i|0)-1|0){case 2:break n;case 1:break o;case 0:break p;default:break m}}b=0-e|0;e=c;break m}b=0-c|0;e=0-e|0;break m}b=e;e=0-c|0;}q:{if(m){c=b;break q}r:{s:{if((e|0)>=0){c=1;f=1;if((b|0)>=0){break r}d=1;c=-1;f=-1;if(e){break s}break r}d=-1;c=-1;f=-1;if((b|0)<=0){break r}}c=(b|0)<=0?-1:1;f=d;}d=e<<1;e=L(f,h);d=d-e|0;f=(L(c,f)|0)>=0;g=f?0-d|0:d;d=L(c,h);c=(g+d|0)/2|0;b=(b<<1)-d|0;e=(e+(f?0-b|0:b)|0)/2|0;}b=a;F[b>>2]=e+k;F[b+4>>2]=c+k;}function Uh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;F[a+8>>2]=e;m=a+32|0;h=F[m>>2];g=F[a+36>>2]-h>>2;a:{if(g>>>0<e>>>0){qa(m,e-g|0);f=F[a+8>>2];break a}f=e;if(f>>>0>=g>>>0){break a}F[a+36>>2]=h+(e<<2);f=e;}g=e>>>0>1073741823?-1:e<<2;n=ma(ka(g),0,g);b:{if((f|0)<=0){break b}h=F[a+32>>2];while(1){f=i<<2;g=F[f+n>>2];j=F[a+16>>2];c:{if((g|0)>(j|0)){F[f+h>>2]=j;break c}f=f+h|0;j=F[a+12>>2];if((j|0)>(g|0)){F[f>>2]=j;break c}F[f>>2]=g;}f=F[a+8>>2];i=i+1|0;if((f|0)>(i|0)){continue}break}if((f|0)<=0){break b}i=0;while(1){g=i<<2;f=g+c|0;g=F[b+g>>2]+F[g+h>>2]|0;F[f>>2]=g;d:{if((g|0)>F[a+16>>2]){g=g-F[a+20>>2]|0;}else {if((g|0)>=F[a+12>>2]){break d}g=g+F[a+20>>2]|0;}F[f>>2]=g;}f=F[a+8>>2];i=i+1|0;if((f|0)>(i|0)){continue}break}}if(!((d|0)<=(e|0)|(f|0)<=0)){p=0-e<<2;g=e;while(1){e:{if((f|0)<=0){break e}l=g<<2;o=l+c|0;q=o+p|0;j=F[m>>2];i=0;while(1){f=i<<2;h=F[f+q>>2];k=F[a+16>>2];f:{if((h|0)>(k|0)){F[f+j>>2]=k;break f}f=f+j|0;k=F[a+12>>2];if((k|0)>(h|0)){F[f>>2]=k;break f}F[f>>2]=h;}f=F[a+8>>2];i=i+1|0;if((f|0)>(i|0)){continue}break}i=0;if((f|0)<=0){break e}l=b+l|0;while(1){h=i<<2;f=h+o|0;h=F[h+l>>2]+F[h+j>>2]|0;F[f>>2]=h;g:{if((h|0)>F[a+16>>2]){h=h-F[a+20>>2]|0;}else {if((h|0)>=F[a+12>>2]){break g}h=h+F[a+20>>2]|0;}F[f>>2]=h;}f=F[a+8>>2];i=i+1|0;if((f|0)>(i|0)){continue}break}}g=e+g|0;if((g|0)<(d|0)){continue}break}}ja(n);return 1}function yf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;j=F[b+80>>2];b=G[c+24|0];g=L(j,b);a:{if(!b){break a}h=b<<2;f=ka(h);a=f;k=b&7;if(k){while(1){F[a>>2]=-1073741824;a=a+4|0;e=e+1|0;if((k|0)!=(e|0)){continue}break}}if((b-1&1073741823)>>>0<7){break a}e=f+h|0;while(1){F[a+24>>2]=-1073741824;F[a+28>>2]=-1073741824;F[a+16>>2]=-1073741824;F[a+20>>2]=-1073741824;F[a+8>>2]=-1073741824;F[a+12>>2]=-1073741824;F[a>>2]=-1073741824;F[a+4>>2]=-1073741824;a=a+32|0;if((e|0)!=(a|0)){continue}break}}e=F[d>>2];a=F[d+4>>2]-e>>2;b:{if(a>>>0<g>>>0){qa(d,g-a|0);break b}if(a>>>0<=g>>>0){break b}F[d+4>>2]=e+(g<<2);}c:{d:{e:{if(!j){i=1;break e}if(!b){a=0;while(1){if(!lb(c,G[c+84|0]?a:F[F[c+68>>2]+(a<<2)>>2],D[c+24|0],f)){break e}a=a+1|0;i=j>>>0<=a>>>0;if((a|0)!=(j|0)){continue}break}break e}n=b&252;k=b&3;o=b>>>0<4;e=0;b=0;while(1){if(!lb(c,G[c+84|0]?b:F[F[c+68>>2]+(b<<2)>>2],D[c+24|0],f)){break e}m=F[d>>2];i=0;a=0;l=0;if(!o){while(1){g=(e<<2)+m|0;h=a<<2;J[g>>2]=J[h+f>>2];J[g+4>>2]=J[(h|4)+f>>2];J[g+8>>2]=J[(h|8)+f>>2];J[g+12>>2]=J[(h|12)+f>>2];a=a+4|0;e=e+4|0;l=l+4|0;if((n|0)!=(l|0)){continue}break}}if(k){while(1){J[(e<<2)+m>>2]=J[(a<<2)+f>>2];a=a+1|0;e=e+1|0;i=i+1|0;if((k|0)!=(i|0)){continue}break}}b=b+1|0;i=j>>>0<=b>>>0;if((b|0)!=(j|0)){continue}break}break d}if(!f){break c}}ja(f);}return i|0}function $d(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;k=Z-16|0;Z=k;c=F[b+20>>2];d=F[b+16>>2];e=d+4|0;c=e>>>0<4?c+1|0:c;g=F[b+12>>2];a:{if(I[b+8>>2]<e>>>0&(g|0)<=(c|0)|(c|0)>(g|0)){break a}d=d+F[b>>2]|0;h=G[d|0]|G[d+1|0]<<8|(G[d+2|0]<<16|G[d+3|0]<<24);F[b+16>>2]=e;F[b+20>>2]=c;if((h|0)<0){break a}Na(a+76|0,h);c=k;F[c>>2]=0;F[c+4>>2]=0;D[c+5|0]=0;D[c+6|0]=0;D[c+7|0]=0;D[c+8|0]=0;D[c+9|0]=0;D[c+10|0]=0;D[c+11|0]=0;D[c+12|0]=0;b:{if(!Aa(c,b)){break b}if(h){g=1;while(1){d=1<<i;e=wa(c);f=F[a+76>>2]+(i>>>3&536870908)|0;e=e^g;if(e&1){d=F[f>>2]&(d^-1);}else {d=d|F[f>>2];}g=e^1;F[f>>2]=d;i=i+1|0;if((h|0)!=(i|0)){continue}break}}i=0;c=F[b+8>>2];e=F[b+12>>2];f=e;e=F[b+20>>2];g=e;l=F[b+16>>2];d=l+4|0;e=d>>>0<4?e+1|0:e;h=d;if(d>>>0>c>>>0&(e|0)>=(f|0)|(e|0)>(f|0)){break b}m=F[b>>2];d=m+l|0;j=G[d|0]|G[d+1|0]<<8|(G[d+2|0]<<16|G[d+3|0]<<24);F[b+16>>2]=h;F[b+20>>2]=e;d=c;c=g;e=l+8|0;c=e>>>0<8?c+1|0:c;if(d>>>0<e>>>0&(c|0)>=(f|0)|(c|0)>(f|0)){break b}d=h+m|0;d=G[d|0]|G[d+1|0]<<8|(G[d+2|0]<<16|G[d+3|0]<<24);F[b+16>>2]=e;F[b+20>>2]=c;if((d|0)<(j|0)){break b}F[a+16>>2]=d;F[a+12>>2]=j;c=(d>>31)-((j>>31)+(d>>>0<j>>>0)|0)|0;b=d-j|0;if(!c&b>>>0>2147483646|c){break b}i=1;c=b+1|0;F[a+20>>2]=c;b=c>>>1|0;F[a+24>>2]=b;F[a+28>>2]=0-b;if(c&1){break b}F[a+24>>2]=b-1;}}Z=k+16|0;return i|0}function tf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=0;k=Z-16|0;Z=k;j=F[b+80>>2];e=G[c+24|0];b=L(j,e);a:{b:{c:{d:{f=F[c+28>>2];if(!(!G[c+84|0]|(f|0)!=5&(f|0)!=6)){e=F[c+48>>2];c=F[F[c>>2]>>2];F[k+8>>2]=0;F[k>>2]=0;F[k+4>>2]=0;if(b){if((b|0)<0){break d}b=b<<2;a=ka(b);g=la(a,c+e|0,b)+b|0;}b=F[d>>2];if(b){F[d+4>>2]=b;ja(b);}F[d+8>>2]=g;F[d+4>>2]=g;F[d>>2]=a;h=1;break a}if(e){f=e<<2;a=ka(f);ma(a,0,f);}i=F[d>>2];f=F[d+4>>2]-i>>2;e:{if(f>>>0<b>>>0){qa(d,b-f|0);break e}if(b>>>0>=f>>>0){break e}F[d+4>>2]=i+(b<<2);}if(!j){h=1;break c}if(!e){b=0;while(1){if(!xb(c,G[c+84|0]?b:F[F[c+68>>2]+(b<<2)>>2],D[c+24|0],a)){break c}b=b+1|0;h=j>>>0<=b>>>0;if((b|0)!=(j|0)){continue}break}break c}o=e&252;m=e&3;p=e>>>0<4;e=0;while(1){if(!xb(c,G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],D[c+24|0],a)){break c}n=F[d>>2];l=0;b=0;h=0;if(!p){while(1){f=(g<<2)+n|0;i=b<<2;F[f>>2]=F[i+a>>2];F[f+4>>2]=F[(i|4)+a>>2];F[f+8>>2]=F[(i|8)+a>>2];F[f+12>>2]=F[(i|12)+a>>2];b=b+4|0;g=g+4|0;h=h+4|0;if((o|0)!=(h|0)){continue}break}}if(m){while(1){F[(g<<2)+n>>2]=F[(b<<2)+a>>2];b=b+1|0;g=g+1|0;l=l+1|0;if((l|0)!=(m|0)){continue}break}}e=e+1|0;h=j>>>0<=e>>>0;if((e|0)!=(j|0)){continue}break}break b}na();v();}if(!a){break a}}ja(a);}Z=k+16|0;return h|0}function cd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=0;k=Z-16|0;Z=k;j=F[b+80>>2];e=G[c+24|0];b=L(j,e);a:{b:{c:{d:{f=F[c+28>>2];if(!(!G[c+84|0]|(f|0)!=5&(f|0)!=6)){e=F[c+48>>2];c=F[F[c>>2]>>2];F[k+8>>2]=0;F[k>>2]=0;F[k+4>>2]=0;if(b){if((b|0)<0){break d}b=b<<2;a=ka(b);g=la(a,c+e|0,b)+b|0;}b=F[d>>2];if(b){F[d+4>>2]=b;ja(b);}F[d+8>>2]=g;F[d+4>>2]=g;F[d>>2]=a;h=1;break a}if(e){f=e<<2;a=ka(f);ma(a,0,f);}i=F[d>>2];f=F[d+4>>2]-i>>2;e:{if(f>>>0<b>>>0){qa(d,b-f|0);break e}if(b>>>0>=f>>>0){break e}F[d+4>>2]=i+(b<<2);}if(!j){h=1;break c}if(!e){b=0;while(1){if(!yb(c,G[c+84|0]?b:F[F[c+68>>2]+(b<<2)>>2],D[c+24|0],a)){break c}b=b+1|0;h=j>>>0<=b>>>0;if((b|0)!=(j|0)){continue}break}break c}o=e&252;m=e&3;p=e>>>0<4;e=0;while(1){if(!yb(c,G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],D[c+24|0],a)){break c}n=F[d>>2];l=0;b=0;h=0;if(!p){while(1){f=(g<<2)+n|0;i=b<<2;F[f>>2]=F[i+a>>2];F[f+4>>2]=F[(i|4)+a>>2];F[f+8>>2]=F[(i|8)+a>>2];F[f+12>>2]=F[(i|12)+a>>2];b=b+4|0;g=g+4|0;h=h+4|0;if((o|0)!=(h|0)){continue}break}}if(m){while(1){F[(g<<2)+n>>2]=F[(b<<2)+a>>2];b=b+1|0;g=g+1|0;l=l+1|0;if((l|0)!=(m|0)){continue}break}}e=e+1|0;h=j>>>0<=e>>>0;if((e|0)!=(j|0)){continue}break}break b}na();v();}if(!a){break a}}ja(a);}Z=k+16|0;return h|0}function vf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=0;k=Z-16|0;Z=k;j=F[b+80>>2];e=G[c+24|0];b=L(j,e);a:{b:{c:{d:{f=F[c+28>>2];if(!(!G[c+84|0]|(f|0)!=3&(f|0)!=4)){e=F[c+48>>2];c=F[F[c>>2]>>2];F[k+8>>2]=0;F[k>>2]=0;F[k+4>>2]=0;if(b){if((b|0)<0){break d}b=b<<1;a=ka(b);g=la(a,c+e|0,b)+b|0;}b=F[d>>2];if(b){F[d+4>>2]=b;ja(b);}F[d+8>>2]=g;F[d+4>>2]=g;F[d>>2]=a;h=1;break a}if(e){f=e<<1;a=ka(f);ma(a,0,f);}i=F[d>>2];f=F[d+4>>2]-i>>1;e:{if(f>>>0<b>>>0){kd(d,b-f|0);break e}if(b>>>0>=f>>>0){break e}F[d+4>>2]=i+(b<<1);}if(!j){h=1;break c}if(!e){b=0;while(1){if(!Ab(c,G[c+84|0]?b:F[F[c+68>>2]+(b<<2)>>2],D[c+24|0],a)){break c}b=b+1|0;h=j>>>0<=b>>>0;if((b|0)!=(j|0)){continue}break}break c}o=e&252;m=e&3;p=e>>>0<4;e=0;while(1){if(!Ab(c,G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],D[c+24|0],a)){break c}n=F[d>>2];l=0;b=0;h=0;if(!p){while(1){f=(g<<1)+n|0;i=b<<1;E[f>>1]=H[i+a>>1];E[f+2>>1]=H[(i|2)+a>>1];E[f+4>>1]=H[(i|4)+a>>1];E[f+6>>1]=H[(i|6)+a>>1];b=b+4|0;g=g+4|0;h=h+4|0;if((o|0)!=(h|0)){continue}break}}if(m){while(1){E[(g<<1)+n>>1]=H[(b<<1)+a>>1];b=b+1|0;g=g+1|0;l=l+1|0;if((l|0)!=(m|0)){continue}break}}e=e+1|0;h=j>>>0<=e>>>0;if((e|0)!=(j|0)){continue}break}break b}na();v();}if(!a){break a}}ja(a);}Z=k+16|0;return h|0}function uf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;a=0;k=Z-16|0;Z=k;j=F[b+80>>2];e=G[c+24|0];b=L(j,e);a:{b:{c:{d:{f=F[c+28>>2];if(!(!G[c+84|0]|(f|0)!=3&(f|0)!=4)){e=F[c+48>>2];c=F[F[c>>2]>>2];F[k+8>>2]=0;F[k>>2]=0;F[k+4>>2]=0;if(b){if((b|0)<0){break d}b=b<<1;a=ka(b);g=la(a,c+e|0,b)+b|0;}b=F[d>>2];if(b){F[d+4>>2]=b;ja(b);}F[d+8>>2]=g;F[d+4>>2]=g;F[d>>2]=a;h=1;break a}if(e){f=e<<1;a=ka(f);ma(a,0,f);}i=F[d>>2];f=F[d+4>>2]-i>>1;e:{if(f>>>0<b>>>0){kd(d,b-f|0);break e}if(b>>>0>=f>>>0){break e}F[d+4>>2]=i+(b<<1);}if(!j){h=1;break c}if(!e){b=0;while(1){if(!zb(c,G[c+84|0]?b:F[F[c+68>>2]+(b<<2)>>2],D[c+24|0],a)){break c}b=b+1|0;h=j>>>0<=b>>>0;if((b|0)!=(j|0)){continue}break}break c}o=e&252;m=e&3;p=e>>>0<4;e=0;while(1){if(!zb(c,G[c+84|0]?e:F[F[c+68>>2]+(e<<2)>>2],D[c+24|0],a)){break c}n=F[d>>2];l=0;b=0;h=0;if(!p){while(1){f=(g<<1)+n|0;i=b<<1;E[f>>1]=H[i+a>>1];E[f+2>>1]=H[(i|2)+a>>1];E[f+4>>1]=H[(i|4)+a>>1];E[f+6>>1]=H[(i|6)+a>>1];b=b+4|0;g=g+4|0;h=h+4|0;if((o|0)!=(h|0)){continue}break}}if(m){while(1){E[(g<<1)+n>>1]=H[(b<<1)+a>>1];b=b+1|0;g=g+1|0;l=l+1|0;if((l|0)!=(m|0)){continue}break}}e=e+1|0;h=j>>>0<=e>>>0;if((e|0)!=(j|0)){continue}break}break b}na();v();}if(!a){break a}}ja(a);}Z=k+16|0;return h|0}function kc(a,b){var c=0,d=0,e=0,f=0,g=0;f=-1;d=-1;a:{if((b|0)==-1){break a}d=b+1|0;f=(d>>>0)%3|0?d:b-2|0;d=b-1|0;if((b>>>0)%3|0){break a}d=b+2|0;}b:{c:{d:{switch(F[a+168>>2]){case 0:case 1:e=F[a+148>>2];c=1;b=F[a+156>>2];g=b+(((f|0)==-1?-1:F[F[e>>2]+(f<<2)>>2])<<2)|0;F[g>>2]=F[g>>2]+1;b=(((d|0)==-1?-1:F[F[e>>2]+(d<<2)>>2])<<2)+b|0;break c;case 5:e=F[a+148>>2];c=-1;c=((b|0)!=-1?F[F[e>>2]+(b<<2)>>2]:c)<<2;b=F[a+156>>2];c=c+b|0;F[c>>2]=F[c>>2]+1;c=(((f|0)==-1?-1:F[F[e>>2]+(f<<2)>>2])<<2)+b|0;F[c>>2]=F[c>>2]+1;c=2;b=(((d|0)==-1?-1:F[F[e>>2]+(d<<2)>>2])<<2)+b|0;break c;case 3:e=F[a+148>>2];c=-1;c=((b|0)!=-1?F[F[e>>2]+(b<<2)>>2]:c)<<2;b=F[a+156>>2];c=c+b|0;F[c>>2]=F[c>>2]+1;c=(((f|0)==-1?-1:F[F[e>>2]+(f<<2)>>2])<<2)+b|0;F[c>>2]=F[c>>2]+2;c=1;b=(((d|0)==-1?-1:F[F[e>>2]+(d<<2)>>2])<<2)+b|0;break c;case 7:break d;default:break b}}e=F[a+148>>2];c=-1;c=((b|0)!=-1?F[F[e>>2]+(b<<2)>>2]:c)<<2;b=F[a+156>>2];c=c+b|0;F[c>>2]=F[c>>2]+2;c=(((f|0)==-1?-1:F[F[e>>2]+(f<<2)>>2])<<2)+b|0;F[c>>2]=F[c>>2]+2;c=2;b=(((d|0)==-1?-1:F[F[e>>2]+(d<<2)>>2])<<2)+b|0;}F[b>>2]=F[b>>2]+c;}c=a;b=F[F[a+156>>2]+(((f|0)==-1?-1:F[F[F[a+148>>2]>>2]+(f<<2)>>2])<<2)>>2];d=F[a+180>>2];a=F[a+176>>2];F[c+172>>2]=(a|0)<=(b|0)?((b|0)<(d|0)?b:d)-a|0:0;}function Dg(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;a:{b=F[a+32>>2];f=F[b+8>>2];h=F[b+12>>2];g=F[b+20>>2];c=F[b+16>>2];e=0;b:{if((h|0)<=(g|0)&c>>>0>=f>>>0|(g|0)>(h|0)){break b}f=G[F[b>>2]+c|0];e=b;b=g;c=c+1|0;b=c?b:b+1|0;F[e+16>>2]=c;F[e+20>>2]=b;c:{if(!f){break c}while(1){if($[F[F[a>>2]+16>>2]](a,d)|0){d=d+1|0;if((f|0)!=(d|0)){continue}break c}break}return 0}d=F[a+8>>2];b=F[a+12>>2];if((d|0)!=(b|0)){while(1){c=F[d>>2];if(!($[F[F[c>>2]+8>>2]](c,a,F[a+4>>2])|0)){break a}d=d+4|0;if((b|0)!=(d|0)){continue}break}}d:{if(!f){break d}d=0;while(1){b=F[F[a+8>>2]+(d<<2)>>2];if(!($[F[F[b>>2]+12>>2]](b,F[a+32>>2])|0)){break a}d=d+1|0;if((f|0)!=(d|0)){continue}break}if(!f){break d}i=a+20|0;b=0;while(1){d=0;j=b<<2;c=F[j+F[a+8>>2]>>2];k=$[F[F[c>>2]+24>>2]](c)|0;if((k|0)>0){while(1){c=F[F[a+8>>2]+j>>2];c=$[F[F[c>>2]+20>>2]](c,d)|0;e=F[a+20>>2];g=F[a+24>>2]-e>>2;e:{if(c>>>0<g>>>0){break e}h=c+1|0;if(h>>>0>g>>>0){qa(i,h-g|0);e=F[i>>2];break e}if(g>>>0<=h>>>0){break e}F[a+24>>2]=(h<<2)+e;}F[(c<<2)+e>>2]=b;d=d+1|0;if((k|0)!=(d|0)){continue}break}}b=b+1|0;if((f|0)!=(b|0)){continue}break}}e=0;if(!($[F[F[a>>2]+28>>2]](a)|0)){break b}e=$[F[F[a>>2]+32>>2]](a)|0;}return e|0}return 0}function Ye(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;Oc(a,b,c);c=F[a+84>>2];d=F[a+88>>2]-c>>2;a:{if((d|0)>(b|0)){break a}b=b+1|0;if(b>>>0>d>>>0){b:{d=b-d|0;e=F[a+92>>2];c=F[a+88>>2];if(d>>>0<=e-c>>2>>>0){c:{if(!d){break c}b=c;e=d&7;if(e){while(1){F[b>>2]=1;b=b+4|0;f=f+1|0;if((e|0)!=(f|0)){continue}break}}c=(d<<2)+c|0;if((d-1&1073741823)>>>0<7){break c}while(1){F[b+24>>2]=1;F[b+28>>2]=1;F[b+16>>2]=1;F[b+20>>2]=1;F[b+8>>2]=1;F[b+12>>2]=1;F[b>>2]=1;F[b+4>>2]=1;b=b+32|0;if((c|0)!=(b|0)){continue}break}}F[a+88>>2]=c;break b}d:{b=c;c=F[a+84>>2];i=b-c|0;g=i>>2;b=g+d|0;if(b>>>0<1073741824){e=e-c|0;h=e>>>1|0;e=e>>>0>=2147483644?1073741823:b>>>0<h>>>0?h:b;if(e){if(e>>>0>=1073741824){break d}j=ka(e<<2);}g=(g<<2)+j|0;b=g;h=d&7;if(h){while(1){F[b>>2]=1;b=b+4|0;f=f+1|0;if((h|0)!=(f|0)){continue}break}}f=g+(d<<2)|0;if((d-1&1073741823)>>>0>=7){while(1){F[b+24>>2]=1;F[b+28>>2]=1;F[b+16>>2]=1;F[b+20>>2]=1;F[b+8>>2]=1;F[b+12>>2]=1;F[b>>2]=1;F[b+4>>2]=1;b=b+32|0;if((f|0)!=(b|0)){continue}break}}b=pa(j,c,i);F[a+88>>2]=f;F[a+84>>2]=b;F[a+92>>2]=b+(e<<2);if(c){ja(c);}break b}na();v();}oa();v();}return}if(b>>>0>=d>>>0){break a}F[a+88>>2]=c+(b<<2);}}function ab(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=F[a+8>>2];e=F[a+4>>2];if(d-e>>2>>>0>=b>>>0){a:{if(!b){break a}d=e;g=b&7;if(g){while(1){F[d>>2]=F[c>>2];d=d+4|0;f=f+1|0;if((g|0)!=(f|0)){continue}break}}e=(b<<2)+e|0;if((b-1&1073741823)>>>0<7){break a}while(1){F[d>>2]=F[c>>2];F[d+4>>2]=F[c>>2];F[d+8>>2]=F[c>>2];F[d+12>>2]=F[c>>2];F[d+16>>2]=F[c>>2];F[d+20>>2]=F[c>>2];F[d+24>>2]=F[c>>2];F[d+28>>2]=F[c>>2];d=d+32|0;if((e|0)!=(d|0)){continue}break}}F[a+4>>2]=e;return}b:{i=F[a>>2];f=e-i>>2;h=f+b|0;if(h>>>0<1073741824){j=d-i|0;d=j>>>1|0;h=j>>>0>=2147483644?1073741823:d>>>0>h>>>0?d:h;if(h){if(h>>>0>=1073741824){break b}k=ka(h<<2);}f=(f<<2)+k|0;d=f;j=b&7;if(j){while(1){F[d>>2]=F[c>>2];d=d+4|0;g=g+1|0;if((j|0)!=(g|0)){continue}break}}g=(b<<2)+f|0;if((b-1&1073741823)>>>0>=7){while(1){F[d>>2]=F[c>>2];F[d+4>>2]=F[c>>2];F[d+8>>2]=F[c>>2];F[d+12>>2]=F[c>>2];F[d+16>>2]=F[c>>2];F[d+20>>2]=F[c>>2];F[d+24>>2]=F[c>>2];F[d+28>>2]=F[c>>2];d=d+32|0;if((g|0)!=(d|0)){continue}break}}if((e|0)!=(i|0)){while(1){f=f-4|0;e=e-4|0;F[f>>2]=F[e>>2];if((e|0)!=(i|0)){continue}break}}F[a+8>>2]=(h<<2)+k;F[a+4>>2]=g;F[a>>2]=f;if(i){ja(i);}return}na();v();}oa();v();}function Xb(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=F[a+8>>2];e=F[a>>2];if(d-e>>2>>>0>=b>>>0){f=F[a+4>>2];h=f-e>>2;i=b>>>0>h>>>0?h:b;a:{if(!i){break a}d=e;g=i;j=g&7;if(j){while(1){F[d>>2]=F[c>>2];g=g-1|0;d=d+4|0;k=k+1|0;if((k|0)!=(j|0)){continue}break}}if(i>>>0<8){break a}while(1){F[d>>2]=F[c>>2];F[d+4>>2]=F[c>>2];F[d+8>>2]=F[c>>2];F[d+12>>2]=F[c>>2];F[d+16>>2]=F[c>>2];F[d+20>>2]=F[c>>2];F[d+24>>2]=F[c>>2];F[d+28>>2]=F[c>>2];d=d+32|0;g=g-8|0;if(g){continue}break}}if(b>>>0>h>>>0){b=(b-h<<2)+f|0;while(1){F[f>>2]=F[c>>2];f=f+4|0;if((b|0)!=(f|0)){continue}break}F[a+4>>2]=b;return}F[a+4>>2]=e+(b<<2);return}if(e){F[a+4>>2]=e;ja(e);F[a+8>>2]=0;F[a>>2]=0;F[a+4>>2]=0;d=0;}b:{if(b>>>0>=1073741824){break b}e=d>>>1|0;d=d>>>0>=2147483644?1073741823:b>>>0<e>>>0?e:b;if(d>>>0>=1073741824){break b}d=d<<2;e=ka(d);F[a>>2]=e;F[a+8>>2]=d+e;c=F[c>>2];d=e;g=b&7;if(g){while(1){F[d>>2]=c;d=d+4|0;f=f+1|0;if((g|0)!=(f|0)){continue}break}}e=e+(b<<2)|0;if((b-1&1073741823)>>>0>=7){while(1){F[d+28>>2]=c;F[d+24>>2]=c;F[d+20>>2]=c;F[d+16>>2]=c;F[d+12>>2]=c;F[d+8>>2]=c;F[d+4>>2]=c;F[d>>2]=c;d=d+32|0;if((e|0)!=(d|0)){continue}break}}F[a+4>>2]=e;return}na();v();}function Ka(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;f=(c>>>0)/3|0;j=F[(F[F[a+8>>2]+96>>2]+L(f,12)|0)+(c-L(f,3)<<2)>>2];a:{h=F[F[a+12>>2]+4>>2];e=F[h+4>>2];if((e|0)!=F[h+8>>2]){F[e>>2]=j;F[h+4>>2]=e+4;break a}b:{i=F[h>>2];f=e-i|0;g=f>>2;d=g+1|0;if(d>>>0<1073741824){k=g<<2;g=f>>>1|0;g=f>>>0>=2147483644?1073741823:d>>>0<g>>>0?g:d;if(g){if(g>>>0>=1073741824){break b}f=ka(g<<2);}else {f=0;}d=k+f|0;F[d>>2]=j;j=d+4|0;if((e|0)!=(i|0)){while(1){d=d-4|0;e=e-4|0;F[d>>2]=F[e>>2];if((e|0)!=(i|0)){continue}break}}F[h+8>>2]=f+(g<<2);F[h+4>>2]=j;F[h>>2]=d;if(i){ja(i);}break a}na();v();}oa();v();}c:{d:{h=F[a+4>>2];e=F[h+4>>2];e:{if((e|0)!=F[h+8>>2]){F[e>>2]=c;F[h+4>>2]=e+4;break e}i=F[h>>2];f=e-i|0;j=f>>2;d=j+1|0;if(d>>>0>=1073741824){break d}g=f>>>1|0;g=f>>>0>=2147483644?1073741823:d>>>0<g>>>0?g:d;if(g){if(g>>>0>=1073741824){break c}f=ka(g<<2);}else {f=0;}d=f+(j<<2)|0;F[d>>2]=c;c=d+4|0;if((e|0)!=(i|0)){while(1){d=d-4|0;e=e-4|0;F[d>>2]=F[e>>2];if((e|0)!=(i|0)){continue}break}}F[h+8>>2]=f+(g<<2);F[h+4>>2]=c;F[h>>2]=d;if(!i){break e}ja(i);}a=F[a+4>>2];F[F[a+12>>2]+(b<<2)>>2]=F[a+24>>2];F[a+24>>2]=F[a+24>>2]+1;return}na();v();}oa();v();}function pb(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0;h=d-c|0;if((h|0)<=0){return}a:{e=F[a+8>>2];i=F[a+4>>2];if((e-i|0)>=(h|0)){j=i-b|0;if((j|0)>=(h|0)){f=i;g=d;break a}f=i;g=c+j|0;if((g|0)!=(d|0)){e=g;while(1){D[f|0]=G[e|0];f=f+1|0;e=e+1|0;if((e|0)!=(d|0)){continue}break}}F[a+4>>2]=f;if((j|0)>0){break a}return}k=F[a>>2];g=(i-k|0)+h|0;if((g|0)>=0){j=b-k|0;f=e-k|0;e=f<<1;f=f>>>0>=1073741823?2147483647:e>>>0>g>>>0?e:g;if(f){e=ka(f);}else {e=0;}g=j+e|0;if((c|0)!=(d|0)){g=la(g,c,h)+h|0;}d=pa(e,k,j);c=i-b|0;b=pa(g,b,c);F[a+8>>2]=e+f;F[a+4>>2]=b+c;F[a>>2]=d;if(k){ja(k);}return}na();v();}e=f;d=e-h|0;if(i>>>0>d>>>0){while(1){D[e|0]=G[d|0];e=e+1|0;d=d+1|0;if(i>>>0>d>>>0){continue}break}}F[a+4>>2]=e;a=b+h|0;if((a|0)!=(f|0)){a=f-a|0;pa(f-a|0,b,a);}if((c|0)==(g|0)){return}f=(c^-1)+g|0;a=g-c&7;b:{if(!a){e=b;break b}d=0;e=b;while(1){D[e|0]=G[c|0];e=e+1|0;c=c+1|0;d=d+1|0;if((a|0)!=(d|0)){continue}break}}if(f>>>0<7){return}while(1){D[e|0]=G[c|0];D[e+1|0]=G[c+1|0];D[e+2|0]=G[c+2|0];D[e+3|0]=G[c+3|0];D[e+4|0]=G[c+4|0];D[e+5|0]=G[c+5|0];D[e+6|0]=G[c+6|0];D[e+7|0]=G[c+7|0];e=e+8|0;c=c+8|0;if((g|0)!=(c|0)){continue}break}}function la(a,b,c){var d=0,e=0,f=0;if(c>>>0>=512){Y(a|0,b|0,c|0);return a}e=a+c|0;a:{if(!((a^b)&3)){b:{if(!(a&3)){c=a;break b}if(!c){c=a;break b}c=a;while(1){D[c|0]=G[b|0];b=b+1|0;c=c+1|0;if(!(c&3)){break b}if(c>>>0<e>>>0){continue}break}}d=e&-4;c:{if(d>>>0<64){break c}f=d+-64|0;if(f>>>0<c>>>0){break c}while(1){F[c>>2]=F[b>>2];F[c+4>>2]=F[b+4>>2];F[c+8>>2]=F[b+8>>2];F[c+12>>2]=F[b+12>>2];F[c+16>>2]=F[b+16>>2];F[c+20>>2]=F[b+20>>2];F[c+24>>2]=F[b+24>>2];F[c+28>>2]=F[b+28>>2];F[c+32>>2]=F[b+32>>2];F[c+36>>2]=F[b+36>>2];F[c+40>>2]=F[b+40>>2];F[c+44>>2]=F[b+44>>2];F[c+48>>2]=F[b+48>>2];F[c+52>>2]=F[b+52>>2];F[c+56>>2]=F[b+56>>2];F[c+60>>2]=F[b+60>>2];b=b- -64|0;c=c- -64|0;if(f>>>0>=c>>>0){continue}break}}if(c>>>0>=d>>>0){break a}while(1){F[c>>2]=F[b>>2];b=b+4|0;c=c+4|0;if(d>>>0>c>>>0){continue}break}break a}if(e>>>0<4){c=a;break a}d=e-4|0;if(d>>>0<a>>>0){c=a;break a}c=a;while(1){D[c|0]=G[b|0];D[c+1|0]=G[b+1|0];D[c+2|0]=G[b+2|0];D[c+3|0]=G[b+3|0];b=b+4|0;c=c+4|0;if(d>>>0>=c>>>0){continue}break}}if(c>>>0<e>>>0){while(1){D[c|0]=G[b|0];b=b+1|0;c=c+1|0;if((e|0)!=(c|0)){continue}break}}return a}function sd(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;F[a>>2]=8336;d=a+232|0;b=F[d+196>>2];if(b){F[d+200>>2]=b;ja(b);}c=F[d+184>>2];if(c){b=c;e=F[d+188>>2];if((b|0)!=(e|0)){while(1){b=e-12|0;f=F[b>>2];if(f){F[e-8>>2]=f;ja(f);}e=b;if((b|0)!=(c|0)){continue}break}b=F[d+184>>2];}F[d+188>>2]=c;ja(b);}b=F[d+156>>2];if(b){F[d+160>>2]=b;ja(b);}c=F[d+136>>2];F[d+136>>2]=0;if(c){e=c-4|0;b=F[e>>2];if(b){b=c+(b<<4)|0;while(1){b=b-16|0;if((c|0)!=(b|0)){continue}break}}ja(e);}td(a+216|0);b=F[a+196>>2];if(b){F[a+200>>2]=b;ja(b);}b=F[a+184>>2];if(b){F[a+188>>2]=b;ja(b);}b=F[a+172>>2];if(b){F[a+176>>2]=b;ja(b);}b=F[a+160>>2];if(b){F[a+164>>2]=b;ja(b);}b=F[a+144>>2];if(b){while(1){c=F[b>>2];ja(b);b=c;if(b){continue}break}}b=F[a+136>>2];F[a+136>>2]=0;if(b){ja(b);}b=F[a+120>>2];if(b){ja(b);}b=F[a+108>>2];if(b){ja(b);}b=F[a+96>>2];if(b){ja(b);}b=F[a+72>>2];if(b){F[a+76>>2]=b;ja(b);}b=F[a+60>>2];if(b){ja(b);}b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}b=F[a+36>>2];if(b){F[a+40>>2]=b;ja(b);}b=F[a+24>>2];if(b){F[a+28>>2]=b;ja(b);}b=F[a+12>>2];if(b){F[a+16>>2]=b;ja(b);}b=F[a+8>>2];F[a+8>>2]=0;if(b){Za(b);}return a|0}function Fa(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;d=F[a+8>>2];e=F[a+4>>2];if(d-e>>2>>>0>=b>>>0){a:{if(!b){break a}d=e;f=b&7;if(f){while(1){F[d>>2]=F[c>>2];d=d+4|0;h=h+1|0;if((f|0)!=(h|0)){continue}break}}e=(b<<2)+e|0;if((b-1&1073741823)>>>0<7){break a}while(1){F[d>>2]=F[c>>2];F[d+4>>2]=F[c>>2];F[d+8>>2]=F[c>>2];F[d+12>>2]=F[c>>2];F[d+16>>2]=F[c>>2];F[d+20>>2]=F[c>>2];F[d+24>>2]=F[c>>2];F[d+28>>2]=F[c>>2];d=d+32|0;if((e|0)!=(d|0)){continue}break}}F[a+4>>2]=e;return}b:{i=F[a>>2];j=e-i|0;f=j>>2;g=f+b|0;if(g>>>0<1073741824){d=d-i|0;e=d>>>1|0;g=d>>>0>=2147483644?1073741823:e>>>0>g>>>0?e:g;if(g){if(g>>>0>=1073741824){break b}k=ka(g<<2);}f=(f<<2)+k|0;d=f;e=b&7;if(e){while(1){F[d>>2]=F[c>>2];d=d+4|0;h=h+1|0;if((e|0)!=(h|0)){continue}break}}e=f+(b<<2)|0;if((b-1&1073741823)>>>0>=7){while(1){F[d>>2]=F[c>>2];F[d+4>>2]=F[c>>2];F[d+8>>2]=F[c>>2];F[d+12>>2]=F[c>>2];F[d+16>>2]=F[c>>2];F[d+20>>2]=F[c>>2];F[d+24>>2]=F[c>>2];F[d+28>>2]=F[c>>2];d=d+32|0;if((e|0)!=(d|0)){continue}break}}b=pa(k,i,j);F[a+4>>2]=e;F[a>>2]=b;F[a+8>>2]=b+(g<<2);if(i){ja(i);}return}na();v();}oa();v();}function Sb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;if(G[a+11|0]>>>7|0){d=F[a+4>>2];}else {d=G[a+11|0]&127;}if(d>>>0<b>>>0){h=Z-16|0;Z=h;b=b-d|0;if(b){g=G[a+11|0]>>>7|0?(F[a+8>>2]&2147483647)-1|0:10;if(G[a+11|0]>>>7|0){d=F[a+4>>2];}else {d=G[a+11|0]&127;}i=d+b|0;if(g-d>>>0<b>>>0){a:{e=Z-16|0;Z=e;c=i-g|0;if(c>>>0<=2147483631-g>>>0){if(G[a+11|0]>>>7|0){f=F[a>>2];}else {f=a;}if(g>>>0<1073741799){F[e+12>>2]=g<<1;F[e>>2]=c+g;c=Z-16|0;Z=c;Z=c+16|0;c=e+12|0;c=F[(I[e>>2]<I[c>>2]?c:e)>>2];if(c>>>0>=11){j=c+16&-16;c=j-1|0;c=(c|0)==11?j:c;}else {c=10;}c=c+1|0;}else {c=2147483631;}sb(e,c);c=F[e>>2];if(d){db(c,f,d);}if((g|0)!=10){ja(f);}F[a>>2]=c;F[a+8>>2]=F[a+8>>2]&-2147483648|F[e+4>>2]&2147483647;F[a+8>>2]=F[a+8>>2]|-2147483648;Z=e+16|0;break a}za();v();}}f=d;if(G[a+11|0]>>>7|0){d=F[a>>2];}else {d=a;}f=f+d|0;e=Z-16|0;Z=e;D[e+15|0]=0;while(1){if(b){D[f|0]=G[e+15|0];b=b-1|0;f=f+1|0;continue}break}Z=e+16|0;Ic(a,i);D[h+15|0]=0;D[d+i|0]=G[h+15|0];}Z=h+16|0;return}if(G[a+11|0]>>>7|0){d=F[a>>2];}else {d=a;}f=Z-16|0;Z=f;Ic(a,b);D[f+15|0]=0;D[b+d|0]=G[f+15|0];Z=f+16|0;}function Zc(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;g=Z-16|0;Z=g;a:{b:{if(b){F[a+88>>2]=0;F[a+92>>2]=0;d=F[a+84>>2];F[a+84>>2]=0;if(d){ja(d);}F[a+76>>2]=0;F[a+80>>2]=0;d=F[a+72>>2];F[a+72>>2]=0;if(d){ja(d);}d=F[b>>2];c=F[b+4>>2];D[g+15|0]=0;Ea(a,c-d>>2,g+15|0);d=F[b+28>>2];c=F[b+24>>2];D[g+14|0]=0;Ea(a+12|0,d-c>>2,g+14|0);Xb(a+28|0,F[b+4>>2]-F[b>>2]>>2,10284);c=F[b+28>>2]-F[b+24>>2]|0;f=c>>2;e=F[a+52>>2];c:{if(f>>>0<=F[a+60>>2]-e>>2>>>0){break c}if((c|0)<0){break b}d=F[a+56>>2];c=ka(c);f=c+(f<<2)|0;h=c+(d-e&-4)|0;c=h;if((d|0)!=(e|0)){while(1){c=c-4|0;d=d-4|0;F[c>>2]=F[d>>2];if((d|0)!=(e|0)){continue}break}}F[a+60>>2]=f;F[a+56>>2]=h;F[a+52>>2]=c;if(!e){break c}ja(e);}c=F[b+28>>2]-F[b+24>>2]|0;f=c>>2;e=F[a+40>>2];d:{if(f>>>0<=F[a+48>>2]-e>>2>>>0){break d}if((c|0)<0){break a}d=F[a+44>>2];c=ka(c);f=c+(f<<2)|0;h=c+(d-e&-4)|0;c=h;if((d|0)!=(e|0)){while(1){c=c-4|0;d=d-4|0;F[c>>2]=F[d>>2];if((d|0)!=(e|0)){continue}break}}F[a+48>>2]=f;F[a+44>>2]=h;F[a+40>>2]=c;if(!e){break d}ja(e);}D[a+24|0]=1;F[a+64>>2]=b;}Z=g+16|0;return}na();v();}na();v();}function nb(a,b){var c=0,d=0,e=0;c=(a|0)==(b|0);D[b+12|0]=c;a:{if(c){break a}while(1){d=F[b+8>>2];if(G[d+12|0]){break a}b:{c=F[d+8>>2];e=F[c>>2];if((e|0)==(d|0)){e=F[c+4>>2];if(!(!e|G[e+12|0])){break b}c:{if(F[d>>2]==(b|0)){b=d;break c}b=F[d+4>>2];a=F[b>>2];F[d+4>>2]=a;if(a){F[a+8>>2]=d;c=F[d+8>>2];}F[b+8>>2]=c;a=F[d+8>>2];F[((F[a>>2]!=(d|0))<<2)+a>>2]=b;F[b>>2]=d;F[d+8>>2]=b;c=F[b+8>>2];d=F[c>>2];}D[b+12|0]=1;D[c+12|0]=0;a=F[d+4>>2];F[c>>2]=a;if(a){F[a+8>>2]=c;}F[d+8>>2]=F[c+8>>2];a=F[c+8>>2];F[((F[a>>2]!=(c|0))<<2)+a>>2]=d;F[d+4>>2]=c;F[c+8>>2]=d;return}if(!(G[e+12|0]|!e)){break b}d:{if(F[d>>2]!=(b|0)){b=d;break d}a=F[b+4>>2];F[d>>2]=a;if(a){F[a+8>>2]=d;c=F[d+8>>2];}F[b+8>>2]=c;a=F[d+8>>2];F[((F[a>>2]!=(d|0))<<2)+a>>2]=b;F[b+4>>2]=d;F[d+8>>2]=b;c=F[b+8>>2];}D[b+12|0]=1;D[c+12|0]=0;a=F[c+4>>2];b=F[a>>2];F[c+4>>2]=b;if(b){F[b+8>>2]=c;}F[a+8>>2]=F[c+8>>2];b=F[c+8>>2];F[((F[b>>2]!=(c|0))<<2)+b>>2]=a;F[a>>2]=c;F[c+8>>2]=a;break a}D[d+12|0]=1;D[c+12|0]=(a|0)==(c|0);D[e+12|0]=1;b=c;if((c|0)!=(a|0)){continue}break}}}function mi(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;a:{b:{c:{d:{e:{f:{g:{h:{i:{j:{k:{if(b){if(!c){break k}if(!d){break j}e=O(d)-O(b)|0;if(e>>>0<=31){break i}break c}if((d|0)==1|d>>>0>1){break c}_=0;a=(a>>>0)/(c>>>0)|0;break a}if(!a){break h}if(!d|d-1&d){break g}a=b>>>ji(d)|0;_=0;break a}if(!(c-1&c)){break f}h=(O(c)+33|0)-O(b)|0;g=0-h|0;break d}h=e+1|0;g=63-e|0;break d}_=0;a=(b>>>0)/(d>>>0)|0;break a}e=O(d)-O(b)|0;if(e>>>0<31){break e}break c}if((c|0)==1){break b}d=ji(c);c=d&31;if((d&63)>>>0>=32){a=b>>>c|0;}else {e=b>>>c|0;a=((1<<c)-1&b)<<32-c|a>>>c;}_=e;break a}h=e+1|0;g=63-e|0;}e=h&63;f=e&31;if(e>>>0>=32){e=0;i=b>>>f|0;}else {e=b>>>f|0;i=((1<<f)-1&b)<<32-f|a>>>f;}g=g&63;f=g&31;if(g>>>0>=32){b=a<<f;a=0;}else {b=(1<<f)-1&a>>>32-f|b<<f;a=a<<f;}if(h){f=d-1|0;g=c-1|0;m=(g|0)!=-1?f+1|0:f;while(1){j=e<<1|i>>>31;e=i<<1|b>>>31;f=m-(j+(e>>>0>g>>>0)|0)>>31;k=c&f;i=e-k|0;e=j-((d&f)+(e>>>0<k>>>0)|0)|0;b=b<<1|a>>>31;a=l|a<<1;l=f&1;h=h-1|0;if(h){continue}break}}_=b<<1|a>>>31;a=l|a<<1;break a}a=0;b=0;}_=b;}return a}function yh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;c=F[b+88>>2];if(!(!c|F[c>>2]!=1)){e=F[c+8>>2];F[a+4>>2]=G[e|0]|G[e+1|0]<<8|(G[e+2|0]<<16|G[e+3|0]<<24);f=a+8|0;d=G[b+24|0];h=F[a+8>>2];g=F[a+12>>2]-h>>2;a:{if(d>>>0>g>>>0){qa(f,d-g|0);d=G[b+24|0];e=F[c+8>>2];break a}if(d>>>0>=g>>>0){break a}F[a+12>>2]=h+(d<<2);}b:{if(!d){b=4;break b}h=d&3;f=F[f>>2];c:{if(d-1>>>0<3){b=4;d=0;break c}k=d&252;d=0;b=4;while(1){g=d<<2;c=b+e|0;F[g+f>>2]=G[c|0]|G[c+1|0]<<8|(G[c+2|0]<<16|G[c+3|0]<<24);F[f+(g|4)>>2]=G[c+4|0]|G[c+5|0]<<8|(G[c+6|0]<<16|G[c+7|0]<<24);F[f+(g|8)>>2]=G[c+8|0]|G[c+9|0]<<8|(G[c+10|0]<<16|G[c+11|0]<<24);F[f+(g|12)>>2]=G[c+12|0]|G[c+13|0]<<8|(G[c+14|0]<<16|G[c+15|0]<<24);d=d+4|0;b=b+16|0;i=i+4|0;if((k|0)!=(i|0)){continue}break}}if(!h){break b}while(1){c=b+e|0;F[f+(d<<2)>>2]=G[c|0]|G[c+1|0]<<8|(G[c+2|0]<<16|G[c+3|0]<<24);d=d+1|0;b=b+4|0;j=j+1|0;if((h|0)!=(j|0)){continue}break}}d=a;a=b+e|0;F[d+20>>2]=G[a|0]|G[a+1|0]<<8|(G[a+2|0]<<16|G[a+3|0]<<24);d=1;}return d|0}function Yg(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0,h=0;g=Z-16|0;Z=g;e=F[a+4>>2];d=F[e>>2];a:{b=F[a+12>>2];c=F[b+28>>2]-F[b+24>>2]|0;f=c>>2;b:{if(f>>>0<=F[e+8>>2]-d>>2>>>0){break b}if((c|0)<0){break a}b=F[e+4>>2];c=ka(c);f=c+(f<<2)|0;h=c+(b-d&-4)|0;c=h;if((b|0)!=(d|0)){while(1){c=c-4|0;b=b-4|0;F[c>>2]=F[b>>2];if((b|0)!=(d|0)){continue}break}}F[e+8>>2]=f;F[e+4>>2]=h;F[e>>2]=c;if(!d){break b}ja(d);}b=F[a+12>>2];c=F[b+28>>2];b=F[b+24>>2];F[g+12>>2]=0;b=c-b>>2;d=a+96|0;e=F[d>>2];c=F[a+100>>2]-e>>2;c:{if(b>>>0>c>>>0){Fa(d,b-c|0,g+12|0);break c}if(b>>>0>=c>>>0){break c}F[a+100>>2]=e+(b<<2);}e=a+8|0;b=F[a+116>>2];d:{if(b){d=F[b>>2];if((d|0)==F[b+4>>2]){c=1;break d}b=0;while(1){c=rd(e,F[(b<<2)+d>>2]);if(!c){break d}f=F[a+116>>2];d=F[f>>2];b=b+1|0;if(b>>>0<F[f+4>>2]-d>>2>>>0){continue}break}break d}c=1;a=F[a+12>>2];a=F[a+4>>2]-F[a>>2]|0;if(a>>>0<12){break d}a=(a>>2>>>0)/3|0;b=0;while(1){c=rd(e,L(b,3));if(!c){break d}b=b+1|0;if((a|0)!=(b|0)){continue}break}}Z=g+16|0;return c|0}na();v();}function md(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0;a:{b:{c:{if(!b){if((d|0)<0){break a}f=F[a+4>>2];b=F[a>>2];d=f-b|0;if(c>>>0>d>>>0){g=c-d|0;e=F[a+8>>2];if(g>>>0<=e-f>>>0){i=a,j=ma(f,0,g)+g|0,F[i+4>>2]=j;break c}if((c|0)<0){break b}f=e-b|0;e=f<<1;f=f>>>0>=1073741823?2147483647:c>>>0<e>>>0?e:c;e=ka(f);ma(e+d|0,0,g);d=pa(e,b,d);F[a+8>>2]=d+f;F[a+4>>2]=c+d;F[a>>2]=d;if(!b){break c}ja(b);break c}if(c>>>0>=d>>>0){break c}F[a+4>>2]=b+c;break c}if((d|0)<0){break a}e=F[a+4>>2];f=F[a>>2];g=e-f|0;d:{if((d|0)<=0&c>>>0<=g>>>0|(d|0)<0){break d}if(c>>>0>g>>>0){d=c-g|0;h=F[a+8>>2];if(d>>>0<=h-e>>>0){i=a,j=ma(e,0,d)+d|0,F[i+4>>2]=j;break d}if((c|0)<0){break b}e=h-f|0;h=e<<1;e=e>>>0>=1073741823?2147483647:c>>>0<h>>>0?h:c;h=ka(e);ma(h+g|0,0,d);d=pa(h,f,g);F[a+8>>2]=d+e;F[a+4>>2]=c+d;F[a>>2]=d;if(!f){break d}ja(f);break d}if(c>>>0>=g>>>0){break d}F[a+4>>2]=c+f;}if(!c){break c}pa(F[a>>2],b,c);}b=F[a+28>>2];c=F[a+24>>2]+1|0;b=c?b:b+1|0;F[a+24>>2]=c;F[a+28>>2]=b;g=1;break a}na();v();}return g}function Lg(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;k=F[a+12>>2];c=F[a+68>>2];d=F[c+80>>2];D[b+84|0]=0;n=b+68|0;i=F[b+68>>2];e=F[b+72>>2]-i>>2;a:{if(e>>>0<d>>>0){ab(n,d-e|0,9124);c=F[a+68>>2];d=F[c+80>>2];break a}if(d>>>0>=e>>>0){break a}F[b+72>>2]=i+(d<<2);}b=F[c+100>>2];e=F[c+96>>2];i=(b-e|0)/12|0;m=1;b:{if((b|0)==(e|0)){break b}k=F[k+28>>2];f=F[k>>2];if((f|0)==-1){return 0}o=i>>>0<=1?1:i;c=e;b=0;m=0;while(1){g=F[c>>2];if(g>>>0>=d>>>0){break b}j=F[F[a+72>>2]+12>>2];h=F[j+(f<<2)>>2];if(h>>>0>=d>>>0){break b}f=F[n>>2];F[f+(g<<2)>>2]=h;g=k+(l<<2)|0;h=F[g+4>>2];if((h|0)==-1){break b}l=F[c+4>>2];if(l>>>0>=d>>>0){break b}h=F[(h<<2)+j>>2];if(h>>>0>=d>>>0){break b}F[f+(l<<2)>>2]=h;g=F[g+8>>2];if((g|0)==-1){break b}c=F[c+8>>2];if(c>>>0>=d>>>0){break b}j=F[(g<<2)+j>>2];if(j>>>0>=d>>>0){break b}F[f+(c<<2)>>2]=j;b=b+1|0;m=i>>>0<=b>>>0;if((b|0)==(o|0)){break b}c=e+L(b,12)|0;l=L(b,3);f=F[k+(l<<2)>>2];if((f|0)!=-1){continue}break}}return m|0}function ag(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;h=F[d+80>>2];e=Z-48|0;Z=e;a=F[a+4>>2];m=a-2|0;a:{if(m>>>0>28){break a}j=F[F[d>>2]>>2]+F[d+48>>2]|0;F[e+16>>2]=a;a=-1<<a;F[e+20>>2]=a^-1;a=-2-a|0;F[e+24>>2]=a;F[e+32>>2]=(a|0)/2;J[e+28>>2]=M(2)/M(a|0);f=F[c>>2];if((f|0)!=F[c+4>>2]){a=0;d=0;while(1){g=F[(d<<2)+f>>2];h=e+36|0;k=F[F[b>>2]>>2];l=F[b+48>>2];f=F[b+40>>2];i=F[b+44>>2];if(!G[b+84|0]){g=F[F[b+68>>2]+(g<<2)>>2];}g=ki(f,i,g,0);i=g;g=g+l|0;la(h,g+k|0,f);Kc(e+16|0,h,e+12|0,e+8|0);f=a<<2;F[f+j>>2]=F[e+12>>2];F[(f|4)+j>>2]=F[e+8>>2];a=a+2|0;d=d+1|0;f=F[c>>2];if(d>>>0<F[c+4>>2]-f>>2>>>0){continue}break}break a}if(!h){break a}d=0;a=0;while(1){k=e+36|0;l=F[F[b>>2]>>2];i=F[b+48>>2];c=F[b+40>>2];f=ki(c,F[b+44>>2],G[b+84|0]?a:F[F[b+68>>2]+(a<<2)>>2],0);g=f;f=f+i|0;la(k,f+l|0,c);Kc(e+16|0,k,e+12|0,e+8|0);c=d<<2;F[c+j>>2]=F[e+12>>2];F[(c|4)+j>>2]=F[e+8>>2];d=d+2|0;a=a+1|0;if((h|0)!=(a|0)){continue}break}}Z=e+48|0;return m>>>0<29|0}function Zg(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;c=F[a+12>>2];d=F[a+108>>2];e=F[d+80>>2];D[b+84|0]=0;m=b+68|0;h=F[b+68>>2];f=F[b+72>>2]-h>>2;a:{if(f>>>0<e>>>0){ab(m,e-f|0,9124);d=F[a+108>>2];e=F[d+80>>2];break a}if(e>>>0>=f>>>0){break a}F[b+72>>2]=h+(e<<2);}b=F[d+100>>2];f=F[d+96>>2];h=(b-f|0)/12|0;k=1;b:{if((b|0)==(f|0)){break b}n=h>>>0<=1?1:h;o=F[c>>2];c=0;d=f;b=0;k=0;while(1){c=(c<<2)+o|0;i=F[c>>2];if((i|0)==-1){break b}g=F[d>>2];if(g>>>0>=e>>>0){break b}l=F[F[a+112>>2]+12>>2];j=F[l+(i<<2)>>2];if(j>>>0>=e>>>0){break b}i=F[m>>2];F[i+(g<<2)>>2]=j;g=F[c+4>>2];if((g|0)==-1){break b}j=F[d+4>>2];if(j>>>0>=e>>>0){break b}g=F[(g<<2)+l>>2];if(g>>>0>=e>>>0){break b}F[i+(j<<2)>>2]=g;c=F[c+8>>2];if((c|0)==-1){break b}d=F[d+8>>2];if(d>>>0>=e>>>0){break b}c=F[(c<<2)+l>>2];if(c>>>0>=e>>>0){break b}F[i+(d<<2)>>2]=c;b=b+1|0;k=h>>>0<=b>>>0;if((b|0)==(n|0)){break b}c=L(b,3);d=f+L(b,12)|0;if((b|0)!=1431655765){continue}break}}return k|0}function xd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=M(0),j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;k=Z-16|0;Z=k;if(F[c+28>>2]==9){d=F[a+4>>2];h=G[c+24|0];e=h<<2;f=ka(e);l=k+8|0;F[l>>2]=1065353216;i=J[a+20>>2];d=-1<<d^-1;if((d|0)>0){J[l>>2]=i/M(d|0);}o=(d|0)>0;a:{if(!o){break a}j=F[c+80>>2];if(!j){break a}if(h){p=F[F[b>>2]>>2]+F[b+48>>2]|0;t=h&254;u=h&1;b=0;while(1){m=F[a+8>>2];i=J[l>>2];d=0;n=0;if((h|0)!=1){while(1){g=d<<2;q=(b<<2)+p|0;J[g+f>>2]=M(i*M(F[q>>2]))+J[g+m>>2];g=g|4;J[g+f>>2]=M(i*M(F[q+4>>2]))+J[g+m>>2];d=d+2|0;b=b+2|0;n=n+2|0;if((t|0)!=(n|0)){continue}break}}if(u){d=d<<2;J[d+f>>2]=M(i*M(F[(b<<2)+p>>2]))+J[d+m>>2];b=b+1|0;}la(F[F[c+64>>2]>>2]+r|0,f,e);r=e+r|0;s=s+1|0;if((s|0)!=(j|0)){continue}break}break a}b=0;if((j|0)!=1){a=j&-2;d=0;while(1){la(F[F[c+64>>2]>>2]+b|0,f,e);b=b+e|0;la(b+F[F[c+64>>2]>>2]|0,f,e);b=b+e|0;d=d+2|0;if((a|0)!=(d|0)){continue}break}}if(!(j&1)){break a}la(F[F[c+64>>2]>>2]+b|0,f,e);}ja(f);}Z=k+16|0;return o|0}function Rg(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;c=F[a+12>>2];d=F[a+68>>2];e=F[d+80>>2];D[b+84|0]=0;m=b+68|0;h=F[b+68>>2];f=F[b+72>>2]-h>>2;a:{if(f>>>0<e>>>0){ab(m,e-f|0,9124);d=F[a+68>>2];e=F[d+80>>2];break a}if(e>>>0>=f>>>0){break a}F[b+72>>2]=h+(e<<2);}b=F[d+100>>2];f=F[d+96>>2];h=(b-f|0)/12|0;k=1;b:{if((b|0)==(f|0)){break b}n=h>>>0<=1?1:h;o=F[c>>2];c=0;d=f;b=0;k=0;while(1){c=(c<<2)+o|0;i=F[c>>2];if((i|0)==-1){break b}g=F[d>>2];if(g>>>0>=e>>>0){break b}l=F[F[a+72>>2]+12>>2];j=F[l+(i<<2)>>2];if(j>>>0>=e>>>0){break b}i=F[m>>2];F[i+(g<<2)>>2]=j;g=F[c+4>>2];if((g|0)==-1){break b}j=F[d+4>>2];if(j>>>0>=e>>>0){break b}g=F[(g<<2)+l>>2];if(g>>>0>=e>>>0){break b}F[i+(j<<2)>>2]=g;c=F[c+8>>2];if((c|0)==-1){break b}d=F[d+8>>2];if(d>>>0>=e>>>0){break b}c=F[(c<<2)+l>>2];if(c>>>0>=e>>>0){break b}F[i+(d<<2)>>2]=c;b=b+1|0;k=h>>>0<=b>>>0;if((b|0)==(n|0)){break b}c=L(b,3);d=f+L(b,12)|0;if((b|0)!=1431655765){continue}break}}return k|0}function Na(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;d=Z-16|0;Z=d;a:{f=F[a+4>>2];b:{if(f>>>0<b>>>0){e=b-f|0;c=F[a+8>>2];g=c<<5;c:{if(!(e>>>0>g>>>0|f>>>0>g-e>>>0)){F[a+4>>2]=b;h=f&31;b=F[a>>2]+(f>>>3&536870908)|0;break c}F[d+8>>2]=0;F[d>>2]=0;F[d+4>>2]=0;if((b|0)<0){break a}if(g>>>0<=1073741822){c=c<<6;b=b+31&-32;b=b>>>0<c>>>0?c:b;}else {b=2147483647;}$a(d,b);f=F[a+4>>2];F[d+4>>2]=f+e;i=F[a>>2];b=F[d>>2];d:{if((f|0)<=0){break d}c=f>>>5|0;if(f>>>0>=32){pa(b,i,c<<2);}g=c<<2;b=g+b|0;h=f&31;if(h){c=-1>>>32-h|0;F[b>>2]=F[b>>2]&(c^-1)|F[i+g>>2]&c;}i=F[a>>2];}F[a>>2]=F[d>>2];F[d>>2]=i;c=F[a+4>>2];F[a+4>>2]=F[d+4>>2];F[d+4>>2]=c;c=F[a+8>>2];F[a+8>>2]=F[d+8>>2];F[d+8>>2]=c;if(!i){break c}ja(i);}if(!e){break b}if(h){c=32-h|0;a=c>>>0<e>>>0?c:e;F[b>>2]=F[b>>2]&(-1<<h&-1>>>c-a^-1);e=e-a|0;b=b+4|0;}a=e>>>5|0;if(e>>>0>=32){ma(b,0,a<<2);}if((e&-32)==(e|0)){break b}a=(a<<2)+b|0;F[a>>2]=F[a>>2]&(-1>>>32-(e&31)^-1);break b}F[a+4>>2]=b;}Z=d+16|0;return}na();v();}function Aa(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0;i=Z-16|0;Z=i;f=F[b+20>>2];h=F[b+12>>2];c=F[b+16>>2];a:{if((f|0)>=(h|0)&c>>>0>=I[b+8>>2]|(f|0)>(h|0)){break a}D[a+12|0]=G[c+F[b>>2]|0];c=F[b+20>>2];f=F[b+16>>2]+1|0;c=f?c:c+1|0;F[b+16>>2]=f;F[b+20>>2]=c;if(!Qd(1,i+12|0,b)){break a}h=F[b+8>>2];f=F[b+16>>2];g=h-f|0;c=F[i+12>>2];d=f>>>0>h>>>0;h=F[b+20>>2];e=F[b+12>>2]-(d+h|0)|0;if(g>>>0<c>>>0&(e|0)<=0|(e|0)<0|(c|0)<=0){break a}g=f+F[b>>2]|0;F[a>>2]=g;b:{c:{e=c-1|0;j=e+g|0;d=G[j|0];d:{if(d>>>0<=63){F[a+4>>2]=e;d=G[j|0]&63;break d}e:{switch((d>>>6|0)-1|0){case 1:break c;case 0:break e;default:break a}}if(c>>>0<2){break a}e=c-2|0;F[a+4>>2]=e;g=g+e|0;d=G[g+1|0]<<8&16128|G[g|0];}F[a+8>>2]=d+4096;break b}if(c>>>0<3){break a}e=c-3|0;F[a+4>>2]=e;d=a;a=g+e|0;a=G[a+1|0]<<8|G[a+2|0]<<16&4128768|G[a|0];F[d+8>>2]=a+4096;if(a>>>0>1044479){break a}}a=h;d=c;c=c+f|0;a=d>>>0>c>>>0?a+1|0:a;F[b+16>>2]=c;F[b+20>>2]=a;k=1;}Z=i+16|0;return k}function qd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;e=F[a+12>>2];i=F[a+8>>2];d=e-i>>2;b=G[b+24|0];a:{if(d>>>0<b>>>0){qa(a+8|0,b-d|0);i=F[a+8>>2];e=F[a+12>>2];break a}if(b>>>0>=d>>>0){break a}e=(b<<2)+i|0;F[a+12>>2]=e;}b=0;f=F[c+8>>2];h=F[c+12>>2];j=F[c+20>>2];e=e-i|0;d=F[c+16>>2];g=e+d|0;j=e>>>0>g>>>0?j+1|0:j;b:{if(f>>>0<g>>>0&(h|0)<=(j|0)|(h|0)<(j|0)){break b}la(i,d+F[c>>2]|0,e);d=F[c+20>>2];g=e;e=e+F[c+16>>2]|0;d=g>>>0>e>>>0?d+1|0:d;F[c+16>>2]=e;F[c+20>>2]=d;f=F[c+8>>2];h=F[c+12>>2];g=e+4|0;d=g>>>0<4?d+1|0:d;if(f>>>0<g>>>0&(d|0)>=(h|0)|(d|0)>(h|0)){break b}d=e+F[c>>2]|0;F[a+20>>2]=G[d|0]|G[d+1|0]<<8|(G[d+2|0]<<16|G[d+3|0]<<24);d=F[c+20>>2];g=d;f=d;e=F[c+16>>2];d=e+4|0;f=d>>>0<4?f+1|0:f;F[c+16>>2]=d;F[c+20>>2]=f;h=F[c+12>>2];if((f|0)>=(h|0)&d>>>0>=I[c+8>>2]|(f|0)>(h|0)){break b}f=G[d+F[c>>2]|0];d=g;e=e+5|0;d=e>>>0<5?d+1|0:d;F[c+16>>2]=e;F[c+20>>2]=d;if(f-1>>>0>29){break b}F[a+4>>2]=f;b=1;}return b|0}function Kc(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;j=+J[b>>2];k=+J[b+4>>2];l=+J[b+8>>2];g=N(j)+N(k)+N(l);a:{if(!(g>1e-6)){j=1;k=0;e=0;break a}g=1/g;k=g*k;j=g*j;e=g*l<0;}h=F[a+16>>2];l=+(h|0);g=R(j*l+.5);b:{if(N(g)<2147483648){m=~~g;break b}m=-2147483648;}f=m>>31;i=(f^m)-f|0;g=R(k*l+.5);c:{if(N(g)<2147483648){f=~~g;break c}f=-2147483648;}b=f>>31;b=h-(i+((f^b)-b|0)|0)|0;i=(b|0)>0?b:0;e=e?0-i|0:i;f=f+(b>>31&((f|0)>0?b:0-b|0))|0;d:{if((m|0)>=0){b=e+h|0;a=F[a+8>>2];e=h+f|0;break d}b=f>>31;b=(b^f)-b|0;a=F[a+8>>2];b=(e|0)<0?b:a-b|0;e=(f|0)<0?i:a-i|0;}e:{if(!(b|e)){b=a;break e}if(!((a|0)!=(b|0)|e)){b=a;break e}if(!((a|0)!=(e|0)|b)){b=a;break e}if(!((b|0)<=(h|0)|e)){b=(h<<1)-b|0;a=0;break e}if(!((a|0)!=(e|0)|(b|0)>=(h|0))){b=(h<<1)-b|0;break e}if(!((a|0)!=(b|0)|(e|0)>=(h|0))){b=a;a=(h<<1)-e|0;break e}if(b){a=e;break e}b=0;if((e|0)<=(h|0)){a=e;break e}a=(h<<1)-e|0;}F[c>>2]=a;F[d>>2]=b;}function ye(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0;a:{if(!$c(a,b)){break a}h=a+36|0;g=$[F[F[a>>2]+24>>2]](a)|0;e=F[a+40>>2];d=F[a+36>>2];c=e-d>>2;b:{if(g>>>0>c>>>0){Pb(h,g-c|0);break b}if(c>>>0<=g>>>0){break b}d=d+(g<<2)|0;if((d|0)!=(e|0)){while(1){e=e-4|0;c=F[e>>2];F[e>>2]=0;if(c){$[F[F[c>>2]+4>>2]](c);}if((d|0)!=(e|0)){continue}break}}F[a+40>>2]=d;}c=1;if((g|0)<=0){break a}e=0;while(1){c:{c=F[b+20>>2];f=F[b+12>>2];d=F[b+16>>2];if((c|0)>=(f|0)&d>>>0>=I[b+8>>2]|(c|0)>(f|0)){break c}f=G[F[b>>2]+d|0];d=d+1|0;c=d?c:c+1|0;F[b+16>>2]=d;F[b+20>>2]=c;d=$[F[F[a>>2]+48>>2]](a,f)|0;f=e<<2;i=f+F[a+36>>2]|0;c=F[i>>2];F[i>>2]=d;if(c){$[F[F[c>>2]+4>>2]](c);}c=F[F[h>>2]+f>>2];if(!c){break c}if(!(k=c,l=$[F[F[a>>2]+28>>2]](a)|0,m=$[F[F[a>>2]+20>>2]](a,e)|0,j=F[F[c>>2]+8>>2],$[j](k|0,l|0,m|0)|0)){break c}c=1;e=e+1|0;if((g|0)!=(e|0)){continue}break a}break}c=0;}return c|0}function Xc(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;g=F[a>>2];c=g+(b>>>3&536870908)|0;F[c>>2]=F[c>>2]|1<<b;f=F[a+64>>2];e=(b|0)==-1;d=-1;a:{if(e){break a}c=b+1|0;c=(c>>>0)%3|0?c:b-2|0;d=-1;if((c|0)==-1){break a}d=F[F[f>>2]+(c<<2)>>2];}c=F[a+12>>2];h=(d>>>3&536870908)+c|0;F[h>>2]=F[h>>2]|1<<d;b:{c:{if(!e){d:{e:{if((b>>>0)%3|0){e=b-1|0;break e}e=b+2|0;d=-1;if((e|0)==-1){break d}}d=F[F[f>>2]+(e<<2)>>2];}e=(d>>>3&536870908)+c|0;F[e>>2]=F[e>>2]|1<<d;d=-1;b=F[F[f+12>>2]+(b<<2)>>2];if((b|0)==-1){break b}D[a+24|0]=0;a=(b>>>3&536870908)+g|0;F[a>>2]=F[a>>2]|1<<b;a=b+1|0;a=(a>>>0)%3|0?a:b-2|0;if((a|0)!=-1){d=F[F[f>>2]+(a<<2)>>2];}a=c+(d>>>3&536870908)|0;F[a>>2]=F[a>>2]|1<<d;f:{g:{if((b>>>0)%3|0){b=b-1|0;break g}b=b+2|0;a=-1;if((b|0)==-1){break f}}a=F[F[f>>2]+(b<<2)>>2];}b=1<<a;a=c+(a>>>3&536870908)|0;c=F[a>>2];break c}a=c+536870908|0;b=F[c+536870908>>2];c=-2147483648;}F[a>>2]=b|c;}}function zc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=M(0),f=M(0),g=M(0),h=M(0),i=M(0),j=0,k=M(0),l=M(0),m=M(0),n=M(0),o=0;a:{if(F[c+28>>2]!=9|G[c+24|0]!=3){break a}a=F[a+4>>2];if(a-2>>>0>28){break a}o=1;j=F[c+80>>2];if(!j){break a}k=M(M(2)/M((1<<a)-2|0));c=F[F[c>>2]>>2]+F[c+48>>2]|0;a=F[F[b>>2]>>2]+F[b+48>>2]|0;b=0;while(1){g=M(0);l=M(0);m=M(0);e=M(M(M(F[a>>2])*k)+M(-1));f=M(M(M(F[a+4>>2])*k)+M(-1));i=M(M(M(1)-M(N(e)))-M(N(f)));h=M(Q(M(-i),M(0)));n=M(-h);f=M(f+(f<M(0)?h:n));e=M(e+(e<M(0)?h:n));h=M(M(f*f)+M(M(i*i)+M(e*e)));if(!(+h<1e-6)){g=M(M(1)/M(U(h)));m=M(f*g);l=M(e*g);g=M(i*g);}a=a+8|0;d=(w(m),y(2));D[c+8|0]=d;D[c+9|0]=d>>>8;D[c+10|0]=d>>>16;D[c+11|0]=d>>>24;d=(w(l),y(2));D[c+4|0]=d;D[c+5|0]=d>>>8;D[c+6|0]=d>>>16;D[c+7|0]=d>>>24;d=(w(g),y(2));D[c|0]=d;D[c+1|0]=d>>>8;D[c+2|0]=d>>>16;D[c+3|0]=d>>>24;c=c+12|0;b=b+1|0;if((j|0)!=(b|0)){continue}break}}return o|0}function Md(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;g=Z-16|0;Z=g;a:{if(!Sa(1,g+8|0,b)){break a}d=F[b+8>>2];e=F[b+16>>2];f=d-e|0;h=F[g+12>>2];c=d>>>0<e>>>0;d=F[b+20>>2];i=F[b+12>>2]-(c+d|0)|0;c=F[g+8>>2];if((h|0)==(i|0)&c>>>0>f>>>0|h>>>0>i>>>0){break a}d=d+h|0;f=c+e|0;d=f>>>0<e>>>0?d+1|0:d;F[b+16>>2]=f;F[b+20>>2]=d;if((c|0)<=0){break a}b=F[b>>2]+e|0;F[a+40>>2]=b;e=c-1|0;d=b+e|0;f=G[d|0];b:{if(f>>>0<=63){F[a+44>>2]=e;b=G[d|0]&63;break b}c:{switch((f>>>6|0)-1|0){case 0:if(c>>>0<2){break a}c=c-2|0;F[a+44>>2]=c;b=b+c|0;b=G[b+1|0]<<8&16128|G[b|0];break b;case 1:if(c>>>0<3){break a}c=c-3|0;F[a+44>>2]=c;b=b+c|0;b=G[b+1|0]<<8|G[b+2|0]<<16&4128768|G[b|0];break b;default:break c}}c=c-4|0;F[a+44>>2]=c;b=b+c|0;b=(G[b|0]|G[b+1|0]<<8|(G[b+2|0]<<16|G[b+3|0]<<24))&1073741823;}F[a+48>>2]=b+16384;j=b>>>0<4177920;}Z=g+16|0;return j}function Tf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;a:{a=Z-32|0;Z=a;e=ya(c);if(e>>>0<2147483632){b:{c:{if(e>>>0>=11){g=(e|15)+1|0;f=ka(g);F[a+24>>2]=g|-2147483648;F[a+16>>2]=f;F[a+20>>2]=e;g=e+f|0;break c}D[a+27|0]=e;f=a+16|0;g=e+f|0;if(!e){break b}}la(f,c,e);}D[g|0]=0;F[a+8>>2]=0;F[a>>2]=0;F[a+4>>2]=0;d:{c=Ya(b,a+16|0);if((c|0)==(b+4|0)){break d}b=F[c+28>>2];e=F[c+32>>2];if((b|0)==(e|0)){break d}b=e-b|0;if(b&3){break d}e=b>>>2|0;f=F[a+4>>2];b=F[a>>2];g=f-b>>2;e:{if(e>>>0>g>>>0){qa(a,e-g|0);b=F[a>>2];f=F[a+4>>2];break e}if(e>>>0>=g>>>0){break e}f=(e<<2)+b|0;F[a+4>>2]=f;}if((b|0)!=(f|0)){e=b;b=F[c+28>>2];la(e,b,F[c+32>>2]-b|0);break d}ta();v();}b=F[d>>2];if(b){F[d+4>>2]=b;ja(b);}F[d>>2]=F[a>>2];F[d+4>>2]=F[a+4>>2];F[d+8>>2]=F[a+8>>2];if(D[a+27|0]<0){ja(F[a+16>>2]);}Z=a+32|0;break a}za();v();}}function ud(a){a=a|0;var b=0,c=0,d=0,e=0;F[a>>2]=8284;d=F[a+368>>2];F[a+368>>2]=0;if(d){e=d-4|0;b=F[e>>2];if(b){c=(b<<4)+d|0;while(1){c=c-16|0;if((d|0)!=(c|0)){continue}break}}ja(e);}td(a+216|0);b=F[a+196>>2];if(b){F[a+200>>2]=b;ja(b);}b=F[a+184>>2];if(b){F[a+188>>2]=b;ja(b);}b=F[a+172>>2];if(b){F[a+176>>2]=b;ja(b);}b=F[a+160>>2];if(b){F[a+164>>2]=b;ja(b);}c=F[a+144>>2];if(c){while(1){b=F[c>>2];ja(c);c=b;if(b){continue}break}}b=F[a+136>>2];F[a+136>>2]=0;if(b){ja(b);}b=F[a+120>>2];if(b){ja(b);}b=F[a+108>>2];if(b){ja(b);}b=F[a+96>>2];if(b){ja(b);}b=F[a+72>>2];if(b){F[a+76>>2]=b;ja(b);}b=F[a+60>>2];if(b){ja(b);}b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}b=F[a+36>>2];if(b){F[a+40>>2]=b;ja(b);}b=F[a+24>>2];if(b){F[a+28>>2]=b;ja(b);}b=F[a+12>>2];if(b){F[a+16>>2]=b;ja(b);}b=F[a+8>>2];F[a+8>>2]=0;if(b){Za(b);}return a|0}function Vf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=Z-16|0;Z=d;a:{e=ya(c);if(e>>>0<2147483632){b:{c:{if(e>>>0>=11){f=(e|15)+1|0;a=ka(f);F[d+8>>2]=f|-2147483648;F[d>>2]=a;F[d+4>>2]=e;f=a+e|0;break c}D[d+11|0]=e;f=d+e|0;a=d;if(!e){break b}}la(a,c,e);}D[f|0]=0;c=G[d+11|0];e=c<<24>>24;b=F[b+4>>2];a=0;d:{if(!b){break d}a=c;c=(e|0)<0;a=c?F[d+4>>2]:a;f=c?F[d>>2]:d;while(1){c=G[b+27|0];g=c<<24>>24<0;c=g?F[b+20>>2]:c;i=c>>>0<a>>>0;e:{f:{g:{h:{i:{j:{h=i?c:a;if(h){g=g?F[b+16>>2]:b+16|0;j=sa(f,g,h);if(j){break j}if(a>>>0>=c>>>0){break i}break e}if(a>>>0>=c>>>0){break h}break e}if((j|0)<0){break e}}c=sa(g,f,h);if(c){break g}}if(i){break f}a=1;break d}if((c|0)<0){break f}a=1;break d}b=b+4|0;}b=F[b>>2];if(b){continue}break}a=0;}if((e|0)<0){ja(F[d>>2]);}Z=d+16|0;break a}za();v();}return a|0}function lc(a,b){var c=0,d=0;c=F[b+8>>2];F[a+4>>2]=F[b+4>>2];F[a+8>>2]=c;F[a+20>>2]=F[b+20>>2];c=F[b+16>>2];F[a+12>>2]=F[b+12>>2];F[a+16>>2]=c;a:{b:{if((a|0)!=(b|0)){c=F[b+28>>2];if(c){d=F[a+24>>2];if(F[a+32>>2]<<5>>>0<c>>>0){if(d){ja(d);F[a+32>>2]=0;F[a+24>>2]=0;F[a+28>>2]=0;c=F[b+28>>2];}if((c|0)<0){break b}c=(c-1>>>5|0)+1|0;d=ka(c<<2);F[a+32>>2]=c;F[a+28>>2]=0;F[a+24>>2]=d;c=F[b+28>>2];}pa(d,F[b+24>>2],(c-1>>>3&536870908)+4|0);c=F[b+28>>2];}else {c=0;}F[a+28>>2]=c;c=F[b+40>>2];if(c){d=F[a+36>>2];if(F[a+44>>2]<<5>>>0<c>>>0){if(d){ja(d);F[a+44>>2]=0;F[a+36>>2]=0;F[a+40>>2]=0;c=F[b+40>>2];}if((c|0)<0){break a}c=(c-1>>>5|0)+1|0;d=ka(c<<2);F[a+44>>2]=c;F[a+40>>2]=0;F[a+36>>2]=d;c=F[b+40>>2];}pa(d,F[b+36>>2],(c-1>>>3&536870908)+4|0);b=F[b+40>>2];}else {b=0;}F[a+40>>2]=b;}return}na();v();}na();v();}function nc(a){var b=0,c=0,d=0;b=F[a+8>>2];d=F[a>>2];a:{if(G[a+12|0]){b:{c:{d:{e:{if((b|0)==-1){break e}c=b+1|0;b=(c>>>0)%3|0?c:b-2|0;if((b|0)==-1){break e}b=F[F[d+12>>2]+(b<<2)>>2];if((b|0)!=-1){break d}}F[a+8>>2]=-1;break c}c=b+1|0;b=(c>>>0)%3|0?c:b-2|0;F[a+8>>2]=b;if((b|0)!=-1){break b}}c=F[a+4>>2];b=-1;f:{if((c|0)==-1){break f}g:{if((c>>>0)%3|0){c=c-1|0;break g}c=c+2|0;b=-1;if((c|0)==-1){break f}}c=F[F[d+12>>2]+(c<<2)>>2];b=-1;if((c|0)==-1){break f}b=c-1|0;if((c>>>0)%3|0){break f}b=c+2|0;}D[a+12|0]=0;F[a+8>>2]=b;return}if((b|0)!=F[a+4>>2]){break a}F[a+8>>2]=-1;return}c=-1;h:{if((b|0)==-1){break h}i:{if((b>>>0)%3|0){b=b-1|0;break i}b=b+2|0;c=-1;if((b|0)==-1){break h}}b=F[F[d+12>>2]+(b<<2)>>2];c=-1;if((b|0)==-1){break h}c=b-1|0;if((b>>>0)%3|0){break h}c=b+2|0;}F[a+8>>2]=c;}}function Od(a){var b=0,c=0,d=0;b=ka(32);D[b+26|0]=0;c=G[1475]|G[1476]<<8;D[b+24|0]=c;D[b+25|0]=c>>>8;c=G[1471]|G[1472]<<8|(G[1473]<<16|G[1474]<<24);d=G[1467]|G[1468]<<8|(G[1469]<<16|G[1470]<<24);D[b+16|0]=d;D[b+17|0]=d>>>8;D[b+18|0]=d>>>16;D[b+19|0]=d>>>24;D[b+20|0]=c;D[b+21|0]=c>>>8;D[b+22|0]=c>>>16;D[b+23|0]=c>>>24;c=G[1463]|G[1464]<<8|(G[1465]<<16|G[1466]<<24);d=G[1459]|G[1460]<<8|(G[1461]<<16|G[1462]<<24);D[b+8|0]=d;D[b+9|0]=d>>>8;D[b+10|0]=d>>>16;D[b+11|0]=d>>>24;D[b+12|0]=c;D[b+13|0]=c>>>8;D[b+14|0]=c>>>16;D[b+15|0]=c>>>24;c=G[1455]|G[1456]<<8|(G[1457]<<16|G[1458]<<24);d=G[1451]|G[1452]<<8|(G[1453]<<16|G[1454]<<24);D[b|0]=d;D[b+1|0]=d>>>8;D[b+2|0]=d>>>16;D[b+3|0]=d>>>24;D[b+4|0]=c;D[b+5|0]=c>>>8;D[b+6|0]=c>>>16;D[b+7|0]=c>>>24;F[a>>2]=-1;ra(a+4|0,b,26);ja(b);}function Kg(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0;e=F[a+4>>2];d=F[e>>2];a:{b=F[a+12>>2];c=F[b+56>>2]-F[b+52>>2]|0;f=c>>2;b:{if(f>>>0<=F[e+8>>2]-d>>2>>>0){break b}if((c|0)<0){break a}b=F[e+4>>2];c=ka(c);f=c+(f<<2)|0;g=c+(b-d&-4)|0;c=g;if((b|0)!=(d|0)){while(1){c=c-4|0;b=b-4|0;F[c>>2]=F[b>>2];if((b|0)!=(d|0)){continue}break}}F[e+8>>2]=f;F[e+4>>2]=g;F[e>>2]=c;if(!d){break b}ja(d);}e=a+8|0;b=F[a+76>>2];c:{if(b){d=F[b>>2];if((d|0)==F[b+4>>2]){return 1}b=0;while(1){c=od(e,F[(b<<2)+d>>2]);if(!c){break c}f=F[a+76>>2];d=F[f>>2];b=b+1|0;if(b>>>0<F[f+4>>2]-d>>2>>>0){continue}break}break c}c=1;a=F[F[a+12>>2]+64>>2];a=F[a+4>>2]-F[a>>2]|0;if(a>>>0<12){break c}a=(a>>2>>>0)/3|0;b=0;while(1){c=od(e,L(b,3));if(!c){break c}b=b+1|0;if((a|0)!=(b|0)){continue}break}}return c|0}na();v();}function Qg(a){a=a|0;var b=0,c=0,d=0,e=0,f=0,g=0;e=F[a+4>>2];d=F[e>>2];a:{b=F[a+12>>2];c=F[b+28>>2]-F[b+24>>2]|0;f=c>>2;b:{if(f>>>0<=F[e+8>>2]-d>>2>>>0){break b}if((c|0)<0){break a}b=F[e+4>>2];c=ka(c);f=c+(f<<2)|0;g=c+(b-d&-4)|0;c=g;if((b|0)!=(d|0)){while(1){c=c-4|0;b=b-4|0;F[c>>2]=F[b>>2];if((b|0)!=(d|0)){continue}break}}F[e+8>>2]=f;F[e+4>>2]=g;F[e>>2]=c;if(!d){break b}ja(d);}e=a+8|0;b=F[a+76>>2];c:{if(b){d=F[b>>2];if((d|0)==F[b+4>>2]){return 1}b=0;while(1){c=pd(e,F[(b<<2)+d>>2]);if(!c){break c}f=F[a+76>>2];d=F[f>>2];b=b+1|0;if(b>>>0<F[f+4>>2]-d>>2>>>0){continue}break}break c}c=1;a=F[a+12>>2];a=F[a+4>>2]-F[a>>2]|0;if(a>>>0<12){break c}a=(a>>2>>>0)/3|0;b=0;while(1){c=pd(e,L(b,3));if(!c){break c}b=b+1|0;if((a|0)!=(b|0)){continue}break}}return c|0}na();v();}function pa(a,b,c){var d=0,e=0;a:{if((a|0)==(b|0)){break a}e=a+c|0;if(b-e>>>0<=0-(c<<1)>>>0){return la(a,b,c)}d=(a^b)&3;b:{c:{if(a>>>0<b>>>0){if(d){d=a;break b}if(!(a&3)){d=a;break c}d=a;while(1){if(!c){break a}D[d|0]=G[b|0];b=b+1|0;c=c-1|0;d=d+1|0;if(d&3){continue}break}break c}d:{if(d){break d}if(e&3){while(1){if(!c){break a}c=c-1|0;d=c+a|0;D[d|0]=G[b+c|0];if(d&3){continue}break}}if(c>>>0<=3){break d}while(1){c=c-4|0;F[c+a>>2]=F[b+c>>2];if(c>>>0>3){continue}break}}if(!c){break a}while(1){c=c-1|0;D[c+a|0]=G[b+c|0];if(c){continue}break}break a}if(c>>>0<=3){break b}while(1){F[d>>2]=F[b>>2];b=b+4|0;d=d+4|0;c=c-4|0;if(c>>>0>3){continue}break}}if(!c){break a}while(1){D[d|0]=G[b|0];d=d+1|0;b=b+1|0;c=c-1|0;if(c){continue}break}}return a}function Pb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;d=F[a+8>>2];c=F[a+4>>2];if(d-c>>2>>>0>=b>>>0){if(b){b=b<<2;c=ma(c,0,b)+b|0;}F[a+4>>2]=c;return}a:{b:{c:{g=F[a>>2];f=c-g>>2;e=f+b|0;if(e>>>0<1073741824){d=d-g|0;h=d>>>1|0;e=d>>>0>=2147483644?1073741823:e>>>0<h>>>0?h:e;if(e){if(e>>>0>=1073741824){break c}i=ka(e<<2);}d=(f<<2)+i|0;f=b<<2;b=ma(d,0,f);f=b+f|0;e=(e<<2)+i|0;if((c|0)==(g|0)){break b}while(1){c=c-4|0;b=F[c>>2];F[c>>2]=0;d=d-4|0;F[d>>2]=b;if((c|0)!=(g|0)){continue}break}F[a+8>>2]=e;b=F[a+4>>2];F[a+4>>2]=f;c=F[a>>2];F[a>>2]=d;if((b|0)==(c|0)){break a}while(1){b=b-4|0;a=F[b>>2];F[b>>2]=0;if(a){$[F[F[a>>2]+4>>2]](a);}if((b|0)!=(c|0)){continue}break}break a}na();v();}oa();v();}F[a+8>>2]=e;F[a+4>>2]=f;F[a>>2]=b;}if(c){ja(c);}}function Yd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;e=F[b+8>>2];d=F[b+12>>2];g=d;d=F[b+20>>2];k=d;h=F[b+16>>2];c=h+4|0;d=c>>>0<4?d+1|0:d;i=c;a:{if(c>>>0>e>>>0&(d|0)>=(g|0)|(d|0)>(g|0)){break a}j=F[b>>2];c=j+h|0;f=G[c|0]|G[c+1|0]<<8|(G[c+2|0]<<16|G[c+3|0]<<24);F[b+16>>2]=i;F[b+20>>2]=d;c=e;e=k;d=h+8|0;e=d>>>0<8?e+1|0:e;if(c>>>0<d>>>0&(e|0)>=(g|0)|(e|0)>(g|0)){break a}c=i+j|0;c=G[c|0]|G[c+1|0]<<8|(G[c+2|0]<<16|G[c+3|0]<<24);F[b+16>>2]=d;F[b+20>>2]=e;if((c|0)<(f|0)){break a}F[a+16>>2]=c;F[a+12>>2]=f;d=(c>>31)-((f>>31)+(c>>>0<f>>>0)|0)|0;e=c-f|0;if(!d&e>>>0>2147483646|d){break a}d=e+1|0;F[a+20>>2]=d;e=d>>>1|0;F[a+24>>2]=e;F[a+28>>2]=0-e;if(!(d&1)){F[a+24>>2]=e-1;}l=Aa(a+112|0,b);}return l|0}function Wc(a,b){var c=0,d=0,e=0,f=0;d=-1;e=-1;f=-1;a:{b:{if((b|0)==-1){break b}e=F[F[F[a+4>>2]+12>>2]+(b<<2)>>2];c=b+1|0;c=(c>>>0)%3|0?c:b-2|0;if((c|0)>=0){f=(c>>>0)/3|0;f=F[(F[F[a>>2]+96>>2]+L(f,12)|0)+(c-L(f,3)<<2)>>2];}c:{if((e|0)==-1){break c}c=((e>>>0)%3|0?-1:2)+e|0;if((c|0)<0){break c}d=(c>>>0)/3|0;d=F[(F[F[a>>2]+96>>2]+L(d,12)|0)+(c-L(d,3)<<2)>>2];}c=-1;if((d|0)!=(f|0)){break a}f=-1;d:{b=((b>>>0)%3|0?-1:2)+b|0;if((b|0)>=0){d=(b>>>0)/3|0;d=F[(F[F[a>>2]+96>>2]+L(d,12)|0)+(b-L(d,3)<<2)>>2];if((e|0)==-1){break b}break d}d=-1;if((e|0)!=-1){break d}break b}b=e+1|0;b=(b>>>0)%3|0?b:e-2|0;if((b|0)<0){break b}c=F[F[a>>2]+96>>2];a=(b>>>0)/3|0;f=F[(c+L(a,12)|0)+(b-L(a,3)<<2)>>2];}c=(d|0)!=(f|0)?-1:e;}return c}function Fc(a,b){var c=0,d=0,e=0;c=Z+-64|0;Z=c;d=F[a>>2];e=F[d-4>>2];d=F[d-8>>2];F[c+32>>2]=0;F[c+36>>2]=0;F[c+40>>2]=0;F[c+44>>2]=0;F[c+48>>2]=0;F[c+52>>2]=0;D[c+55|0]=0;D[c+56|0]=0;D[c+57|0]=0;D[c+58|0]=0;D[c+59|0]=0;D[c+60|0]=0;D[c+61|0]=0;D[c+62|0]=0;F[c+24>>2]=0;F[c+28>>2]=0;F[c+20>>2]=0;F[c+16>>2]=11020;F[c+12>>2]=a;F[c+8>>2]=b;a=a+d|0;d=0;a:{if(La(e,b,0)){F[c+56>>2]=1;$[F[F[e>>2]+20>>2]](e,c+8|0,a,a,1,0);d=F[c+32>>2]==1?a:0;break a}$[F[F[e>>2]+24>>2]](e,c+8|0,a,1,0);b:{switch(F[c+44>>2]){case 0:d=F[c+48>>2]==1?F[c+36>>2]==1?F[c+40>>2]==1?F[c+28>>2]:0:0:0;break a;case 1:break b;default:break a}}if(F[c+32>>2]!=1){if(F[c+48>>2]|F[c+36>>2]!=1|F[c+40>>2]!=1){break a}}d=F[c+24>>2];}Z=c- -64|0;return d}function ma(a,b,c){var d=0,e=0,f=0,g=0;a:{if(!c){break a}D[a|0]=b;d=a+c|0;D[d-1|0]=b;if(c>>>0<3){break a}D[a+2|0]=b;D[a+1|0]=b;D[d-3|0]=b;D[d-2|0]=b;if(c>>>0<7){break a}D[a+3|0]=b;D[d-4|0]=b;if(c>>>0<9){break a}d=0-a&3;e=d+a|0;b=L(b&255,16843009);F[e>>2]=b;d=c-d&-4;c=d+e|0;F[c-4>>2]=b;if(d>>>0<9){break a}F[e+8>>2]=b;F[e+4>>2]=b;F[c-8>>2]=b;F[c-12>>2]=b;if(d>>>0<25){break a}F[e+24>>2]=b;F[e+20>>2]=b;F[e+16>>2]=b;F[e+12>>2]=b;F[c-16>>2]=b;F[c-20>>2]=b;F[c-24>>2]=b;F[c-28>>2]=b;g=e&4|24;c=d-g|0;if(c>>>0<32){break a}d=ki(b,0,1,1);f=_;b=e+g|0;while(1){F[b+24>>2]=d;F[b+28>>2]=f;F[b+16>>2]=d;F[b+20>>2]=f;F[b+8>>2]=d;F[b+12>>2]=f;F[b>>2]=d;F[b+4>>2]=f;b=b+32|0;c=c-32|0;if(c>>>0>31){continue}break}}return a}function ie(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;d=F[b+8>>2];e=F[b+12>>2];g=e;e=F[b+20>>2];k=e;h=F[b+16>>2];c=h+4|0;e=c>>>0<4?e+1|0:e;i=c;a:{if(c>>>0>d>>>0&(e|0)>=(g|0)|(e|0)>(g|0)){break a}j=F[b>>2];c=j+h|0;f=G[c|0]|G[c+1|0]<<8|(G[c+2|0]<<16|G[c+3|0]<<24);F[b+16>>2]=i;F[b+20>>2]=e;c=d;d=k;e=h+8|0;d=e>>>0<8?d+1|0:d;if(c>>>0<e>>>0&(d|0)>=(g|0)|(d|0)>(g|0)){break a}c=i+j|0;c=G[c|0]|G[c+1|0]<<8|(G[c+2|0]<<16|G[c+3|0]<<24);F[b+16>>2]=e;F[b+20>>2]=d;if((c|0)<(f|0)){break a}F[a+16>>2]=c;F[a+12>>2]=f;d=(c>>31)-((f>>31)+(c>>>0<f>>>0)|0)|0;b=c-f|0;if(!d&b>>>0>2147483646|d){break a}l=1;d=b+1|0;F[a+20>>2]=d;b=d>>>1|0;F[a+24>>2]=b;F[a+28>>2]=0-b;if(d&1){break a}F[a+24>>2]=b-1;}return l|0}function Uc(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;d=Z-16|0;Z=d;f=F[a+24>>2];k=F[a+28>>2];a:{if((f|0)!=(k|0)){while(1){F[d+8>>2]=0;F[d>>2]=0;F[d+4>>2]=0;a=Sc(F[f>>2],b,d);g=G[d+11|0];h=g<<24>>24;i=3;b:{c:{d:{if(!a){break d}i=0;a=G[c+11|0];e=a<<24>>24;j=(h|0)<0?F[d+4>>2]:g;if((j|0)!=(((e|0)<0?F[c+4>>2]:a)|0)){break d}a=(e|0)<0?F[c>>2]:c;e=(h|0)<0;e:{if(!e){e=d;if(!h){break e}while(1){if(G[e|0]!=G[a|0]){break d}a=a+1|0;e=e+1|0;g=g-1|0;if(g){continue}break}break e}if(!j){break e}if(sa(e?F[d>>2]:d,a,j)){break c}}l=F[f>>2];i=1;}if((h|0)>=0){break b}}ja(F[d>>2]);}f:{switch(i|0){case 0:case 3:break f;default:break a}}f=f+4|0;if((k|0)!=(f|0)){continue}break}}l=0;}Z=d+16|0;return l}function gb(a,b,c){var d=0,e=0,f=0,g=0,h=0,i=0;f=c-b|0;h=f>>2;d=F[a+8>>2];e=F[a>>2];if(h>>>0<=d-e>>2>>>0){d=F[a+4>>2];g=d-e|0;f=g+b|0;i=g>>2;g=i>>>0<h>>>0?f:c;if((g|0)!=(b|0)){while(1){F[e>>2]=F[b>>2];e=e+4|0;b=b+4|0;if((g|0)!=(b|0)){continue}break}}if(h>>>0>i>>>0){if((c|0)!=(g|0)){while(1){F[d>>2]=F[f>>2];d=d+4|0;f=f+4|0;if((f|0)!=(c|0)){continue}break}}F[a+4>>2]=d;return}F[a+4>>2]=e;return}if(e){F[a+4>>2]=e;ja(e);F[a+8>>2]=0;F[a>>2]=0;F[a+4>>2]=0;d=0;}a:{if((f|0)<0){break a}e=d>>>1|0;d=d>>>0>=2147483644?1073741823:e>>>0>h>>>0?e:h;if(d>>>0>=1073741824){break a}e=d<<2;d=ka(e);F[a>>2]=d;F[a+8>>2]=d+e;if((b|0)!=(c|0)){c=b;b=(f-4&-4)+4|0;d=la(d,c,b)+b|0;}F[a+4>>2]=d;return}na();v();}function Ea(a,b,c){var d=0,e=0,f=0;e=Z-16|0;Z=e;F[a+4>>2]=0;a:{b:{if(!b){break b}f=F[a+8>>2];d=f<<5;c:{if(d>>>0>=b>>>0){F[a+4>>2]=b;break c}F[e+8>>2]=0;F[e>>2]=0;F[e+4>>2]=0;if((b|0)<0){break a}if(d>>>0<=1073741822){f=f<<6;d=b+31&-32;d=d>>>0<f>>>0?f:d;}else {d=2147483647;}$a(e,d);f=F[a>>2];F[a>>2]=F[e>>2];F[e>>2]=f;d=F[a+4>>2];F[a+4>>2]=b;F[e+4>>2]=d;d=F[a+8>>2];F[a+8>>2]=F[e+8>>2];F[e+8>>2]=d;if(!f){break c}ja(f);}d=b>>>5|0;a=F[a>>2];if(G[c|0]){if(b>>>0>=32){ma(a,255,d<<2);}if((b&-32)==(b|0)){break b}a=a+(d<<2)|0;F[a>>2]=F[a>>2]|-1>>>32-(b&31);break b}if(b>>>0>=32){ma(a,0,d<<2);}if((b&-32)==(b|0)){break b}a=a+(d<<2)|0;F[a>>2]=F[a>>2]&(-1>>>32-(b&31)^-1);}Z=e+16|0;return}na();v();}function If(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;e=Z-32|0;Z=e;a:{b:{f=ya(c);if(f>>>0<2147483632){c:{d:{if(f>>>0>=11){a=(f|15)+1|0;g=ka(a);F[e+24>>2]=a|-2147483648;F[e+16>>2]=g;F[e+20>>2]=f;a=f+g|0;break d}D[e+27|0]=f;g=e+16|0;a=f+g|0;if(!f){break c}}la(g,c,f);}D[a|0]=0;c=ya(d);if(c>>>0>=2147483632){break b}e:{f:{if(c>>>0>=11){f=(c|15)+1|0;a=ka(f);F[e+8>>2]=f|-2147483648;F[e>>2]=a;F[e+4>>2]=c;g=a+c|0;break f}D[e+11|0]=c;g=c+e|0;a=e;if(!c){break e}}la(a,d,c);}D[g|0]=0;c=F[b+4>>2];a=-1;g:{if(!c){break g}c=Uc(c,e+16|0,e);a=-1;if(!c){break g}a=Pc(b,F[c+24>>2]);}if(D[e+11|0]<0){ja(F[e>>2]);}if(D[e+27|0]<0){ja(F[e+16>>2]);}Z=e+32|0;break a}za();v();}za();v();}return a|0}function ne(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0;h=F[c+12>>2];f=h;e=F[c+20>>2];j=F[c+8>>2];g=F[c+16>>2];a:{if((f|0)<=(e|0)&j>>>0<=g>>>0|(e|0)>(f|0)){break a}k=F[c>>2];i=D[k+g|0];d=e;f=g+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;if((i-7&255)>>>0<247){break a}b:{if((i|0)==-2){break b}if((d|0)>=(h|0)&f>>>0>=j>>>0|(d|0)>(h|0)){break a}d=D[f+k|0];g=g+2|0;e=g>>>0<2?e+1|0:e;F[c+16>>2]=g;F[c+20>>2]=e;if((d-4&255)>>>0<251){break a}e=$[F[F[a>>2]+40>>2]](a,i,d)|0;d=F[a+20>>2];F[a+20>>2]=e;if(!d){break b}$[F[F[d>>2]+4>>2]](d);}d=F[a+20>>2];if(d){if(!($[F[F[a>>2]+28>>2]](a,d)|0)){break a}}l=$[F[F[a>>2]+36>>2]](a,b,c)|0;}return l|0}function se(a,b){a=a|0;b=b|0;a=0;a:{switch(b|0){case 0:a=ka(20);F[a+12>>2]=-1;F[a+16>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[a>>2]=1920;return a|0;case 1:a=ka(24);F[a+12>>2]=-1;F[a+16>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[a>>2]=1920;F[a+20>>2]=0;F[a>>2]=2136;return a|0;case 2:a=ka(48);F[a+12>>2]=-1;F[a+16>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[a>>2]=1920;F[a+20>>2]=0;F[a>>2]=2136;F[a+24>>2]=1624;F[a>>2]=7948;F[a+32>>2]=0;F[a+36>>2]=0;F[a+28>>2]=-1;F[a+40>>2]=0;F[a+44>>2]=0;return a|0;case 3:a=ka(32);F[a+12>>2]=-1;F[a+16>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[a>>2]=1920;F[a+20>>2]=0;F[a>>2]=2136;F[a+24>>2]=1032;F[a>>2]=5812;F[a+28>>2]=-1;break;default:break a}}return a|0}function Be(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;f=F[b>>2];b=F[b+4>>2];d=F[F[a+8>>2]+40>>2];j=d;m=ka((d|0)<0?-1:d);i=b-f|0;e=1;a:{if((i|0)<4){break a}b=0;g=F[c+16>>2];k=d;f=g+d|0;d=0+F[c+20>>2]|0;d=f>>>0<k>>>0?d+1|0:d;h=F[c+12>>2];e=0;if(I[c+8>>2]<f>>>0&(d|0)>=(h|0)|(d|0)>(h|0)){break a}e=i>>2;i=(e|0)<=1?1:e;while(1){b:{g=la(m,F[c>>2]+g|0,j);F[c+16>>2]=f;F[c+20>>2]=d;la(F[F[F[a+8>>2]+64>>2]>>2]+b|0,g,j);l=l+1|0;if((i|0)==(l|0)){break b}b=b+j|0;d=n+F[c+20>>2]|0;g=F[c+16>>2];f=k+g|0;d=f>>>0<k>>>0?d+1|0:d;h=F[c+12>>2];if((d|0)<=(h|0)&I[c+8>>2]>=f>>>0|(d|0)<(h|0)){continue}}break}e=(e|0)<=(l|0);}ja(m);return e|0}function mh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;F[b>>2]=1;f=b+8|0;c=F[b+8>>2];d=F[b+12>>2]-c|0;if(d>>>0<=4294967291){Db(f,d+4|0);c=F[f>>2];}c=c+d|0;d=F[a+4>>2];D[c|0]=d;D[c+1|0]=d>>>8;D[c+2|0]=d>>>16;D[c+3|0]=d>>>24;c=F[a+8>>2];if((c|0)!=F[a+12>>2]){d=0;while(1){g=(d<<2)+c|0;c=F[b+8>>2];e=F[b+12>>2]-c|0;if(e>>>0<=4294967291){Db(f,e+4|0);c=F[f>>2];}c=c+e|0;e=F[g>>2];D[c|0]=e;D[c+1|0]=e>>>8;D[c+2|0]=e>>>16;D[c+3|0]=e>>>24;d=d+1|0;c=F[a+8>>2];if(d>>>0<F[a+12>>2]-c>>2>>>0){continue}break}}c=F[b+12>>2];b=F[b+8>>2];c=c-b|0;if(c>>>0<=4294967291){Db(f,c+4|0);b=F[f>>2];}b=b+c|0;a=F[a+20>>2];D[b|0]=a;D[b+1|0]=a>>>8;D[b+2|0]=a>>>16;D[b+3|0]=a>>>24;}function mb(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;c=F[a+4>>2];if((c|0)!=F[a+8>>2]){e=F[b+4>>2];F[c>>2]=F[b>>2];F[c+4>>2]=e;F[c+8>>2]=F[b+8>>2];F[a+4>>2]=c+12;return}a:{g=F[a>>2];d=(c-g|0)/12|0;e=d+1|0;if(e>>>0<357913942){f=d<<1;f=d>>>0>=178956970?357913941:e>>>0<f>>>0?f:e;if(f){if(f>>>0>=357913942){break a}e=ka(L(f,12));}else {e=0;}d=e+L(d,12)|0;h=F[b+4>>2];F[d>>2]=F[b>>2];F[d+4>>2]=h;F[d+8>>2]=F[b+8>>2];b=d+12|0;if((c|0)!=(g|0)){while(1){c=c-12|0;h=F[c+4>>2];d=d-12|0;F[d>>2]=F[c>>2];F[d+4>>2]=h;F[d+8>>2]=F[c+8>>2];if((c|0)!=(g|0)){continue}break}c=F[a>>2];}F[a+8>>2]=e+L(f,12);F[a+4>>2]=b;F[a>>2]=d;if(c){ja(c);}return}na();v();}oa();v();}function Bf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0;a:{if(I[b+80>>2]>65535){break a}a=F[b+100>>2];b=F[b+96>>2];e=(a-b|0)/12|0;f=L(e,6);g=(f|0)==(c|0);if((a|0)==(b|0)|(c|0)!=(f|0)){break a}g=1;c=e>>>0<=1?1:e;i=c&1;a=0;if(e>>>0>=2){j=c&-2;c=0;while(1){f=L(a,6);h=f+d|0;e=b+L(a,12)|0;E[h>>1]=F[e>>2];E[(f|2)+d>>1]=F[e+4>>2];E[h+4>>1]=F[e+8>>2];f=a|1;e=L(f,6)+d|0;f=b+L(f,12)|0;E[e>>1]=F[f>>2];E[e+2>>1]=F[f+4>>2];E[e+4>>1]=F[f+8>>2];a=a+2|0;c=c+2|0;if((j|0)!=(c|0)){continue}break}}if(!i){break a}c=L(a,6)+d|0;a=b+L(a,12)|0;E[c>>1]=F[a>>2];E[c+2>>1]=F[a+4>>2];E[c+4>>1]=F[a+8>>2];}return g|0}function Gh(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0;f=Z-32|0;Z=f;h=e>>>0>1073741823?-1:e<<2;h=ma(ka(h),0,h);g=F[b>>2];i=F[b+4>>2];k=F[h+4>>2];F[f+16>>2]=F[h>>2];F[f+20>>2]=k;F[f+8>>2]=g;F[f+12>>2]=i;i=a+8|0;Jb(f+24|0,i,f+16|0,f+8|0);F[c>>2]=F[f+24>>2];F[c+4>>2]=F[f+28>>2];if((d|0)>(e|0)){k=0-e<<2;a=e;while(1){g=a<<2;j=g+b|0;m=F[j>>2];j=F[j+4>>2];g=c+g|0;l=g+k|0;n=F[l+4>>2];F[f+16>>2]=F[l>>2];F[f+20>>2]=n;F[f+8>>2]=m;F[f+12>>2]=j;Jb(f+24|0,i,f+16|0,f+8|0);F[g>>2]=F[f+24>>2];F[g+4>>2]=F[f+28>>2];a=a+e|0;if((d|0)>(a|0)){continue}break}}ja(h);Z=f+32|0;return 1}function Sf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;a=Z-32|0;Z=a;F[a+24>>2]=0;F[a+28>>2]=0;a:{d=ya(c);if(d>>>0<2147483632){b:{c:{if(d>>>0>=11){e=(d|15)+1|0;f=ka(e);F[a+16>>2]=e|-2147483648;F[a+8>>2]=f;F[a+12>>2]=d;e=d+f|0;break c}D[a+19|0]=d;f=a+8|0;e=f+d|0;if(!d){break b}}la(f,c,d);}D[e|0]=0;c=b+4|0;b=Ya(b,a+8|0);d:{if((c|0)==(b|0)){break d}c=F[b+32>>2];b=F[b+28>>2];if((c-b|0)!=8){break d}c=G[b+4|0]|G[b+5|0]<<8|(G[b+6|0]<<16|G[b+7|0]<<24);F[a+24>>2]=G[b|0]|G[b+1|0]<<8|(G[b+2|0]<<16|G[b+3|0]<<24);F[a+28>>2]=c;}g=K[a+24>>3];if(D[a+19|0]<0){ja(F[a+8>>2]);}Z=a+32|0;break a}za();v();}return +g}function Gc(a,b,c,d,e,f,g){var h=0,i=0,j=0;h=Z-16|0;Z=h;if((b^-1)+2147483631>>>0>=c>>>0){if(G[a+11|0]>>>7|0){i=F[a>>2];}else {i=a;}if(b>>>0<1073741799){F[h+12>>2]=b<<1;F[h>>2]=b+c;c=Z-16|0;Z=c;Z=c+16|0;c=h+12|0;c=F[(I[h>>2]<I[c>>2]?c:h)>>2];if(c>>>0>=11){j=c+16&-16;c=j-1|0;c=(c|0)==11?j:c;}else {c=10;}c=c+1|0;}else {c=2147483631;}sb(h,c);c=F[h>>2];if(f){db(c,g,f);}g=d-e|0;if((d|0)!=(e|0)){db(c+f|0,e+i|0,g);}if((b|0)!=10){ja(i);}F[a>>2]=c;F[a+8>>2]=F[a+8>>2]&-2147483648|F[h+4>>2]&2147483647;F[a+8>>2]=F[a+8>>2]|-2147483648;b=a;a=f+g|0;F[b+4>>2]=a;D[h+12|0]=0;D[a+c|0]=G[h+12|0];Z=h+16|0;return}za();v();}function _c(a,b,c){var d=0,e=0,f=0,g=0;a:{f=b>>>0<1431655766&(b|c)>=0;b:{if(!f){break b}b=L(b,3);Xb(a,b,10224);Xb(a+12|0,b,10228);d=F[a+24>>2];c:{if(F[a+32>>2]-d>>2>>>0>=c>>>0){break c}if(c>>>0>=1073741824){break a}b=F[a+28>>2];e=c<<2;c=ka(e);e=c+e|0;g=c+(b-d&-4)|0;c=g;if((b|0)!=(d|0)){while(1){c=c-4|0;b=b-4|0;F[c>>2]=F[b>>2];if((b|0)!=(d|0)){continue}break}}F[a+32>>2]=e;F[a+28>>2]=g;F[a+24>>2]=c;if(!d){break c}ja(d);}F[a+80>>2]=0;F[a+84>>2]=0;b=F[a+76>>2];F[a+76>>2]=0;if(b){ja(b);}F[a+68>>2]=0;F[a+72>>2]=0;b=a- -64|0;a=F[b>>2];F[b>>2]=0;if(!a){break b}ja(a);}return f}na();v();}function yd(a){var b=0,c=0,d=0,e=0,f=0;f=1;c=F[a+140>>2];a:{if((c|0)<=0){break a}b=c<<4;d=ka(c>>>0>268435455?-1:b|4);F[d>>2]=c;d=d+4|0;c=d+b|0;b=d;while(1){F[b>>2]=0;F[b+4>>2]=0;D[b+5|0]=0;D[b+6|0]=0;D[b+7|0]=0;D[b+8|0]=0;D[b+9|0]=0;D[b+10|0]=0;D[b+11|0]=0;D[b+12|0]=0;b=b+16|0;if((c|0)!=(b|0)){continue}break}e=F[a+136>>2];F[a+136>>2]=d;if(e){c=e-4|0;d=F[c>>2];if(d){b=(d<<4)+e|0;while(1){b=b-16|0;if((e|0)!=(b|0)){continue}break}}ja(c);}b=0;if(F[a+140>>2]<=0){break a}while(1){f=Aa(F[a+136>>2]+(b<<4)|0,a);if(!f){break a}b=b+1|0;if((b|0)<F[a+140>>2]){continue}break}}return f}
function Sd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;d=F[b+8>>2];c=F[b+12>>2];g=c;c=F[b+20>>2];i=c;h=F[b+16>>2];f=h+4|0;c=f>>>0<4?c+1|0:c;a:{if(d>>>0<f>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break a}e=h+F[b>>2]|0;e=G[e|0]|G[e+1|0]<<8|(G[e+2|0]<<16|G[e+3|0]<<24);F[b+16>>2]=f;F[b+20>>2]=c;f=d;d=i;c=h+8|0;d=c>>>0<8?d+1|0:d;if(c>>>0>f>>>0&(d|0)>=(g|0)|(d|0)>(g|0)){break a}F[b+16>>2]=c;F[b+20>>2]=d;if(!(e&1)){break a}d=O(e)^31;if(d-1>>>0>28){break a}F[a+8>>2]=d+1;d=-2<<d;c=d^-2;F[a+16>>2]=c;F[a+12>>2]=d^-1;F[a+24>>2]=c>>1;J[a+20>>2]=M(2)/M(c|0);j=Aa(a+96|0,b);}return j|0}function bc(a,b){var c=0;c=F[b+4>>2];F[a>>2]=F[b>>2];F[a+4>>2]=c;c=F[b+60>>2];F[a+56>>2]=F[b+56>>2];F[a+60>>2]=c;c=F[b+52>>2];F[a+48>>2]=F[b+48>>2];F[a+52>>2]=c;c=F[b+44>>2];F[a+40>>2]=F[b+40>>2];F[a+44>>2]=c;c=F[b+36>>2];F[a+32>>2]=F[b+32>>2];F[a+36>>2]=c;c=F[b+28>>2];F[a+24>>2]=F[b+24>>2];F[a+28>>2]=c;c=F[b+20>>2];F[a+16>>2]=F[b+16>>2];F[a+20>>2]=c;c=F[b+12>>2];F[a+8>>2]=F[b+8>>2];F[a+12>>2]=c;F[a+88>>2]=0;F[a+64>>2]=0;F[a+68>>2]=0;F[a+72>>2]=0;F[a+76>>2]=0;D[a+77|0]=0;D[a+78|0]=0;D[a+79|0]=0;D[a+80|0]=0;D[a+81|0]=0;D[a+82|0]=0;D[a+83|0]=0;D[a+84|0]=0;return a}function ac(a,b){var c=0,d=0,e=0,f=0,g=0;a:{if(F[a+64>>2]){break a}c=ka(32);F[c+16>>2]=0;F[c+20>>2]=0;F[c+8>>2]=0;F[c>>2]=0;F[c+4>>2]=0;F[c+24>>2]=0;F[c+28>>2]=0;d=F[a+64>>2];F[a+64>>2]=c;if(!d){break a}c=F[d>>2];if(c){F[d+4>>2]=c;ja(c);}ja(d);}d=F[a+64>>2];c=F[a+28>>2]-1|0;if(c>>>0<=10){c=F[(c<<2)+10148>>2];}else {c=-1;}c=L(c,G[a+24|0]);f=c>>31;g=md(d,0,ki(c,f,b,0),_);if(g){d=F[a+64>>2];F[a>>2]=d;e=F[d+20>>2];F[a+8>>2]=F[d+16>>2];F[a+12>>2]=e;e=F[d+24>>2];d=F[d+28>>2];F[a+48>>2]=0;F[a+52>>2]=0;F[a+40>>2]=c;F[a+44>>2]=f;F[a+16>>2]=e;F[a+20>>2]=d;F[a+80>>2]=b;}return g}function Af(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0,j=0,k=0;a=F[b+100>>2];b=F[b+96>>2];h=a-b|0;a:{if((h|0)!=(c|0)|(a|0)==(b|0)){break a}g=(c|0)/12|0;e=g>>>0<=1?1:g;j=e&1;a=0;if(g>>>0>=2){k=e&-2;g=0;while(1){e=L(a,12);i=e+d|0;f=b+e|0;F[i>>2]=F[f>>2];F[(e|4)+d>>2]=F[f+4>>2];F[i+8>>2]=F[f+8>>2];f=L(a|1,12);e=f+d|0;f=b+f|0;F[e>>2]=F[f>>2];F[e+4>>2]=F[f+4>>2];F[e+8>>2]=F[f+8>>2];a=a+2|0;g=g+2|0;if((k|0)!=(g|0)){continue}break}}if(!j){break a}e=d;d=L(a,12);a=e+d|0;b=b+d|0;F[a>>2]=F[b>>2];F[a+4>>2]=F[b+4>>2];F[a+8>>2]=F[b+8>>2];}return (c|0)==(h|0)|0}function Kh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0,i=0,j=0;c=F[b+8>>2];d=F[b+12>>2];g=d;d=F[b+20>>2];i=d;h=F[b+16>>2];f=h+4|0;d=f>>>0<4?d+1|0:d;a:{if(c>>>0<f>>>0&(d|0)>=(g|0)|(d|0)>(g|0)){break a}e=h+F[b>>2]|0;e=G[e|0]|G[e+1|0]<<8|(G[e+2|0]<<16|G[e+3|0]<<24);F[b+16>>2]=f;F[b+20>>2]=d;f=c;c=i;d=h+8|0;c=d>>>0<8?c+1|0:c;if(d>>>0>f>>>0&(c|0)>=(g|0)|(c|0)>(g|0)){break a}F[b+16>>2]=d;F[b+20>>2]=c;if(!(e&1)){break a}b=O(e)^31;if(b-1>>>0>28){break a}j=1;F[a+8>>2]=b+1;b=-2<<b;c=b^-2;F[a+16>>2]=c;F[a+12>>2]=b^-1;F[a+24>>2]=c>>1;J[a+20>>2]=M(2)/M(c|0);}return j|0}function Ya(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;f=a+4|0;a=F[a+4>>2];a:{b:{if(!a){break b}d=G[b+11|0];c=d<<24>>24<0;g=c?F[b>>2]:b;d=c?F[b+4>>2]:d;b=f;while(1){e=G[a+27|0];c=e<<24>>24<0;e=c?F[a+20>>2]:e;h=e>>>0>d>>>0;i=h?d:e;c:{if(i){c=sa(c?F[a+16>>2]:a+16|0,g,i);if(c){break c}}c=d>>>0>e>>>0?-1:h;}c=(c|0)<0;b=c?b:a;a=F[(c?a+4|0:a)>>2];if(a){continue}break}if((b|0)==(f|0)){break b}c=G[b+27|0];a=c<<24>>24<0;d:{c=a?F[b+20>>2]:c;e=c>>>0<d>>>0?c:d;if(e){a=sa(g,a?F[b+16>>2]:b+16|0,e);if(a){break d}}if(c>>>0>d>>>0){break b}break a}if((a|0)>=0){break a}}b=f;}return b}function Oe(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;if(La(a,F[b+8>>2],e)){if(!(F[b+28>>2]==1|F[b+4>>2]!=(c|0))){F[b+28>>2]=d;}return}a:{if(La(a,F[b>>2],e)){if(!(F[b+16>>2]!=(c|0)&F[b+20>>2]!=(c|0))){if((d|0)!=1){break a}F[b+32>>2]=1;return}F[b+32>>2]=d;b:{if(F[b+44>>2]==4){break b}E[b+52>>1]=0;a=F[a+8>>2];$[F[F[a>>2]+20>>2]](a,b,c,c,1,e);if(G[b+53|0]){F[b+44>>2]=3;if(!G[b+52|0]){break b}break a}F[b+44>>2]=4;}F[b+20>>2]=c;F[b+40>>2]=F[b+40>>2]+1;if(F[b+36>>2]!=1|F[b+24>>2]!=2){break a}D[b+54|0]=1;return}a=F[a+8>>2];$[F[F[a>>2]+24>>2]](a,b,c,d,e);}}function Ig(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;f=ka(64);c=ka(12);F[c+8>>2]=F[F[a+4>>2]+80>>2];F[c>>2]=9968;F[c+4>>2]=0;f=yc(f,c);a:{b:{if((b|0)<0){c=f;break b}h=a+8|0;c=F[a+12>>2];e=F[a+8>>2];g=c-e>>2;c:{if((g|0)>(b|0)){break c}d=b+1|0;if(b>>>0>=g>>>0){Pb(h,d-g|0);break c}if(d>>>0>=g>>>0){break c}e=e+(d<<2)|0;if((e|0)!=(c|0)){while(1){c=c-4|0;d=F[c>>2];F[c>>2]=0;if(d){$[F[F[d>>2]+4>>2]](d);}if((c|0)!=(e|0)){continue}break}}F[a+12>>2]=e;}a=F[h>>2]+(b<<2)|0;c=F[a>>2];F[a>>2]=f;if(!c){break a}}$[F[F[c>>2]+4>>2]](c);}return (b^-1)>>>31|0}function we(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;c=F[a+60>>2];a:{if(!c){break a}F[c+4>>2]=a+48;if(!($[F[F[c>>2]+12>>2]](c)|0)){break a}b:{c=$[F[F[a>>2]+24>>2]](a)|0;if((c|0)<=0){break b}while(1){c:{f=F[($[F[F[a>>2]+28>>2]](a)|0)+4>>2];g=$[F[F[a>>2]+20>>2]](a,d)|0;e=F[a+60>>2];if(!($[F[F[e>>2]+8>>2]](e,F[F[f+8>>2]+(g<<2)>>2])|0)){break c}d=d+1|0;if((c|0)!=(d|0)){continue}break b}break}return 0}d=0;if(!($[F[F[a>>2]+36>>2]](a,b)|0)){break a}if(!($[F[F[a>>2]+40>>2]](a,b)|0)){break a}d=$[F[F[a>>2]+44>>2]](a)|0;}return d|0}function Id(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=F[a+216>>2];if((c|0)!=F[a+220>>2]){while(1){a:{c=F[L(e,144)+c>>2];if((c|0)<0){break a}d=F[a+4>>2];f=F[d+8>>2];if((c|0)>=F[d+12>>2]-f>>2){break a}d=0;c=F[(c<<2)+f>>2];if(($[F[F[c>>2]+24>>2]](c)|0)<=0){break a}while(1){if(($[F[F[c>>2]+20>>2]](c,d)|0)!=(b|0)){d=d+1|0;if(($[F[F[c>>2]+24>>2]](c)|0)>(d|0)){continue}break a}break}a=F[a+216>>2]+L(e,144)|0;return (G[a+100|0]?a+4|0:0)|0}e=e+1|0;c=F[a+216>>2];if(e>>>0<(F[a+220>>2]-c|0)/144>>>0){continue}break}}return 0}function nd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;c=F[a+8>>2];d=F[a+4>>2];if(c-d>>2>>>0>=b>>>0){if(b){b=b<<2;d=ma(d,0,b)+b|0;}F[a+4>>2]=d;return}a:{f=F[a>>2];g=d-f>>2;e=g+b|0;if(e>>>0<1073741824){c=c-f|0;h=c>>>1|0;e=c>>>0>=2147483644?1073741823:e>>>0<h>>>0?h:e;if(e){if(e>>>0>=1073741824){break a}i=ka(e<<2);}c=(g<<2)+i|0;b=b<<2;b=ma(c,0,b)+b|0;if((d|0)!=(f|0)){while(1){c=c-4|0;d=d-4|0;F[c>>2]=F[d>>2];if((d|0)!=(f|0)){continue}break}}F[a+8>>2]=(e<<2)+i;F[a+4>>2]=b;F[a>>2]=c;if(f){ja(f);}return}na();v();}oa();v();}function bb(a){var b=0,c=0,d=0,e=0,f=0;d=F[a+8>>2];a:{if(G[d+84|0]){break a}b=F[a+16>>2];if(!b|!G[b+84|0]){break a}c=F[d+72>>2];e=F[d+68>>2];D[b+84|0]=0;c=c-e>>2;f=F[b+68>>2];e=F[b+72>>2]-f>>2;b:{if(c>>>0>e>>>0){ab(b+68|0,c-e|0,2004);d=F[a+8>>2];break b}if(c>>>0>=e>>>0){break b}F[b+72>>2]=f+(c<<2);}if(G[d+84|0]){break a}c=F[d+68>>2];if((c|0)==F[d+72>>2]){break a}e=F[F[a+16>>2]+68>>2];b=0;while(1){f=b<<2;F[f+e>>2]=F[c+f>>2];b=b+1|0;c=F[d+68>>2];if(b>>>0<F[d+72>>2]-c>>2>>>0){continue}break}}return F[a+16>>2]}function Lf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;e=Z+-64|0;Z=e;f=Ja(e+8|0);F[f+16>>2]=0;F[f+20>>2]=0;F[f>>2]=b;F[f+8>>2]=c;F[f+12>>2]=0;b=e+48|0;Pd(b,a,f,d);F[a+24>>2]=F[e+48>>2];f=a+24|0;a:{if((f|0)==(b|0)){break a}b=a+28|0;c=e+48|4;g=G[e+63|0];d=g<<24>>24;if(D[a+39|0]>=0){if((d|0)>=0){a=F[c+4>>2];F[b>>2]=F[c>>2];F[b+4>>2]=a;F[b+8>>2]=F[c+8>>2];break a}qb(b,F[e+52>>2],F[e+56>>2]);break a}a=(d|0)<0;rb(b,a?F[e+52>>2]:c,a?F[e+56>>2]:g);}if(D[e+63|0]<0){ja(F[e+52>>2]);}Z=e- -64|0;return f|0}function Jf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;a=Z-32|0;Z=a;a:{d=ya(c);if(d>>>0<2147483632){b:{c:{if(d>>>0>=11){e=(d|15)+1|0;f=ka(e);F[a+24>>2]=e|-2147483648;F[a+16>>2]=f;F[a+20>>2]=d;e=d+f|0;break c}D[a+27|0]=d;f=a+16|0;e=f+d|0;if(!d){break b}}la(f,c,d);}D[e|0]=0;D[a+4|0]=0;F[a>>2]=1701667182;D[a+11|0]=4;d=F[b+4>>2];c=-1;d:{if(!d){break d}d=Uc(d,a,a+16|0);c=-1;if(!d){break d}c=Pc(b,F[d+24>>2]);}b=c;if(D[a+11|0]<0){ja(F[a>>2]);}if(D[a+27|0]<0){ja(F[a+16>>2]);}Z=a+32|0;break a}za();v();}return b|0}function Hd(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=F[a+216>>2];if((c|0)!=F[a+220>>2]){while(1){a:{c=F[L(e,144)+c>>2];if((c|0)<0){break a}d=F[a+4>>2];f=F[d+8>>2];if((c|0)>=F[d+12>>2]-f>>2){break a}d=0;c=F[(c<<2)+f>>2];if(($[F[F[c>>2]+24>>2]](c)|0)<=0){break a}while(1){if(($[F[F[c>>2]+20>>2]](c,d)|0)!=(b|0)){d=d+1|0;if(($[F[F[c>>2]+24>>2]](c)|0)>(d|0)){continue}break a}break}return (F[a+216>>2]+L(e,144)|0)+104|0}e=e+1|0;c=F[a+216>>2];if(e>>>0<(F[a+220>>2]-c|0)/144>>>0){continue}break}}return a+184|0}function Uf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0;d=Z-16|0;Z=d;F[d+12>>2]=0;a:{e=ya(c);if(e>>>0<2147483632){b:{c:{if(e>>>0>=11){f=(e|15)+1|0;a=ka(f);F[d+8>>2]=f|-2147483648;F[d>>2]=a;F[d+4>>2]=e;f=a+e|0;break c}D[d+11|0]=e;f=d+e|0;a=d;if(!e){break b}}la(a,c,e);}D[f|0]=0;a=Ya(b,d);d:{if((a|0)==(b+4|0)){break d}b=F[a+32>>2];a=F[a+28>>2];if((b-a|0)!=4){break d}F[d+12>>2]=G[a|0]|G[a+1|0]<<8|(G[a+2|0]<<16|G[a+3|0]<<24);}a=F[d+12>>2];if(D[d+11|0]<0){ja(F[d>>2]);}Z=d+16|0;break a}za();v();}return a|0}function Mf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;d=Z+-64|0;Z=d;e=Ja(d+8|0);F[e+16>>2]=0;F[e+20>>2]=0;F[e>>2]=b;F[e+8>>2]=c;F[e+12>>2]=0;b=d+48|0;Od(b);F[a+24>>2]=F[d+48>>2];f=a+24|0;a:{if((b|0)==(f|0)){break a}b=a+28|0;c=d+48|4;g=G[d+63|0];e=g<<24>>24;if(D[a+39|0]>=0){if((e|0)>=0){a=F[c+4>>2];F[b>>2]=F[c>>2];F[b+4>>2]=a;F[b+8>>2]=F[c+8>>2];break a}qb(b,F[d+52>>2],F[d+56>>2]);break a}a=(e|0)<0;rb(b,a?F[d+52>>2]:c,a?F[d+56>>2]:g);}if(D[d+63|0]<0){ja(F[d+52>>2]);}Z=d- -64|0;return f|0}function Ce(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0,h=0;e=1;a:{if(($[F[F[b>>2]+20>>2]](b)|0)<=0){break a}while(1){e=0;d=Qc(F[F[a+4>>2]+4>>2],$[F[F[b>>2]+24>>2]](b,f)|0);if((d|0)==-1){break a}g=F[a+4>>2];c=0;b:{if((d|0)<0){break b}h=F[g+4>>2];if((d|0)>=F[h+12>>2]-F[h+8>>2]>>2){break b}c=F[F[g+8>>2]+(F[F[g+20>>2]+(d<<2)>>2]<<2)>>2];c=$[F[F[c>>2]+32>>2]](c,d)|0;}if(!c){break a}if(!($[F[F[b>>2]+28>>2]](b,c)|0)){break a}e=1;f=f+1|0;if(($[F[F[b>>2]+20>>2]](b)|0)>(f|0)){continue}break}}return e|0}function Db(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;a:{c=F[a+4>>2];e=F[a>>2];d=c-e|0;b:{if(d>>>0<b>>>0){g=b-d|0;f=F[a+8>>2];if(g>>>0<=f-c>>>0){h=a,i=ma(c,0,g)+g|0,F[h+4>>2]=i;break b}if((b|0)<0){break a}c=f-e|0;f=c<<1;c=c>>>0>=1073741823?2147483647:b>>>0<f>>>0?f:b;f=ka(c);ma(f+d|0,0,g);d=pa(f,e,d);F[a+8>>2]=d+c;F[a+4>>2]=b+d;F[a>>2]=d;if(!e){break b}ja(e);break b}if(b>>>0>=d>>>0){break b}F[a+4>>2]=b+e;}b=F[a+28>>2];c=b;d=b+1|0;b=F[a+24>>2]+1|0;e=b?c:d;F[a+24>>2]=b;F[a+28>>2]=e;return}na();v();}function Ma(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;e=F[a+4>>2];if((e|0)!=F[a+8>>2]){F[e>>2]=F[b>>2];F[a+4>>2]=e+4;return}a:{g=F[a>>2];f=e-g|0;c=f>>2;d=c+1|0;if(d>>>0<1073741824){h=c<<2;c=f>>>1|0;c=f>>>0>=2147483644?1073741823:c>>>0>d>>>0?c:d;if(c){if(c>>>0>=1073741824){break a}f=ka(c<<2);}else {f=0;}d=h+f|0;F[d>>2]=F[b>>2];b=d+4|0;if((e|0)!=(g|0)){while(1){d=d-4|0;e=e-4|0;F[d>>2]=F[e>>2];if((e|0)!=(g|0)){continue}break}}F[a+8>>2]=f+(c<<2);F[a+4>>2]=b;F[a>>2]=d;if(g){ja(g);}return}na();v();}oa();v();}function va(a){F[a>>2]=-1;F[a+4>>2]=0;F[a+8>>2]=0;F[a+32>>2]=0;F[a+36>>2]=0;D[a+28|0]=1;F[a+20>>2]=0;F[a+24>>2]=0;F[a+12>>2]=0;F[a+16>>2]=0;F[a+40>>2]=0;F[a+44>>2]=0;F[a+48>>2]=0;F[a+52>>2]=0;F[a+56>>2]=0;F[a+60>>2]=0;F[a+64>>2]=0;F[a+68>>2]=0;F[a+76>>2]=0;F[a+80>>2]=0;F[a+84>>2]=0;F[a+88>>2]=0;F[a+92>>2]=0;F[a+96>>2]=0;F[a+72>>2]=a+4;F[a+104>>2]=0;F[a+108>>2]=0;D[a+100|0]=1;F[a+112>>2]=0;F[a+116>>2]=0;F[a+120>>2]=0;F[a+124>>2]=0;F[a+128>>2]=0;F[a+132>>2]=0;F[a+136>>2]=0;F[a+140>>2]=0;}function Hb(a,b){var c=0,d=0,e=0,f=0;d=F[a+12>>2];c=F[a+16>>2]-d>>2;a:{if(c>>>0<b>>>0){qa(a+12|0,b-c|0);break a}if(b>>>0>=c>>>0){break a}F[a+16>>2]=d+(b<<2);}b:{c=F[a>>2];c:{if(F[a+8>>2]-c>>2>>>0>=b>>>0){break c}if(b>>>0>=1073741824){break b}d=F[a+4>>2];e=b<<2;b=ka(e);e=b+e|0;f=b+(d-c&-4)|0;b=f;if((c|0)!=(d|0)){while(1){b=b-4|0;d=d-4|0;F[b>>2]=F[d>>2];if((c|0)!=(d|0)){continue}break}}F[a+8>>2]=e;F[a+4>>2]=f;F[a>>2]=b;if(!c){break c}ja(c);}return}na();v();}function tb(a){a=a|0;var b=0,c=0,d=0;F[a>>2]=10300;b=F[a+68>>2];if(b){F[a+72>>2]=b;ja(b);}b=F[a+56>>2];if(b){F[a+60>>2]=b;ja(b);}b=F[a+44>>2];if(b){F[a+48>>2]=b;ja(b);}b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}b=F[a+20>>2];if(b){F[a+24>>2]=b;ja(b);}b=F[a+8>>2];if(b){d=b;c=F[a+12>>2];if((b|0)!=(c|0)){while(1){c=c-4|0;d=F[c>>2];F[c>>2]=0;if(d){xa(d);}if((b|0)!=(c|0)){continue}break}d=F[a+8>>2];}F[a+12>>2]=b;ja(d);}b=F[a+4>>2];F[a+4>>2]=0;if(b){ic(b);}return a|0}function qa(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;e=F[a+8>>2];c=F[a+4>>2];if(e-c>>2>>>0>=b>>>0){if(b){b=b<<2;c=ma(c,0,b)+b|0;}F[a+4>>2]=c;return}a:{f=c;c=F[a>>2];g=f-c|0;h=g>>2;d=h+b|0;if(d>>>0<1073741824){e=e-c|0;f=e>>>1|0;d=e>>>0>=2147483644?1073741823:d>>>0<f>>>0?f:d;if(d){if(d>>>0>=1073741824){break a}i=ka(d<<2);}b=b<<2;e=ma((h<<2)+i|0,0,b);f=d<<2;d=pa(i,c,g);F[a+8>>2]=f+d;F[a+4>>2]=b+e;F[a>>2]=d;if(c){ja(c);}return}na();v();}oa();v();}function gc(a,b){var c=0,d=0,e=0,f=0;c=a+4|0;a=Ya(a,b);a:{if((c|0)==(a|0)){break a}b=a+28|0;b=D[a+39|0]<0?F[b>>2]:b;while(1){a=b;b=a+1|0;c=D[a|0];if((c|0)==32|c-9>>>0<5){continue}break}b:{c:{d:{c=D[a|0];switch(c-43|0){case 0:break c;case 2:break d;default:break b}}e=1;}c=D[b|0];a=b;}if(c-48>>>0<10){while(1){d=(L(d,10)-D[a|0]|0)+48|0;b=D[a+1|0];a=a+1|0;if(b-48>>>0<10){continue}break}}a=e?d:0-d|0;if((a|0)==-1){break a}f=(a|0)!=0;}return f}function Qa(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;a=F[a>>2];c=F[a+4>>2];e=F[a+8>>2];if(c>>>0<e>>>0){F[c>>2]=F[b>>2];F[a+4>>2]=c+4;return}a:{d=c;c=F[a>>2];g=d-c|0;d=g>>2;f=d+1|0;if(f>>>0<1073741824){h=d<<2;e=e-c|0;d=e>>>1|0;f=e>>>0>=2147483644?1073741823:f>>>0<d>>>0?d:f;if(f){if(f>>>0>=1073741824){break a}e=ka(f<<2);}else {e=0;}d=h+e|0;F[d>>2]=F[b>>2];b=pa(e,c,g);F[a+8>>2]=b+(f<<2);F[a+4>>2]=d+4;F[a>>2]=b;if(c){ja(c);}return}na();v();}oa();v();}function db(a,b,c){var d=0,e=0,f=0,g=0,h=0;f=Z-16|0;Z=f;d=Z-32|0;Z=d;e=Z-16|0;Z=e;F[e+12>>2]=b;F[e+8>>2]=b+c;F[d+24>>2]=F[e+12>>2];F[d+28>>2]=F[e+8>>2];Z=e+16|0;c=Z-16|0;Z=c;h=F[d+28>>2];e=F[d+24>>2];g=h-e|0;if((e|0)!=(h|0)){pa(a,e,g);}F[c+12>>2]=e+g;F[c+8>>2]=a+g;F[d+16>>2]=F[c+12>>2];F[d+20>>2]=F[c+8>>2];Z=c+16|0;F[d+12>>2]=(F[d+16>>2]-b|0)+b;F[d+8>>2]=(F[d+20>>2]-a|0)+a;F[f+8>>2]=F[d+12>>2];F[f+12>>2]=F[d+8>>2];Z=d+32|0;Z=f+16|0;}function _a(a,b){var c=0,d=0,e=0,f=0,g=0,h=0,i=0;e=F[a+8>>2];c=F[a+4>>2];if(e-c>>3>>>0>=b>>>0){if(b){b=b<<3;c=ma(c,0,b)+b|0;}F[a+4>>2]=c;return}a:{f=c;c=F[a>>2];g=f-c|0;h=g>>3;d=h+b|0;if(d>>>0<536870912){e=e-c|0;f=e>>>2|0;d=e>>>0>=2147483640?536870911:d>>>0<f>>>0?f:d;if(d){if(d>>>0>=536870912){break a}i=ka(d<<3);}b=b<<3;e=ma((h<<3)+i|0,0,b);f=d<<3;d=pa(i,c,g);F[a+8>>2]=f+d;F[a+4>>2]=b+e;F[a>>2]=d;if(c){ja(c);}return}na();v();}oa();v();}function re(a){a=a|0;var b=0,c=0,d=0;F[a>>2]=2016;b=F[a+60>>2];F[a+60>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}d=F[a+36>>2];if(d){c=F[a+40>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=F[c>>2];F[c>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}if((c|0)!=(d|0)){continue}break}b=F[a+36>>2];}F[a+40>>2]=d;ja(b);}F[a>>2]=1776;b=F[a+16>>2];if(b){F[a+20>>2]=b;ja(b);}b=F[a+4>>2];if(b){F[a+8>>2]=b;ja(b);}return a|0}function qe(a){a=a|0;var b=0,c=0,d=0;F[a>>2]=2016;b=F[a+60>>2];F[a+60>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}d=F[a+36>>2];if(d){c=F[a+40>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=F[c>>2];F[c>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}if((c|0)!=(d|0)){continue}break}b=F[a+36>>2];}F[a+40>>2]=d;ja(b);}F[a>>2]=1776;b=F[a+16>>2];if(b){F[a+20>>2]=b;ja(b);}b=F[a+4>>2];if(b){F[a+8>>2]=b;ja(b);}ja(a);}function Eg(a){a=a|0;var b=0,c=0,d=0,e=0,f=0;a:{b=F[a+8>>2];b:{if((b|0)<0){break b}c=F[a+4>>2];e=F[c>>2];d=F[c+4>>2]-e>>2;c:{if(d>>>0<b>>>0){nd(c,b-d|0);f=F[a+8>>2];break c}f=b;if(b>>>0>=d>>>0){break c}F[c+4>>2]=e+(b<<2);f=b;}d=f;if((d|0)<=0){break b}a=F[a+4>>2];c=F[a>>2];e=F[a+4>>2]-c>>2;a=0;while(1){if((a|0)==(e|0)){break a}F[c+(a<<2)>>2]=a;a=a+1|0;if((d|0)!=(a|0)){continue}break}}return (b^-1)>>>31|0}ta();v();}function fh(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;d=Z-16|0;Z=d;e=F[a+4>>2];a:{if((e|0)==-1){break a}c=F[b+20>>2];if(!!F[b+16>>2]&(c|0)>=0|(c|0)>0){break a}pb(b,F[b+4>>2],F[a+8>>2],F[a+12>>2]);c=F[b+20>>2];if(!!F[b+16>>2]&(c|0)>=0|(c|0)>0){break a}pb(b,F[b+4>>2],a+20|0,a+24|0);c=F[b+20>>2];f=F[b+16>>2];D[d+15|0]=F[a+4>>2];if(!!f&(c|0)>=0|(c|0)>0){break a}pb(b,F[b+4>>2],d+15|0,d+16|0);}Z=d+16|0;return (e|0)!=-1|0}function kd(a,b){var c=0,d=0,e=0,f=0,g=0,h=0;e=F[a+8>>2];c=F[a+4>>2];if(e-c>>1>>>0>=b>>>0){if(b){b=b<<1;c=ma(c,0,b)+b|0;}F[a+4>>2]=c;return}a:{f=c;c=F[a>>2];g=f-c|0;f=g>>1;d=f+b|0;if((d|0)>=0){e=e-c|0;d=e>>>0>=2147483646?2147483647:d>>>0<e>>>0?e:d;if(d){if((d|0)<0){break a}h=ka(d<<1);}b=b<<1;e=ma((f<<1)+h|0,0,b);f=d<<1;d=pa(h,c,g);F[a+8>>2]=f+d;F[a+4>>2]=b+e;F[a>>2]=d;if(c){ja(c);}return}na();v();}oa();v();}function of(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;d=Z-16|0;Z=d;Pd(d,a,b,c);F[a+24>>2]=F[d>>2];e=a+24|0;a:{if((e|0)==(d|0)){break a}b=a+28|0;c=d|4;f=G[d+15|0];g=f<<24>>24;if(D[a+39|0]>=0){if((g|0)>=0){a=F[c+4>>2];F[b>>2]=F[c>>2];F[b+4>>2]=a;F[b+8>>2]=F[c+8>>2];break a}qb(b,F[d+4>>2],F[d+8>>2]);break a}a=(g|0)<0;rb(b,a?F[d+4>>2]:c,a?F[d+8>>2]:f);}if(D[d+15|0]<0){ja(F[d+4>>2]);}Z=d+16|0;return e|0}function ra(a,b,c){var d=0,e=0,f=0,g=0;e=Z-16|0;Z=e;a:{b:{if(c>>>0<11){d=a;D[a+11|0]=G[a+11|0]&128|c;D[a+11|0]=G[a+11|0]&127;break b}if(c>>>0>2147483631){break a}g=e+8|0;if(c>>>0>=11){f=c+16&-16;d=f-1|0;d=(d|0)==11?f:d;}else {d=10;}sb(g,d+1|0);d=F[e+8>>2];F[a>>2]=d;F[a+8>>2]=F[a+8>>2]&-2147483648|F[e+12>>2]&2147483647;F[a+8>>2]=F[a+8>>2]|-2147483648;F[a+4>>2]=c;}db(d,b,c+1|0);Z=e+16|0;return}za();v();}function pf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;b=Z-16|0;Z=b;Od(b);F[a+24>>2]=F[b>>2];e=a+24|0;a:{if((e|0)==(b|0)){break a}c=a+28|0;d=b|4;f=G[b+15|0];g=f<<24>>24;if(D[a+39|0]>=0){if((g|0)>=0){a=F[d+4>>2];F[c>>2]=F[d>>2];F[c+4>>2]=a;F[c+8>>2]=F[d+8>>2];break a}qb(c,F[b+4>>2],F[b+8>>2]);break a}a=(g|0)<0;rb(c,a?F[b+4>>2]:d,a?F[b+8>>2]:f);}if(D[b+15|0]<0){ja(F[b+4>>2]);}Z=b+16|0;return e|0}function Rf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0;d=Z-16|0;Z=d;a:{e=ya(c);if(e>>>0<2147483632){b:{c:{if(e>>>0>=11){g=(e|15)+1|0;f=ka(g);F[d+8>>2]=g|-2147483648;F[d>>2]=f;F[d+4>>2]=e;g=e+f|0;break c}D[d+11|0]=e;g=d+e|0;f=d;if(!e){break b}}la(f,c,e);}D[g|0]=0;f=a+16|0;c=Sc(b,d,f);b=F[a+16>>2];a=D[a+27|0];if(D[d+11|0]<0){ja(F[d>>2]);}Z=d+16|0;a=c?(a|0)<0?b:f:0;break a}za();v();}return a|0}function Yb(a,b){var c=0,d=0,e=0;c=F[a+4>>2];d=c+b|0;F[a+4>>2]=d;if(!((d-1^c-1)>>>0<32?c:0)){F[F[a>>2]+((d>>>0>=33?d-1>>>5|0:0)<<2)>>2]=0;}a:{if(!b){break a}a=F[a>>2]+(c>>>3&536870908)|0;c=c&31;if(c){d=32-c|0;e=b>>>0>d>>>0?d:b;F[a>>2]=F[a>>2]&(-1<<c&-1>>>d-e^-1);b=b-e|0;a=a+4|0;}c=b>>>5|0;if(b>>>0>=32){ma(a,0,c<<2);}if((b&-32)==(b|0)){break a}a=(c<<2)+a|0;F[a>>2]=F[a>>2]&(-1>>>32-(b&31)^-1);}}function ld(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>10){break a}d=F[c+20>>2];f=F[c+12>>2];e=F[c+16>>2];if((d|0)>=(f|0)&e>>>0>=I[c+8>>2]|(d|0)>(f|0)){break a}f=D[e+F[c>>2]|0];e=e+1|0;d=e?d:d+1|0;F[c+16>>2]=e;F[c+20>>2]=d;d=f;b:{if((d|0)<0){if(!ld(a+1|0,b,c)){break a}a=F[b>>2];d=d&127|a<<7;a=F[b+4>>2]<<7|a>>>25;break b}d=d&255;a=0;}F[b>>2]=d;F[b+4>>2]=a;g=1;}return g}function Sa(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>10){break a}d=F[c+20>>2];f=F[c+12>>2];e=F[c+16>>2];if((d|0)>=(f|0)&e>>>0>=I[c+8>>2]|(d|0)>(f|0)){break a}f=D[e+F[c>>2]|0];e=e+1|0;d=e?d:d+1|0;F[c+16>>2]=e;F[c+20>>2]=d;d=f;b:{if((d|0)<0){if(!Sa(a+1|0,b,c)){break a}a=F[b>>2];d=d&127|a<<7;a=F[b+4>>2]<<7|a>>>25;break b}d=d&255;a=0;}F[b>>2]=d;F[b+4>>2]=a;g=1;}return g}function Ne(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;if(La(a,F[b+8>>2],e)){if(!(F[b+28>>2]==1|F[b+4>>2]!=(c|0))){F[b+28>>2]=d;}return}a:{if(!La(a,F[b>>2],e)){break a}if(!(F[b+16>>2]!=(c|0)&F[b+20>>2]!=(c|0))){if((d|0)!=1){break a}F[b+32>>2]=1;return}F[b+20>>2]=c;F[b+32>>2]=d;F[b+40>>2]=F[b+40>>2]+1;if(!(F[b+36>>2]!=1|F[b+24>>2]!=2)){D[b+54|0]=1;}F[b+44>>2]=4;}}function jg(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;e=Z+-64|0;Z=e;d=$[F[F[a>>2]+44>>2]](a,b)|0;a=$[F[F[a>>2]+40>>2]](a,b)|0;f=kb(e);g=F[b+56>>2];h=d&255;i=a;a=a-1|0;if(a>>>0<=10){a=F[(a<<2)+10148>>2];}else {a=-1;}d=L(a,d);cc(f,g,h,i,0,d,d>>31);a=bc(ka(96),f);ac(a,c);D[a+84|0]=1;F[a+72>>2]=F[a+68>>2];F[a+60>>2]=F[b+60>>2];Z=e- -64|0;return a|0}function rh(a){a=a|0;var b=0,c=0,d=0;F[a>>2]=8176;b=F[a+48>>2];F[a+48>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}F[a>>2]=10032;b=F[a+20>>2];if(b){F[a+24>>2]=b;ja(b);}d=F[a+8>>2];if(d){c=F[a+12>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=F[c>>2];F[c>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}if((c|0)!=(d|0)){continue}break}b=F[a+8>>2];}F[a+12>>2]=d;ja(b);}return a|0}function Dc(a,b,c,d){D[a+53|0]=1;a:{if(F[a+4>>2]!=(c|0)){break a}D[a+52|0]=1;c=F[a+16>>2];b:{if(!c){F[a+36>>2]=1;F[a+24>>2]=d;F[a+16>>2]=b;if((d|0)!=1){break a}if(F[a+48>>2]==1){break b}break a}if((b|0)==(c|0)){c=F[a+24>>2];if((c|0)==2){F[a+24>>2]=d;c=d;}if(F[a+48>>2]!=1){break a}if((c|0)==1){break b}break a}F[a+36>>2]=F[a+36>>2]+1;}D[a+54|0]=1;}}function qh(a){a=a|0;var b=0,c=0,d=0;F[a>>2]=8176;b=F[a+48>>2];F[a+48>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}F[a>>2]=10032;b=F[a+20>>2];if(b){F[a+24>>2]=b;ja(b);}d=F[a+8>>2];if(d){c=F[a+12>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=F[c>>2];F[c>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}if((c|0)!=(d|0)){continue}break}b=F[a+8>>2];}F[a+12>>2]=d;ja(b);}ja(a);}function Se(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;e=Z+-64|0;Z=e;d=1;a:{if(La(a,b,0)){break a}d=0;if(!b){break a}b=Fc(b,11068);d=0;if(!b){break a}d=e+8|0;ma(d|4,0,52);F[e+56>>2]=1;F[e+20>>2]=-1;F[e+16>>2]=a;F[e+8>>2]=b;$[F[F[b>>2]+28>>2]](b,d,F[c>>2],1);a=F[e+32>>2];if((a|0)==1){F[c>>2]=F[e+24>>2];}d=(a|0)==1;}Z=e- -64|0;return d|0}function Fd(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=Z-16|0;Z=d;F[a+4>>2]=b;b=F[b+64>>2];e=F[b>>2];b=F[b+4>>2];D[d+15|0]=0;Ea(a+24|0,(b-e>>2>>>0)/3|0,d+15|0);b=F[a+4>>2];e=F[b+56>>2];b=F[b+52>>2];D[d+14|0]=0;Ea(a+36|0,e-b>>2,d+14|0);b=F[c+12>>2];F[a+16>>2]=F[c+8>>2];F[a+20>>2]=b;b=F[c+4>>2];F[a+8>>2]=F[c>>2];F[a+12>>2]=b;Z=d+16|0;}function zf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,g=0;a=Z-16|0;Z=a;f=D[b+24|0];e=F[2555];F[a+8>>2]=F[2554];F[a+12>>2]=e;e=F[2553];F[a>>2]=F[2552];F[a+4>>2]=e;e=lb(b,c,f,a);if(e){b=0;if(f){c=(f&255)<<2;b=ka(c);g=la(b,a,c)+c|0;}c=F[d>>2];if(c){F[d+4>>2]=c;ja(c);}F[d+8>>2]=g;F[d+4>>2]=g;F[d>>2]=b;}Z=a+16|0;return e|0}function wd(a,b){var c=0,d=0;a:{c=F[a+4>>2];d=F[a+8>>2];if((c|0)==d<<5){if((c+1|0)<0){break a}if(c>>>0<=1073741822){d=d<<6;c=(c&-32)+32|0;c=c>>>0<d>>>0?d:c;}else {c=2147483647;}$a(a,c);c=F[a+4>>2];}F[a+4>>2]=c+1;d=1<<c;a=F[a>>2]+(c>>>3&536870908)|0;if(G[b|0]){F[a>>2]=d|F[a>>2];return}F[a>>2]=F[a>>2]&(d^-1);return}na();v();}function Zb(a){var b=0;F[a>>2]=0;F[a+4>>2]=0;F[a+56>>2]=0;F[a+48>>2]=0;F[a+52>>2]=0;F[a+40>>2]=0;F[a+44>>2]=0;F[a+32>>2]=0;F[a+36>>2]=0;F[a+24>>2]=0;F[a+28>>2]=0;F[a+16>>2]=0;F[a+20>>2]=0;F[a+8>>2]=0;F[a+12>>2]=0;b=a- -64|0;F[b>>2]=0;F[b+4>>2]=0;F[a+72>>2]=0;F[a+76>>2]=0;F[a+80>>2]=0;F[a+84>>2]=0;F[a+60>>2]=a;return a}function ve(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;f=$[F[F[a>>2]+24>>2]](a)|0;c=1;a:{if((f|0)<=0){break a}d=F[F[a+36>>2]>>2];g=a+48|0;c=0;if(!($[F[F[d>>2]+16>>2]](d,g,b)|0)){break a}while(1){e=e+1|0;if((f|0)!=(e|0)){d=F[F[a+36>>2]+(e<<2)>>2];if($[F[F[d>>2]+16>>2]](d,g,b)|0){continue}}break}c=(e|0)>=(f|0);}return c|0}function ue(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,g=0;f=$[F[F[a>>2]+24>>2]](a)|0;c=1;a:{if((f|0)<=0){break a}d=F[F[a+36>>2]>>2];g=a+48|0;c=0;if(!($[F[F[d>>2]+20>>2]](d,g,b)|0)){break a}while(1){e=e+1|0;if((f|0)!=(e|0)){d=F[F[a+36>>2]+(e<<2)>>2];if($[F[F[d>>2]+20>>2]](d,g,b)|0){continue}}break}c=(e|0)>=(f|0);}return c|0}function bh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=Z-16|0;Z=d;F[a+4>>2]=b;e=F[b>>2];b=F[b+4>>2];D[d+15|0]=0;Ea(a+24|0,(b-e>>2>>>0)/3|0,d+15|0);b=F[a+4>>2];e=F[b+28>>2];b=F[b+24>>2];D[d+14|0]=0;Ea(a+36|0,e-b>>2,d+14|0);b=F[c+12>>2];F[a+16>>2]=F[c+8>>2];F[a+20>>2]=b;b=F[c+4>>2];F[a+8>>2]=F[c>>2];F[a+12>>2]=b;Z=d+16|0;}function hb(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=F[c+20>>2];e=F[c+12>>2];f=F[c+16>>2];if((d|0)>=(e|0)&f>>>0>=I[c+8>>2]|(d|0)>(e|0)){break a}e=G[F[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;d=e<<24>>24;if((d|0)<0){if(!hb(a+1|0,b,c)){break a}e=d&127|F[b>>2]<<7;}F[b>>2]=e;g=1;}return g}function fb(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=F[c+20>>2];e=F[c+12>>2];f=F[c+16>>2];if((d|0)>=(e|0)&f>>>0>=I[c+8>>2]|(d|0)>(e|0)){break a}e=G[F[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;d=e<<24>>24;if((d|0)<0){if(!fb(a+1|0,b,c)){break a}e=d&127|F[b>>2]<<7;}F[b>>2]=e;g=1;}return g}function Wb(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=F[c+20>>2];e=F[c+12>>2];f=F[c+16>>2];if((d|0)>=(e|0)&f>>>0>=I[c+8>>2]|(d|0)>(e|0)){break a}e=G[F[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;d=e<<24>>24;if((d|0)<0){if(!Wb(a+1|0,b,c)){break a}e=d&127|F[b>>2]<<7;}F[b>>2]=e;g=1;}return g}function Ta(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=F[c+20>>2];e=F[c+12>>2];f=F[c+16>>2];if((d|0)>=(e|0)&f>>>0>=I[c+8>>2]|(d|0)>(e|0)){break a}e=G[F[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;d=e<<24>>24;if((d|0)<0){if(!Ta(a+1|0,b,c)){break a}e=d&127|F[b>>2]<<7;}F[b>>2]=e;g=1;}return g}function Qd(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=F[c+20>>2];e=F[c+12>>2];f=F[c+16>>2];if((d|0)>=(e|0)&f>>>0>=I[c+8>>2]|(d|0)>(e|0)){break a}e=G[F[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;d=e<<24>>24;if((d|0)<0){if(!Qd(a+1|0,b,c)){break a}e=d&127|F[b>>2]<<7;}F[b>>2]=e;g=1;}return g}function Oa(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=F[c+20>>2];e=F[c+12>>2];f=F[c+16>>2];if((d|0)>=(e|0)&f>>>0>=I[c+8>>2]|(d|0)>(e|0)){break a}e=G[F[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;d=e<<24>>24;if((d|0)<0){if(!Oa(a+1|0,b,c)){break a}e=d&127|F[b>>2]<<7;}F[b>>2]=e;g=1;}return g}function Da(a,b,c){var d=0,e=0,f=0,g=0;a:{if(a>>>0>5){break a}d=F[c+20>>2];e=F[c+12>>2];f=F[c+16>>2];if((d|0)>=(e|0)&f>>>0>=I[c+8>>2]|(d|0)>(e|0)){break a}e=G[F[c>>2]+f|0];f=f+1|0;d=f?d:d+1|0;F[c+16>>2]=f;F[c+20>>2]=d;d=e<<24>>24;if((d|0)<0){if(!Da(a+1|0,b,c)){break a}e=d&127|F[b>>2]<<7;}F[b>>2]=e;g=1;}return g}function sa(a,b,c){var d=0,e=0;a:{b:{if(c>>>0>=4){if((a|b)&3){break b}while(1){if(F[a>>2]!=F[b>>2]){break b}b=b+4|0;a=a+4|0;c=c-4|0;if(c>>>0>3){continue}break}}if(!c){break a}}while(1){d=G[a|0];e=G[b|0];if((d|0)==(e|0)){b=b+1|0;a=a+1|0;c=c-1|0;if(c){continue}break a}break}return d-e|0}return 0}function td(a){var b=0,c=0,d=0,e=0;d=F[a>>2];if(d){e=d;c=F[a+4>>2];if((d|0)!=(c|0)){while(1){e=c-144|0;b=F[e+132>>2];if(b){F[c-8>>2]=b;ja(b);}b=F[c-28>>2];if(b){F[c-24>>2]=b;ja(b);}b=F[c-40>>2];if(b){F[c-36>>2]=b;ja(b);}Gb(c-140|0);c=e;if((d|0)!=(c|0)){continue}break}e=F[a>>2];}F[a+4>>2]=d;ja(e);}}function Ef(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=F[b+4>>2];a:{if(!d){break a}b=F[F[F[b+8>>2]+(c<<2)>>2]+60>>2];if((b|0)<0){break a}a=F[d+24>>2];c=F[d+28>>2];if((a|0)==(c|0)){break a}b:{while(1){e=F[a>>2];if((b|0)==F[e+24>>2]){break b}a=a+4|0;if((c|0)!=(a|0)){continue}break}e=0;}}return e|0}function ic(a){var b=0,c=0,d=0;if(a){d=F[a+24>>2];if(d){b=d;c=F[a+28>>2];if((b|0)!=(c|0)){while(1){c=c-4|0;b=F[c>>2];F[c>>2]=0;if(b){Ca(b+12|0,F[b+16>>2]);Ba(b,F[b+4>>2]);ja(b);}if((c|0)!=(d|0)){continue}break}b=F[a+24>>2];}F[a+28>>2]=d;ja(b);}Ca(a+12|0,F[a+16>>2]);Ba(a,F[a+4>>2]);ja(a);}}function $g(a){a=a|0;var b=0;F[a+8>>2]=9136;F[a>>2]=8924;b=F[a+96>>2];if(b){F[a+100>>2]=b;ja(b);}b=F[a+80>>2];if(b){F[a+84>>2]=b;ja(b);}b=F[a+68>>2];if(b){F[a+72>>2]=b;ja(b);}b=F[a+56>>2];if(b){F[a+60>>2]=b;ja(b);}F[a+8>>2]=9372;b=F[a+44>>2];if(b){ja(b);}b=F[a+32>>2];if(b){ja(b);}return a|0}function _g(a){a=a|0;var b=0;F[a+8>>2]=9136;F[a>>2]=8924;b=F[a+96>>2];if(b){F[a+100>>2]=b;ja(b);}b=F[a+80>>2];if(b){F[a+84>>2]=b;ja(b);}b=F[a+68>>2];if(b){F[a+72>>2]=b;ja(b);}b=F[a+56>>2];if(b){F[a+60>>2]=b;ja(b);}F[a+8>>2]=9372;b=F[a+44>>2];if(b){ja(b);}b=F[a+32>>2];if(b){ja(b);}ja(a);}function wh(a){a=a|0;var b=0,c=0,d=0;F[a>>2]=10032;b=F[a+20>>2];if(b){F[a+24>>2]=b;ja(b);}d=F[a+8>>2];if(d){c=F[a+12>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=F[c>>2];F[c>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}if((c|0)!=(d|0)){continue}break}b=F[a+8>>2];}F[a+12>>2]=d;ja(b);}return a|0}function uc(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,g=0,h=0,i=0;h=F[c+8>>2];e=F[c+16>>2];g=F[c+12>>2];f=g;d=F[c+20>>2];if(h>>>0>e>>>0&(f|0)>=(d|0)|(d|0)<(f|0)){b=G[F[c>>2]+e|0];i=e+1|0;f=i?d:d+1|0;F[c+16>>2]=i;F[c+20>>2]=f;F[a+4>>2]=b;}return e>>>0<h>>>0&(d|0)<=(g|0)|(d|0)<(g|0)}function La(a,b,c){var d=0;if(!c){return F[a+4>>2]==F[b+4>>2]}if((a|0)==(b|0)){return 1}d=F[a+4>>2];a=G[d|0];c=F[b+4>>2];b=G[c|0];a:{if(!a|(b|0)!=(a|0)){break a}while(1){b=G[c+1|0];a=G[d+1|0];if(!a){break a}c=c+1|0;d=d+1|0;if((a|0)==(b|0)){continue}break}}return (a|0)==(b|0)}function Gg(a){a=a|0;var b=0,c=0,d=0;F[a>>2]=10032;b=F[a+20>>2];if(b){F[a+24>>2]=b;ja(b);}d=F[a+8>>2];if(d){c=F[a+12>>2];b=d;if((c|0)!=(b|0)){while(1){c=c-4|0;b=F[c>>2];F[c>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}if((c|0)!=(d|0)){continue}break}b=F[a+8>>2];}F[a+12>>2]=d;ja(b);}ja(a);}function Gf(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=F[b+12>>2];b=F[b+8>>2];a=0;a:{if((d|0)==(b|0)){break a}a=d-b>>2;d=a>>>0<=1?1:a;a=0;b:{while(1){e=F[b+(a<<2)>>2];if(F[e+60>>2]==(c|0)){break b}a=a+1|0;if((d|0)!=(a|0)){continue}break}a=0;break a}a=(a|0)!=-1?e:0;}return a|0}function ah(a){a=a|0;var b=0;F[a>>2]=9136;b=F[a+88>>2];if(b){F[a+92>>2]=b;ja(b);}b=F[a+72>>2];if(b){F[a+76>>2]=b;ja(b);}b=F[a+60>>2];if(b){F[a- -64>>2]=b;ja(b);}b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}F[a>>2]=9372;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}return a|0}function Tc(a,b){var c=0,d=0,e=0;F[a+8>>2]=0;F[a>>2]=0;F[a+4>>2]=0;a:{c=F[b+4>>2];d=F[b>>2];b:{if((c|0)==(d|0)){a=c;break b}c=c-d|0;if((c|0)<0){break a}d=c;e=ka(c);c=ma(e,0,c);d=d+c|0;F[a+8>>2]=d;F[a+4>>2]=d;F[a>>2]=c;c=F[b>>2];a=F[b+4>>2];}la(e,c,a-c|0);return}na();v();}function Dd(a){var b=0,c=0,d=0,e=0;c=F[a+4>>2];d=F[a>>2];if((c|0)!=(d|0)){while(1){e=c-144|0;b=F[e+132>>2];if(b){F[c-8>>2]=b;ja(b);}b=F[c-28>>2];if(b){F[c-24>>2]=b;ja(b);}b=F[c-40>>2];if(b){F[c-36>>2]=b;ja(b);}Gb(c-140|0);c=e;if((d|0)!=(c|0)){continue}break}}F[a+4>>2]=d;}function Xg(a){a=a|0;var b=0;F[a>>2]=9136;b=F[a+88>>2];if(b){F[a+92>>2]=b;ja(b);}b=F[a+72>>2];if(b){F[a+76>>2]=b;ja(b);}b=F[a+60>>2];if(b){F[a- -64>>2]=b;ja(b);}b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}F[a>>2]=9372;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}ja(a);}function Za(a){var b=0;if(a){b=F[a+76>>2];if(b){F[a+80>>2]=b;ja(b);}b=F[a- -64>>2];if(b){F[a+68>>2]=b;ja(b);}b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}b=F[a+24>>2];if(b){F[a+28>>2]=b;ja(b);}b=F[a+12>>2];if(b){F[a+16>>2]=b;ja(b);}b=F[a>>2];if(b){F[a+4>>2]=b;ja(b);}ja(a);}}function Gb(a){var b=0;b=F[a+84>>2];if(b){F[a+88>>2]=b;ja(b);}b=F[a+72>>2];if(b){F[a+76>>2]=b;ja(b);}b=F[a+52>>2];if(b){F[a+56>>2]=b;ja(b);}b=F[a+40>>2];if(b){F[a+44>>2]=b;ja(b);}b=F[a+28>>2];if(b){F[a+32>>2]=b;ja(b);}b=F[a+12>>2];if(b){ja(b);}a=F[a>>2];if(a){ja(a);}}function Lc(a,b,c){var d=0,e=0,f=0,g=0;f=Z-16|0;Z=f;d=Z-16|0;Z=d;b=b-a>>2;while(1){if(b){F[d+12>>2]=a;e=b>>>1|0;F[d+12>>2]=F[d+12>>2]+(e<<2);g=(e^-1)+b|0;b=e;e=I[F[d+12>>2]>>2]<I[c>>2];b=e?g:b;a=e?F[d+12>>2]+4|0:a;continue}break}Z=d+16|0;Z=f+16|0;return a}function id(a,b){var c=0,d=0;d=ka(40);F[d>>2]=-1;c=d+8|0;F[c+16>>2]=0;F[c+20>>2]=0;F[c+8>>2]=0;F[c>>2]=0;F[c+4>>2]=0;F[c+24>>2]=0;F[c+28>>2]=0;$[F[F[a>>2]+16>>2]](a,d);a=F[b+88>>2];F[b+88>>2]=d;if(a){b=F[a+8>>2];if(b){F[a+12>>2]=b;ja(b);}ja(a);}return 1}function ya(a){var b=0,c=0,d=0;b=a;a:{if(b&3){while(1){if(!G[b|0]){break a}b=b+1|0;if(b&3){continue}break}}while(1){c=b;b=b+4|0;d=F[c>>2];if(!((d^-1)&d-16843009&-2139062144)){continue}break}while(1){b=c;c=b+1|0;if(G[b|0]){continue}break}}return b-a|0}function wa(a){var b=0,c=0,d=0,e=0,f=0;d=G[a+12|0];c=F[a+8>>2];a:{if(c>>>0>4095){break a}b=F[a+4>>2];if((b|0)<=0){break a}b=b-1|0;F[a+4>>2]=b;c=G[b+F[a>>2]|0]|c<<8;}d=0-d&255;b=L(d,c>>>8|0);e=c&255;f=e>>>0<d>>>0;F[a+8>>2]=f?b+e|0:c-(b+d|0)|0;return f}function yc(a,b){F[a+4>>2]=0;F[a+8>>2]=0;F[a>>2]=1776;F[a+12>>2]=0;F[a+16>>2]=0;F[a+20>>2]=0;F[a+24>>2]=0;F[a+28>>2]=0;F[a+32>>2]=0;F[a+36>>2]=0;F[a+40>>2]=0;F[a>>2]=2016;F[a+60>>2]=b;F[a+44>>2]=0;F[a+48>>2]=0;F[a+52>>2]=0;F[a+56>>2]=0;return a}function Eb(a,b){var c=0,d=0,e=0;c=ya(b);if(c>>>0<2147483632){a:{b:{if(c>>>0>=11){d=(c|15)+1|0;e=ka(d);F[a+8>>2]=d|-2147483648;F[a>>2]=e;F[a+4>>2]=c;d=c+e|0;break b}D[a+11|0]=c;d=a+c|0;e=a;if(!c){break a}}pa(e,b,c);}D[d|0]=0;return a}za();v();}function Of(a){a=a|0;var b=0,c=0,d=0;if(a){if(D[a+27|0]<0){ja(F[a+16>>2]);}b=F[a>>2];if(b){c=b;d=F[a+4>>2];if((b|0)!=(d|0)){while(1){c=d-12|0;if(D[d-1|0]<0){ja(F[c>>2]);}d=c;if((d|0)!=(b|0)){continue}break}c=F[a>>2];}F[a+4>>2]=b;ja(c);}ja(a);}}function xa(a){a=a|0;var b=0,c=0;if(a){b=F[a+88>>2];F[a+88>>2]=0;if(b){c=F[b+8>>2];if(c){F[b+12>>2]=c;ja(c);}ja(b);}b=F[a+68>>2];if(b){F[a+72>>2]=b;ja(b);}b=F[a+64>>2];F[a+64>>2]=0;if(b){c=F[b>>2];if(c){F[b+4>>2]=c;ja(c);}ja(b);}ja(a);}}function Ib(a,b){var c=0,d=0,e=0;a:{c=F[a>>2];b:{if(F[a+8>>2]-c>>2>>>0>=b>>>0){break b}if(b>>>0>=1073741824){break a}d=F[a+4>>2]-c|0;e=b<<2;b=pa(ka(e),c,d);F[a+8>>2]=b+e;F[a+4>>2]=b+d;F[a>>2]=b;if(!c){break b}ja(c);}return}na();v();}function Df(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;b=F[b+96>>2];a=ka(12);b=b+L(c,12)|0;c=F[b+4>>2];F[a>>2]=F[b>>2];F[a+4>>2]=c;F[a+8>>2]=F[b+8>>2];b=F[d>>2];if(b){F[d+4>>2]=b;ja(b);}F[d>>2]=a;a=a+12|0;F[d+8>>2]=a;F[d+4>>2]=a;return 1}function Ah(a){a=a|0;var b=0;F[a+24>>2]=1624;F[a>>2]=7948;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}F[a>>2]=2136;b=F[a+20>>2];F[a+20>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}F[a>>2]=1920;b=F[a+16>>2];F[a+16>>2]=0;if(b){xa(b);}return a|0}function li(a,b,c,d){var e=0,f=0,g=0,h=0;f=b^d;g=f>>31;e=b>>31;a=a^e;h=a-e|0;e=(b^e)-((a>>>0<e>>>0)+e|0)|0;a=d>>31;b=c^a;f=f>>31;a=mi(h,e,b-a|0,(a^d)-((a>>>0>b>>>0)+a|0)|0)^f;b=a-f|0;_=(g^_)-((a>>>0<f>>>0)+g|0)|0;return b}function zh(a){a=a|0;var b=0;F[a+24>>2]=1624;F[a>>2]=7948;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}F[a>>2]=2136;b=F[a+20>>2];F[a+20>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}F[a>>2]=1920;b=F[a+16>>2];F[a+16>>2]=0;if(b){xa(b);}ja(a);}function rb(a,b,c){var d=0,e=0,f=0;e=Z-16|0;Z=e;d=F[a+8>>2]&2147483647;a:{if(d>>>0>c>>>0){d=F[a>>2];F[a+4>>2]=c;db(d,b,c);D[e+15|0]=0;D[c+d|0]=G[e+15|0];break a}f=a;a=F[a+4>>2];Gc(f,d-1|0,(c-d|0)+1|0,a,a,c,b);}Z=e+16|0;}function xe(a,b){a=a|0;b=b|0;var c=0,d=0;c=Z-16|0;Z=c;a=F[a+4>>2];a:{if((a|0)==-1){break a}D[c+15|0]=a;d=F[b+20>>2];if(!!F[b+16>>2]&(d|0)>=0|(d|0)>0){break a}pb(b,F[b+4>>2],c+15|0,c+16|0);}Z=c+16|0;return (a|0)!=-1|0}function ki(a,b,c,d){var e=0,f=0,g=0,h=0,i=0,j=0;e=c>>>16|0;f=a>>>16|0;j=L(e,f);g=c&65535;h=a&65535;i=L(g,h);f=(i>>>16|0)+L(f,g)|0;e=(f&65535)+L(e,h)|0;_=(L(b,c)+j|0)+L(a,d)+(f>>>16)+(e>>>16)|0;return i&65535|e<<16}function qb(a,b,c){var d=0,e=0;d=Z-16|0;Z=d;a:{if(c>>>0<=10){D[a+11|0]=G[a+11|0]&128|c;D[a+11|0]=G[a+11|0]&127;db(a,b,c);D[d+15|0]=0;D[a+c|0]=G[d+15|0];break a}e=a;a=G[a+11|0]&127;Gc(e,10,c-10|0,a,a,c,b);}Z=d+16|0;}function Ec(a,b,c){var d=0;d=F[a+16>>2];if(!d){F[a+36>>2]=1;F[a+24>>2]=c;F[a+16>>2]=b;return}a:{if((b|0)==(d|0)){if(F[a+24>>2]!=2){break a}F[a+24>>2]=c;return}D[a+54|0]=1;F[a+24>>2]=2;F[a+36>>2]=F[a+36>>2]+1;}}function vg(){var a=0;a=kb(ka(96));F[a+64>>2]=0;F[a+68>>2]=0;F[a+88>>2]=0;F[a+72>>2]=0;F[a+76>>2]=0;D[a+77|0]=0;D[a+78|0]=0;D[a+79|0]=0;D[a+80|0]=0;D[a+81|0]=0;D[a+82|0]=0;D[a+83|0]=0;D[a+84|0]=0;return a|0}function jh(a,b){a=a|0;b=b|0;var c=0,d=0;F[b>>2]=2;c=F[b+8>>2];d=F[b+12>>2]-c|0;if(d>>>0<=4294967291){Db(b+8|0,d+4|0);c=F[b+8>>2];}b=c+d|0;a=F[a+4>>2];D[b|0]=a;D[b+1|0]=a>>>8;D[b+2|0]=a>>>16;D[b+3|0]=a>>>24;}function ge(a){a=a|0;var b=0;F[a>>2]=3016;b=F[a+96>>2];if(b){ja(b);}b=F[a+84>>2];if(b){ja(b);}b=F[a+72>>2];if(b){ja(b);}b=F[a+60>>2];if(b){ja(b);}F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}return a|0}function ci(a){a=a|0;var b=0;F[a>>2]=4580;b=F[a+96>>2];if(b){ja(b);}b=F[a+84>>2];if(b){ja(b);}b=F[a+72>>2];if(b){ja(b);}b=F[a+60>>2];if(b){ja(b);}F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}return a|0}function Cg(a){a=a|0;var b=0,c=0,d=0;b=F[a+8>>2];d=F[a+12>>2];if((b|0)==(d|0)){return 1}while(1){c=F[b>>2];c=$[F[F[c>>2]+16>>2]](c,F[a+32>>2])|0;if(c){b=b+4|0;if((d|0)!=(b|0)){continue}}break}return c|0}function Pc(a,b){var c=0,d=0;c=F[a+8>>2];a=F[a+12>>2];if((c|0)!=(a|0)){a=a-c>>2;d=a>>>0<=1?1:a;a=0;while(1){if(F[F[(a<<2)+c>>2]+60>>2]==(b|0)){return a}a=a+1|0;if((d|0)!=(a|0)){continue}break}}return -1}function fe(a){a=a|0;var b=0;F[a>>2]=3016;b=F[a+96>>2];if(b){ja(b);}b=F[a+84>>2];if(b){ja(b);}b=F[a+72>>2];if(b){ja(b);}b=F[a+60>>2];if(b){ja(b);}F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}ja(a);}function bi(a){a=a|0;var b=0;F[a>>2]=4580;b=F[a+96>>2];if(b){ja(b);}b=F[a+84>>2];if(b){ja(b);}b=F[a+72>>2];if(b){ja(b);}b=F[a+60>>2];if(b){ja(b);}F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}ja(a);}function Sc(a,b,c){var d=0,e=0;d=a+4|0;a=Ya(a,b);a:{if((d|0)==(a|0)){break a}b=F[a+32>>2];d=F[a+28>>2];if((b|0)==(d|0)){break a}Sb(c,b-d|0);c=Tb(c);b=F[a+28>>2];la(c,b,F[a+32>>2]-b|0);e=1;}return e}function Kd(a){F[a+40>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;F[a>>2]=10032;F[a+12>>2]=0;F[a+16>>2]=0;F[a+20>>2]=0;F[a+24>>2]=0;F[a+28>>2]=0;F[a+32>>2]=0;E[a+36>>1]=0;F[a+44>>2]=0;F[a>>2]=8080;return a}function kb(a){F[a+8>>2]=0;F[a+12>>2]=0;F[a>>2]=0;F[a+40>>2]=0;F[a+44>>2]=0;F[a+28>>2]=9;D[a+24|0]=1;F[a+56>>2]=-1;F[a+60>>2]=0;F[a+16>>2]=0;F[a+20>>2]=0;F[a+48>>2]=0;F[a+52>>2]=0;return a}function pe(a,b){a=a|0;b=b|0;var c=0,d=0;d=F[a+16>>2];c=0;a:{if(F[a+20>>2]-d>>2<=(b|0)){break a}b=F[(b<<2)+d>>2];c=0;if((b|0)<0){break a}c=bb(F[F[a+36>>2]+(b<<2)>>2]);}return c|0}function Nf(){var a=0,b=0;a=ka(40);F[a+4>>2]=0;F[a+8>>2]=0;F[a+24>>2]=0;F[a+28>>2]=0;b=a+16|0;F[b>>2]=0;F[b+4>>2]=0;F[a>>2]=a+4;F[a+12>>2]=b;F[a+32>>2]=0;F[a+36>>2]=0;return a|0}function Xe(a,b){a=a|0;b=b|0;var c=0,d=0;Nc(a,b);a:{if((b|0)<0){break a}d=F[a+88>>2];c=F[a+84>>2];if(d-c>>2<=(b|0)){break a}c=(b<<2)+c|0;b=c+4|0;pa(c,b,d-b|0);F[a+88>>2]=d-4;}}function eb(a){var b=0,c=0;b=F[2909];c=a+7&-8;a=b+c|0;a:{if(a>>>0<=b>>>0?c:0){break a}if(a>>>0>aa()<<16>>>0){if(!(X(a|0)|0)){break a}}F[2909]=a;return b}F[2940]=48;return -1}function Th(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;F[a+4>>2]=b;b=F[F[F[b+4>>2]+8>>2]+(c<<2)>>2];F[a+12>>2]=c;F[a+8>>2]=b;a=F[a+8>>2];if(G[a+24|0]==3){d=F[a+28>>2]==9;}return d|0}function Tg(a){a=a|0;var b=0;F[a+8>>2]=9556;F[a>>2]=9392;b=F[a+56>>2];if(b){F[a+60>>2]=b;ja(b);}F[a+8>>2]=9372;b=F[a+44>>2];if(b){ja(b);}b=F[a+32>>2];if(b){ja(b);}return a|0}function Ng(a){a=a|0;var b=0;F[a+8>>2]=8624;F[a>>2]=9684;b=F[a+56>>2];if(b){F[a+60>>2]=b;ja(b);}F[a+8>>2]=8876;b=F[a+44>>2];if(b){ja(b);}b=F[a+32>>2];if(b){ja(b);}return a|0}function Ee(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0;d=F[a+8>>2];a:{if(!G[d+24|0]){break a}if(!ac(d,F[b+4>>2]-F[b>>2]>>2)){break a}e=$[F[F[a>>2]+32>>2]](a,b,c)|0;}return e|0}function Fh(a,b,c){a=a|0;b=b|0;c=c|0;var d=0;F[a+4>>2]=b;d=F[F[F[b+4>>2]+8>>2]+(c<<2)>>2];F[a+12>>2]=c;F[a+8>>2]=d;return F[F[F[F[b+4>>2]+8>>2]+(c<<2)>>2]+28>>2]==9|0}function Ca(a,b){if(b){Ca(a,F[b>>2]);Ca(a,F[b+4>>2]);a=F[b+28>>2];F[b+28>>2]=0;if(a){Ca(a+12|0,F[a+16>>2]);Ba(a,F[a+4>>2]);ja(a);}if(D[b+27|0]<0){ja(F[b+16>>2]);}ja(b);}}function Sg(a){a=a|0;var b=0;F[a+8>>2]=9556;F[a>>2]=9392;b=F[a+56>>2];if(b){F[a+60>>2]=b;ja(b);}F[a+8>>2]=9372;b=F[a+44>>2];if(b){ja(b);}b=F[a+32>>2];if(b){ja(b);}ja(a);}function Mg(a){a=a|0;var b=0;F[a+8>>2]=8624;F[a>>2]=9684;b=F[a+56>>2];if(b){F[a+60>>2]=b;ja(b);}F[a+8>>2]=8876;b=F[a+44>>2];if(b){ja(b);}b=F[a+32>>2];if(b){ja(b);}ja(a);}function Hc(a,b){var c=0,d=0,e=0,f=0;F[a>>2]=11356;F[a>>2]=11468;c=ya(b);d=ka(c+13|0);F[d+8>>2]=0;F[d+4>>2]=c;F[d>>2]=c;e=a,f=la(d+12|0,b,c+1|0),F[e+4>>2]=f;return a}function hc(a,b,c){a:{if(b){b=0;if(!ld(1,c,a)){break a}}D[a+36|0]=1;F[a+32>>2]=0;b=F[a+16>>2];c=b+F[a>>2]|0;F[a+24>>2]=c;F[a+28>>2]=c+(F[a+8>>2]-b|0);b=1;}return b}function Ue(a,b){a=a|0;b=b|0;var c=0;a:{if(!($[F[F[a>>2]+36>>2]](a,b)|0)){break a}if(!($[F[F[a>>2]+40>>2]](a,b)|0)){break a}c=$[F[F[a>>2]+44>>2]](a)|0;}return c|0}function _d(a){a=a|0;var b=0;a:{if(!F[a- -64>>2]|!F[a+68>>2]|(!F[a+44>>2]|!F[a+48>>2])){break a}if(!F[a+52>>2]|!F[a+56>>2]){break a}b=F[a+92>>2]!=-1;}return b|0}function ii(a,b){a=a|0;b=b|0;var c=0;b=F[b+88>>2];if(!(!b|F[b>>2]!=2)){c=a;a=F[b+8>>2];F[c+4>>2]=G[a|0]|G[a+1|0]<<8|(G[a+2|0]<<16|G[a+3|0]<<24);c=1;}return c|0}function wc(a){a=a|0;var b=0;F[a>>2]=2136;b=F[a+20>>2];F[a+20>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}F[a>>2]=1920;b=F[a+16>>2];F[a+16>>2]=0;if(b){xa(b);}return a|0}function Ud(a){a=a|0;var b=0;a:{if(!F[a+48>>2]|!F[a+52>>2]|(!F[a+28>>2]|!F[a+32>>2])){break a}if(!F[a+36>>2]|!F[a+40>>2]){break a}b=F[a+76>>2]!=-1;}return b|0}function Ug(a){a=a|0;var b=0;F[a>>2]=9556;b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}F[a>>2]=9372;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}return a|0}function Ed(a){a=a|0;var b=0;F[a>>2]=8624;b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}F[a>>2]=8876;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}return a|0}function vc(a){a=a|0;var b=0;F[a>>2]=2136;b=F[a+20>>2];F[a+20>>2]=0;if(b){$[F[F[b>>2]+4>>2]](b);}F[a>>2]=1920;b=F[a+16>>2];F[a+16>>2]=0;if(b){xa(b);}ja(a);}function yg(){var a=0,b=0;b=ka(40);F[b>>2]=-1;a=b+8|0;F[a+16>>2]=0;F[a+20>>2]=0;F[a+8>>2]=0;F[a>>2]=0;F[a+4>>2]=0;F[a+24>>2]=0;F[a+28>>2]=0;return b|0}function eh(a){a=a|0;var b=0;F[a>>2]=8624;b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}F[a>>2]=8876;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}ja(a);}function Og(a){a=a|0;var b=0;F[a>>2]=9556;b=F[a+48>>2];if(b){F[a+52>>2]=b;ja(b);}F[a>>2]=9372;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}ja(a);}function Ja(a){F[a+8>>2]=0;F[a+12>>2]=0;F[a>>2]=0;F[a+16>>2]=0;F[a+20>>2]=0;F[a+32>>2]=0;F[a+24>>2]=0;F[a+28>>2]=0;E[a+38>>1]=0;D[a+36|0]=0;return a}function Me(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(La(a,F[b+8>>2],f)){Dc(b,c,d,e);return}a=F[a+8>>2];$[F[F[a>>2]+20>>2]](a,b,c,d,e,f);}function Eh(a,b,c){a=a|0;b=b|0;a:{if(G[F[a+4>>2]+36|0]>=2){b=0;if(!($[F[F[a>>2]+52>>2]](a)|0)){break a}}b=id(a+24|0,F[a+16>>2]);}return b|0}function hg(){var a=0;a=Rc(ka(108));F[a+84>>2]=0;F[a+88>>2]=0;F[a>>2]=10240;F[a+92>>2]=0;F[a+96>>2]=0;F[a+100>>2]=0;F[a+104>>2]=0;return a|0}function Qc(a,b){var c=0;c=-1;a:{if((b|0)==-1|(b|0)>4){break a}b=L(b,12)+a|0;a=F[b+20>>2];if((F[b+24>>2]-a|0)<=0){break a}c=F[a>>2];}return c}function cc(a,b,c,d,e,f,g){F[a>>2]=0;F[a+56>>2]=b;F[a+48>>2]=0;F[a+52>>2]=0;F[a+40>>2]=f;F[a+44>>2]=g;D[a+32|0]=e;F[a+28>>2]=d;D[a+24|0]=c;}function Sh(a,b,c){a=a|0;b=b|0;c=c|0;a:{if(G[F[a+4>>2]+36|0]>=2){b=0;if(!uc(a+24|0,bb(a),c)){break a}}b=id(a+24|0,F[a+16>>2]);}return b|0}function _e(a){a=a|0;var b=0;F[a>>2]=10240;b=F[a+96>>2];if(b){F[a+100>>2]=b;ja(b);}b=F[a+84>>2];if(b){F[a+88>>2]=b;ja(b);}return tb(a)|0}function Tb(a){var b=0;if(G[a+11|0]>>>7|0){b=F[a+4>>2];}else {b=G[a+11|0]&127;}if(!b){sc(1222);v();}if(G[a+11|0]>>>7|0){a=F[a>>2];}return a}function Ze(a){a=a|0;var b=0;F[a>>2]=10240;b=F[a+96>>2];if(b){F[a+100>>2]=b;ja(b);}b=F[a+84>>2];if(b){F[a+88>>2]=b;ja(b);}ja(tb(a));}function ce(a){a=a|0;var b=0;F[a>>2]=3264;b=F[a+76>>2];if(b){ja(b);}F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}return a|0}function _h(a){a=a|0;var b=0;F[a>>2]=4816;b=F[a+76>>2];if(b){ja(b);}F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}return a|0}function Ba(a,b){if(b){Ba(a,F[b>>2]);Ba(a,F[b+4>>2]);a=F[b+28>>2];if(a){F[b+32>>2]=a;ja(a);}if(D[b+27|0]<0){ja(F[b+16>>2]);}ja(b);}}function Wf(){var a=0;a=ka(28);F[a>>2]=0;F[a+4>>2]=0;F[a+24>>2]=0;F[a+16>>2]=0;F[a+20>>2]=0;F[a+8>>2]=0;F[a+12>>2]=0;return a|0}function We(a){a=a|0;var b=0;F[a>>2]=1776;b=F[a+16>>2];if(b){F[a+20>>2]=b;ja(b);}b=F[a+4>>2];if(b){F[a+8>>2]=b;ja(b);}return a|0}function fg(){var a=0,b=0;a=ka(24);F[a+4>>2]=0;F[a+8>>2]=0;b=a+16|0;F[b>>2]=0;F[b+4>>2]=0;F[a>>2]=a+4;F[a+12>>2]=b;return a|0}function Pe(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;if(La(a,F[b+8>>2],0)){Ec(b,c,d);return}a=F[a+8>>2];$[F[F[a>>2]+28>>2]](a,b,c,d);}function be(a){a=a|0;var b=0;F[a>>2]=3264;b=F[a+76>>2];if(b){ja(b);}F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}ja(a);}function Zh(a){a=a|0;var b=0;F[a>>2]=4816;b=F[a+76>>2];if(b){ja(b);}F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}ja(a);}function ka(a){var b=0;a=a?a:1;a:{while(1){b=Ub(a);if(b){break a}b=F[3065];if(b){$[b|0]();continue}break}V();v();}return b}function ib(a,b){if(b){ib(a,F[b>>2]);ib(a,F[b+4>>2]);if(D[b+39|0]<0){ja(F[b+28>>2]);}if(D[b+27|0]<0){ja(F[b+16>>2]);}ja(b);}}function Cc(a){a=a|0;var b=0,c=0;F[a>>2]=11468;b=F[a+4>>2]-12|0;c=F[b+8>>2]-1|0;F[b+8>>2]=c;if((c|0)<0){ja(b);}return a|0}function ng(){var a=0;a=ka(24);F[a+8>>2]=0;F[a+12>>2]=0;F[a+4>>2]=-1;F[a>>2]=1624;F[a+16>>2]=0;F[a+20>>2]=0;return a|0}function Ac(a,b,c){a=a|0;b=b|0;c=c|0;F[a+4>>2]=b;b=F[F[F[b+4>>2]+8>>2]+(c<<2)>>2];F[a+12>>2]=c;F[a+8>>2]=b;return 1}function pc(a){a=a|0;var b=0;if(!(!F[a+60>>2]|!F[a+44>>2]|(!F[a+48>>2]|!F[a+52>>2]))){b=F[a+56>>2]!=0;}return b|0}function Ic(a,b){if(G[a+11|0]>>>7|0){F[a+4>>2]=b;return}D[a+11|0]=G[a+11|0]&128|b;D[a+11|0]=G[a+11|0]&127;}function gi(a){a=a|0;var b=0;F[a>>2]=3500;F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}return a|0}function Xh(a){a=a|0;var b=0;F[a>>2]=5040;F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}return a|0}function nf(a){a=a|0;if(a){if(D[a+39|0]<0){ja(F[a+28>>2]);}$b(a+12|0,F[a+16>>2]);ib(a,F[a+4>>2]);ja(a);}}function dh(a){a=a|0;var b=0;F[a>>2]=8876;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}return a|0}function Wg(a){a=a|0;var b=0;F[a>>2]=9372;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}return a|0}function ob(a){a=a|0;var b=0;if(!(!F[a+52>>2]|(!F[a+44>>2]|!F[a+48>>2]))){b=F[a+56>>2]!=0;}return b|0}function oc(a,b){a=a|0;b=b|0;var c=0;if(!(F[b+56>>2]|!b|G[b+24|0]!=3)){F[a+60>>2]=b;c=1;}return c|0}function fi(a){a=a|0;var b=0;F[a>>2]=3500;F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}ja(a);}function Wh(a){a=a|0;var b=0;F[a>>2]=5040;F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}ja(a);}function zg(a,b,c){a=a|0;b=b|0;c=c|0;F[a+16>>2]=0;F[a+20>>2]=0;F[a>>2]=b;F[a+8>>2]=c;F[a+12>>2]=0;}function ch(a){a=a|0;var b=0;F[a>>2]=8876;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}ja(a);}function Zd(a,b){a=a|0;b=b|0;var c=0;if(!(F[b+56>>2]|G[b+24|0]!=3)){F[a- -64>>2]=b;c=1;}return c|0}function Vg(a){a=a|0;var b=0;F[a>>2]=9372;b=F[a+36>>2];if(b){ja(b);}b=F[a+24>>2];if(b){ja(b);}ja(a);}function Td(a,b){a=a|0;b=b|0;var c=0;if(!(F[b+56>>2]|G[b+24|0]!=3)){F[a+48>>2]=b;c=1;}return c|0}function Le(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;if(La(a,F[b+8>>2],f)){Dc(b,c,d,e);}}function oa(){var a=0;a=Rb(4);F[a>>2]=11356;F[a>>2]=11316;F[a>>2]=11336;W(a|0,11448,14);v();}function je(a){a=a|0;var b=0;F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}return a|0}function Ae(a){a=a|0;var b=0;F[a>>2]=1920;b=F[a+16>>2];F[a+16>>2]=0;if(b){xa(b);}return a|0}function Pg(a){a=a|0;var b=0;F[a>>2]=1624;b=F[a+8>>2];if(b){F[a+12>>2]=b;ja(b);}return a|0}function Ch(a){a=a|0;var b=0;b=bb(a);return qd(a+24|0,b?b:F[a+8>>2],F[F[a+4>>2]+32>>2])|0}function ze(a){a=a|0;var b=0;F[a>>2]=1920;b=F[a+16>>2];F[a+16>>2]=0;if(b){xa(b);}ja(a);}function Ob(a){a=a|0;var b=0;F[a>>2]=2960;b=F[a+32>>2];if(b){F[a+36>>2]=b;ja(b);}ja(a);}function Hg(a){a=a|0;var b=0;F[a>>2]=1624;b=F[a+8>>2];if(b){F[a+12>>2]=b;ja(b);}ja(a);}function oe(a,b){a=a|0;b=b|0;return $[F[F[a>>2]+48>>2]](a,F[b+4>>2]-F[b>>2]>>2)|0}function $b(a,b){if(b){$b(a,F[b>>2]);$b(a,F[b+4>>2]);ib(b+20|0,F[b+24>>2]);ja(b);}}function xg(a){a=a|0;var b=0;if(a){b=F[a+8>>2];if(b){F[a+12>>2]=b;ja(b);}ja(a);}}function xh(a){a=a|0;if(!F[a+44>>2]){return 0}return $[F[F[a>>2]+48>>2]](a)|0}function ni(a){var b=0;while(1){if(a){a=a-1&a;b=b+1|0;continue}break}return b}function Qe(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;if(La(a,F[b+8>>2],0)){Ec(b,c,d);}}function vh(a,b){a=a|0;b=b|0;a=F[a+48>>2];return $[F[F[a>>2]+20>>2]](a,b)|0}function oi(a){var b=0;b=a&31;a=0-a&31;return (-1>>>b&-2)<<b|(-1<<a&-2)>>>a}
function oh(a,b){a=a|0;b=b|0;a=F[a+48>>2];return $[F[F[a>>2]+12>>2]](a,b)|0}function nh(a,b){a=a|0;b=b|0;a=F[a+48>>2];return $[F[F[a>>2]+16>>2]](a,b)|0}function Xa(){var a=0;a=ka(12);F[a>>2]=0;F[a+4>>2]=0;F[a+8>>2]=0;return a|0}function Wa(a){a=a|0;var b=0;if(a){b=F[a>>2];if(b){F[a+4>>2]=b;ja(b);}ja(a);}}function mf(a,b,c){a=a|0;b=b|0;c=c|0;F[a+32>>2]=c;F[a+28>>2]=b;return 1}function eg(a){a=a|0;if(a){Ca(a+12|0,F[a+16>>2]);Ba(a,F[a+4>>2]);ja(a);}}function Lb(a,b){a=a|0;b=b|0;if(b>>>0<=1){F[a+28>>2]=b;}return b>>>0<2|0}function Fg(a,b){b=b|0;D[b+84|0]=1;F[b+72>>2]=F[b+68>>2];return 1}function kg(){var a=0;a=ka(8);F[a+4>>2]=-1;F[a>>2]=1032;return a|0}function Hf(a,b,c){b=b|0;c=c|0;return F[F[b+8>>2]+(c<<2)>>2]}function th(a){a=a|0;a=F[a+48>>2];return $[F[F[a>>2]+24>>2]](a)|0}function sh(a){a=a|0;a=F[a+48>>2];return $[F[F[a>>2]+28>>2]](a)|0}function ph(a){a=a|0;a=F[a+48>>2];return $[F[F[a>>2]+36>>2]](a)|0}function Rh(a,b){a=a|0;return zc(a+24|0,bb(a),F[a+8>>2])|0}function Bh(a,b){a=a|0;return xd(a+24|0,bb(a),F[a+8>>2])|0}function bg(a){a=a|0;if(a){if(D[a+15|0]<0){ja(F[a+4>>2]);}ja(a);}}function Ke(a){a=a|0;if(!a){return 0}return (Fc(a,11164)|0)!=0|0}function Fe(a,b){a=a|0;b=b|0;F[a+12>>2]=-1;F[a+8>>2]=b;return 1}function hd(a,b){a=a|0;b=b|0;return $[F[F[a>>2]+12>>2]](a,b)|0}function Dh(a,b){a=a|0;b=b|0;return $[F[F[a>>2]+56>>2]](a,b)|0}function sc(a){a=Hc(Rb(8),a);F[a>>2]=11568;W(a|0,11600,1);v();}function mg(a,b){a=a|0;b=b|0;return M(J[F[a+8>>2]+(b<<2)>>2])}function Rd(a){a=Hc(Rb(8),a);F[a>>2]=11516;W(a|0,11548,1);v();}function $f(a,b){a=a|0;b=b|0;return M(J[F[a>>2]+(b<<2)>>2])}function gg(a){a=a|0;return (F[a+100>>2]-F[a+96>>2]|0)/12|0}function cg(a){a=a|0;return (D[a+15|0]<0?F[a+4>>2]:a+4|0)|0}function Re(a,b){a=a|0;b=b|0;return F[F[a+4>>2]+(b<<2)>>2]}function dd(a,b){a=a|0;b=b|0;return F[F[a>>2]+(b<<2)>>2]}function Yf(a,b){a=a|0;b=b|0;return E[F[a>>2]+(b<<1)>>1]}function Xf(a,b){a=a|0;b=b|0;return H[F[a>>2]+(b<<1)>>1]}function Vd(a,b,c){a=a|0;b=b|0;c=c|0;return xc(a,b,c)|0}function sb(a,b){var c=0;c=ka(b);F[a+4>>2]=b;F[a>>2]=c;}function Kf(a,b,c){b=b|0;c=c|0;return Qc(b,c)|0}function Rc(a){F[a>>2]=10300;ma(a+4|0,0,80);return a}function ji(a){if(a){return 31-O(a-1^a)|0}return 32}function gd(a){a=a|0;return F[a+12>>2]-F[a+8>>2]>>2}function _f(a,b){a=a|0;b=b|0;return D[F[a>>2]+b|0]}function Zf(a,b){a=a|0;b=b|0;return G[F[a>>2]+b|0]}function Ie(a){a=a|0;return F[a+8>>2]-F[a+4>>2]>>2}function wb(a){a=a|0;if(a){$[F[F[a>>2]+4>>2]](a);}}function Jd(a,b){a=a|0;b=b|0;F[a+4>>2]=b;return 1}function ed(a){a=a|0;return F[a+4>>2]-F[a>>2]>>1}function dc(a){a=a|0;return F[a+4>>2]-F[a>>2]>>2}function fd(a){a=a|0;return F[a+4>>2]-F[a>>2]|0}function ke(a){a=a|0;return G[F[a+8>>2]+24|0]}function Qf(a,b){b=b|0;return F[b+8>>2]}function Ff(a,b){b=b|0;return F[b+4>>2]}function De(a,b,c){return 1}function Bg(a,b){b=b|0;return G[b+24|0]}function Oh(a){a=a|0;F[a>>2]=5928;return a|0}function Jh(a){a=a|0;F[a>>2]=6932;return a|0}function lg(a){a=a|0;return M(J[a+20>>2])}function Nh(a){a=a|0;F[a>>2]=5928;ja(a);}function Ih(a){a=a|0;F[a>>2]=6932;ja(a);}function ug(a){a=a|0;return F[a+88>>2]}function tg(a){a=a|0;return F[a+56>>2]}function qg(a){a=a|0;return F[a+40>>2]}function pg(a){a=a|0;return F[a+48>>2]}function og(a){a=a|0;return F[a+60>>2]}function ec(a){a=a|0;return F[a+80>>2]}function cb(a){a=a|0;return F[a+28>>2]}function vd(a){a=a|0;return F[a+8>>2]}function tc(a,b){return -1}function sg(a){a=a|0;return D[a+24|0]}function rg(a){a=a|0;return G[a+32|0]}function dg(a){a=a|0;return !F[a>>2]|0}function Wd(a,b){return 6}function Va(a){a=a|0;return F[a+4>>2]}function Rb(a){return Ub(a+80|0)+80|0}function Qh(a,b){return 2}function Ia(a,b){return 0}function Bc(a,b){return 1}function jd(a){a=a|0;return F[a>>2]}function wg(){return kb(ka(64))|0}function ig(){return Rc(ka(84))|0}function fc(a){a=a|0;if(a){ja(a);}}function Ag(){return Ja(ka(40))|0}function Qb(a){a=a|0;Cc(a);ja(a);}function Je(a){return 1161}function He(a){return 1235}function Ge(a){return 1201}function Pa(a){a=a|0;return a|0}function hh(a){a=a|0;ja(ud(a));}function gh(a){a=a|0;ja(sd(a));}function Ve(a){a=a|0;ja(tb(a));}function ua(a){return 1}function rc(a){return 4}function qc(a){return 5}function Xd(a){return 2}function Ua(a){return 0}function Nb(a){return 6}function Mh(a){return 3}function za(){Rd(1222);v();}function ta(){sc(1154);v();}function na(){Rd(1154);v();}function Ha(a){a=a|0;ja(a);}function Ra(a){v();}function ff(){return 10}function ef(){return 11}function df(){return 12}function vb(){return -1}function ub(){return 1}function lf(){return 5}function kf(){return 6}function jf(){return 7}function jb(){return 0}function hf(){return 8}function gf(){return 9}function cf(){return -2}function bf(){return -3}function bd(){return 3}function af(){return -4}function ad(){return 4}function _b(){return 2}function $e(){return -5}function Te(){V();v();}function Jc(a){}function ae(){}
// EMSCRIPTEN_END_FUNCS
e=G;p();var $=c([null,Cc,Pa,Ha,Xd,ii,jh,ag,zc,xe,uc,jg,Wd,Qh,Pa,Pg,Hg,ua,yh,mh,kh,xd,fh,qd,Wd,Bg,We,Ra,mf,$c,Ue,Re,Ie,cb,Ia,Te,Bc,ua,Ae,ze,Ac,Fe,Ee,De,Bc,Ce,Be,re,qe,ye,we,pe,ve,ue,te,se,wc,vc,Ac,oe,ne,xc,me,ke,le,je,Ob,ua,Va,ob,Ua,tc,Ia,Ua,ua,ie,he,Ra,Ra,ge,fe,rc,ob,ee,de,ce,be,qc,pc,ua,Ia,oc,$d,hi,gi,fi,Nb,_d,ua,Ia,Zd,Yd,ei,Pa,Ha,Lb,cb,Mb,Ra,Ob,ua,ob,di,Ra,ci,bi,rc,ob,ai,$h,_h,Zh,qc,pc,ua,Ia,oc,$d,Yh,Xh,Wh,Nb,_d,ua,Ia,Zd,Yd,Vh,Pa,Ha,Lb,cb,Kb,Ra,Ob,Ua,ua,Uh,wc,vc,Th,Sh,Vd,Ph,Xd,Rh,Oh,Nh,Nb,Va,Ud,ua,Ia,Td,ua,Mh,Sd,Lh,Pa,Ha,Lb,cb,Mb,Jh,Ih,Nb,Ud,ua,Ia,Td,Sd,Hh,Pa,Ha,Lb,cb,Kb,Pa,Ha,Ua,ua,Ua,tc,Ia,Kh,Gh,Ah,zh,Fh,Eh,Vd,Dh,Ch,Bh,wh,Ra,ua,ua,xh,Dg,Cg,ua,Ua,Ia,Ia,rh,qh,uh,vh,sh,ph,oh,nh,th,ud,hh,Jd,Id,Hd,Gd,lh,ua,Va,vd,sd,gh,Jd,Id,Hd,Gd,ih,ua,Va,vd,Ed,eh,Fd,dh,ch,$g,_g,Zg,Yg,ah,Xg,bh,Wg,Vg,Tg,Sg,Rg,Qg,Ug,Og,Ng,Mg,Lg,Kg,Gg,Ig,Jg,Pa,Ha,Fg,Eg,Ra,Ua,ua,_e,Ze,Ye,Xe,tb,Ve,Oc,Nc,Pa,Ha,Jc,Jc,Se,Le,Ne,Qe,Ha,Me,Oe,Pe,Ha,He,Ha,Ge,Ha,Je,Qb,Va,Qb,Qb]);function aa(){return C.byteLength/65536|0}function fa(ga){ga=ga|0;var ba=aa()|0;var ca=ba+ga|0;if(ba<ca&&ca<65536){var da=new ArrayBuffer(L(ca,65536));var ea=new Int8Array(da);ea.set(D);D=new Int8Array(da);E=new Int16Array(da);F=new Int32Array(da);G=new Uint8Array(da);H=new Uint16Array(da);I=new Uint32Array(da);J=new Float32Array(da);K=new Float64Array(da);C=da;B.buffer=C;e=G;}return ba}return {"f":ae,"g":$,"h":fc,"i":Ag,"j":zg,"k":fc,"l":yg,"m":jd,"n":xg,"o":wg,"p":fc,"q":vg,"r":ec,"s":ug,"t":tg,"u":cb,"v":sg,"w":rg,"x":qg,"y":pg,"z":og,"A":xa,"B":ng,"C":hd,"D":Va,"E":mg,"F":lg,"G":wb,"H":kg,"I":hd,"J":Va,"K":wb,"L":ig,"M":gd,"N":ec,"O":wb,"P":hg,"Q":gg,"R":gd,"S":ec,"T":wb,"U":fg,"V":eg,"W":jd,"X":dg,"Y":cg,"Z":bg,"_":Xa,"$":$f,"aa":dc,"ba":Wa,"ca":Xa,"da":_f,"ea":fd,"fa":Wa,"ga":Xa,"ha":Zf,"ia":fd,"ja":Wa,"ka":Xa,"la":Yf,"ma":ed,"na":Wa,"oa":Xa,"pa":Xf,"qa":ed,"ra":Wa,"sa":Xa,"ta":dd,"ua":dc,"va":Wa,"wa":Xa,"xa":dd,"ya":dc,"za":Wa,"Aa":Wf,"Ba":Vf,"Ca":Uf,"Da":Tf,"Ea":Sf,"Fa":Rf,"Ga":Qf,"Ha":Pf,"Ia":Of,"Ja":Nf,"Ka":Mf,"La":Lf,"Ma":Kf,"Na":Jf,"Oa":If,"Pa":Hf,"Qa":Gf,"Ra":Ff,"Sa":Ef,"Ta":Df,"Ua":Cf,"Va":Bf,"Wa":Af,"Xa":zf,"Ya":yf,"Za":cd,"_a":xf,"$a":wf,"ab":vf,"bb":uf,"cb":cd,"db":tf,"eb":sf,"fb":rf,"gb":qf,"hb":pf,"ib":of,"jb":nf,"kb":vb,"lb":jb,"mb":ub,"nb":_b,"ob":vb,"pb":jb,"qb":ub,"rb":_b,"sb":bd,"tb":ad,"ub":vb,"vb":jb,"wb":ub,"xb":jb,"yb":ub,"zb":_b,"Ab":bd,"Bb":ad,"Cb":lf,"Db":kf,"Eb":jf,"Fb":hf,"Gb":gf,"Hb":ff,"Ib":ef,"Jb":df,"Kb":jb,"Lb":vb,"Mb":cf,"Nb":bf,"Ob":af,"Pb":$e,"Qb":Ub,"Rb":ja,"Sb":Ke}}return ha(ia)}
// EMSCRIPTEN_END_ASM


)(info);},instantiate:function(binary,info){return {then:function(ok){var module=new WebAssembly.Module(binary);ok({"instance":new WebAssembly.Instance(module,info)});}}},RuntimeError:Error};wasmBinary=[];if(typeof WebAssembly!="object"){abort("no native wasm support detected");}var wasmMemory;var ABORT=false;function assert(condition,text){if(!condition){abort(text);}}var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2;}else {u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63;}if(u0<65536){str+=String.fromCharCode(u0);}else {var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023);}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023;}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u;}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63;}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}else {if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63;}}heap[outIdx]=0;return outIdx-startIdx}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var c=str.charCodeAt(i);if(c<=127){len++;}else if(c<=2047){len+=2;}else if(c>=55296&&c<=57343){len+=4;++i;}else {len+=3;}}return len}var HEAP8,HEAPU8,HEAP32,HEAPU32;function updateMemoryViews(){var b=wasmMemory.buffer;Module["HEAP8"]=HEAP8=new Int8Array(b);Module["HEAP16"]=new Int16Array(b);Module["HEAP32"]=HEAP32=new Int32Array(b);Module["HEAPU8"]=HEAPU8=new Uint8Array(b);Module["HEAPU16"]=new Uint16Array(b);Module["HEAPU32"]=HEAPU32=new Uint32Array(b);Module["HEAPF32"]=new Float32Array(b);Module["HEAPF64"]=new Float64Array(b);}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;assert(INITIAL_MEMORY>=65536,"INITIAL_MEMORY should be larger than STACK_SIZE, was "+INITIAL_MEMORY+"! (STACK_SIZE="+65536+")");if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"];}else {wasmMemory=new WebAssembly.Memory({"initial":INITIAL_MEMORY/65536,"maximum":2147483648/65536});}updateMemoryViews();INITIAL_MEMORY=wasmMemory.buffer.byteLength;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift());}}callRuntimeCallbacks(__ATPRERUN__);}function initRuntime(){runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__);}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift());}}callRuntimeCallbacks(__ATPOSTRUN__);}function addOnPreRun(cb){__ATPRERUN__.unshift(cb);}function addOnInit(cb){__ATINIT__.unshift(cb);}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb);}var runDependencies=0;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies);}if(runDependencies==0){if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback();}}}function abort(what){if(Module["onAbort"]){Module["onAbort"](what);}what="Aborted("+what+")";err(what);ABORT=true;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="draco_decoder_gltf.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile);}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}var binary=tryParseAsDataURI(file);if(binary){return binary}if(readBinary){return readBinary(file)}throw "both async and sync fetching of the wasm failed"}catch(err){abort(err);}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB)){if(typeof fetch=="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw "failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else {if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response));},reject);})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"a":wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;Module["asm"]["g"];addOnInit(Module["asm"]["f"]);removeRunDependency();}addRunDependency();function receiveInstantiationResult(result){receiveInstance(result["instance"]);}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason);})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else {return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);readyPromiseReject(e);}}instantiateAsync().catch(readyPromiseReject);return {}}function callRuntimeCallbacks(callbacks){while(callbacks.length>0){callbacks.shift()(Module);}}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-24;this.set_type=function(type){HEAPU32[this.ptr+4>>2]=type;};this.get_type=function(){return HEAPU32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAPU32[this.ptr+8>>2]=destructor;};this.get_destructor=function(){return HEAPU32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount;};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught;};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown;};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_adjusted_ptr(0);this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false);};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1;};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;return prev===1};this.set_adjusted_ptr=function(adjustedPtr){HEAPU32[this.ptr+16>>2]=adjustedPtr;};this.get_adjusted_ptr=function(){return HEAPU32[this.ptr+16>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_type());if(isPointer){return HEAPU32[this.excPtr>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.excPtr};}function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);throw ptr}function _abort(){abort("");}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num);}function getHeapMax(){return 2147483648}function emscripten_realloc_buffer(size){var b=wasmMemory.buffer;try{wasmMemory.grow(size-b.byteLength+65535>>>16);updateMemoryViews();return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function intArrayFromString(stringy,dontAddNull,length){var len=lengthBytesUTF8(stringy)+1;var u8array=new Array(len);stringToUTF8Array(stringy,u8array,0,u8array.length);return u8array}var decodeBase64=typeof atob=="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2);}if(enc4!==64){output=output+String.fromCharCode(chr3);}}while(i<input.length);return output};function intArrayFromBase64(s){try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i);}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}var wasmImports={"c":___cxa_throw,"b":_abort,"e":_emscripten_memcpy_big,"d":_emscripten_resize_heap,"a":wasmMemory};createWasm();var _emscripten_bind_VoidPtr___destroy___0=Module["_emscripten_bind_VoidPtr___destroy___0"]=function(){return (_emscripten_bind_VoidPtr___destroy___0=Module["_emscripten_bind_VoidPtr___destroy___0"]=Module["asm"]["h"]).apply(null,arguments)};var _emscripten_bind_DecoderBuffer_DecoderBuffer_0=Module["_emscripten_bind_DecoderBuffer_DecoderBuffer_0"]=function(){return (_emscripten_bind_DecoderBuffer_DecoderBuffer_0=Module["_emscripten_bind_DecoderBuffer_DecoderBuffer_0"]=Module["asm"]["i"]).apply(null,arguments)};var _emscripten_bind_DecoderBuffer_Init_2=Module["_emscripten_bind_DecoderBuffer_Init_2"]=function(){return (_emscripten_bind_DecoderBuffer_Init_2=Module["_emscripten_bind_DecoderBuffer_Init_2"]=Module["asm"]["j"]).apply(null,arguments)};var _emscripten_bind_DecoderBuffer___destroy___0=Module["_emscripten_bind_DecoderBuffer___destroy___0"]=function(){return (_emscripten_bind_DecoderBuffer___destroy___0=Module["_emscripten_bind_DecoderBuffer___destroy___0"]=Module["asm"]["k"]).apply(null,arguments)};var _emscripten_bind_AttributeTransformData_AttributeTransformData_0=Module["_emscripten_bind_AttributeTransformData_AttributeTransformData_0"]=function(){return (_emscripten_bind_AttributeTransformData_AttributeTransformData_0=Module["_emscripten_bind_AttributeTransformData_AttributeTransformData_0"]=Module["asm"]["l"]).apply(null,arguments)};var _emscripten_bind_AttributeTransformData_transform_type_0=Module["_emscripten_bind_AttributeTransformData_transform_type_0"]=function(){return (_emscripten_bind_AttributeTransformData_transform_type_0=Module["_emscripten_bind_AttributeTransformData_transform_type_0"]=Module["asm"]["m"]).apply(null,arguments)};var _emscripten_bind_AttributeTransformData___destroy___0=Module["_emscripten_bind_AttributeTransformData___destroy___0"]=function(){return (_emscripten_bind_AttributeTransformData___destroy___0=Module["_emscripten_bind_AttributeTransformData___destroy___0"]=Module["asm"]["n"]).apply(null,arguments)};var _emscripten_bind_GeometryAttribute_GeometryAttribute_0=Module["_emscripten_bind_GeometryAttribute_GeometryAttribute_0"]=function(){return (_emscripten_bind_GeometryAttribute_GeometryAttribute_0=Module["_emscripten_bind_GeometryAttribute_GeometryAttribute_0"]=Module["asm"]["o"]).apply(null,arguments)};var _emscripten_bind_GeometryAttribute___destroy___0=Module["_emscripten_bind_GeometryAttribute___destroy___0"]=function(){return (_emscripten_bind_GeometryAttribute___destroy___0=Module["_emscripten_bind_GeometryAttribute___destroy___0"]=Module["asm"]["p"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_PointAttribute_0=Module["_emscripten_bind_PointAttribute_PointAttribute_0"]=function(){return (_emscripten_bind_PointAttribute_PointAttribute_0=Module["_emscripten_bind_PointAttribute_PointAttribute_0"]=Module["asm"]["q"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_size_0=Module["_emscripten_bind_PointAttribute_size_0"]=function(){return (_emscripten_bind_PointAttribute_size_0=Module["_emscripten_bind_PointAttribute_size_0"]=Module["asm"]["r"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_GetAttributeTransformData_0=Module["_emscripten_bind_PointAttribute_GetAttributeTransformData_0"]=function(){return (_emscripten_bind_PointAttribute_GetAttributeTransformData_0=Module["_emscripten_bind_PointAttribute_GetAttributeTransformData_0"]=Module["asm"]["s"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_attribute_type_0=Module["_emscripten_bind_PointAttribute_attribute_type_0"]=function(){return (_emscripten_bind_PointAttribute_attribute_type_0=Module["_emscripten_bind_PointAttribute_attribute_type_0"]=Module["asm"]["t"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_data_type_0=Module["_emscripten_bind_PointAttribute_data_type_0"]=function(){return (_emscripten_bind_PointAttribute_data_type_0=Module["_emscripten_bind_PointAttribute_data_type_0"]=Module["asm"]["u"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_num_components_0=Module["_emscripten_bind_PointAttribute_num_components_0"]=function(){return (_emscripten_bind_PointAttribute_num_components_0=Module["_emscripten_bind_PointAttribute_num_components_0"]=Module["asm"]["v"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_normalized_0=Module["_emscripten_bind_PointAttribute_normalized_0"]=function(){return (_emscripten_bind_PointAttribute_normalized_0=Module["_emscripten_bind_PointAttribute_normalized_0"]=Module["asm"]["w"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_byte_stride_0=Module["_emscripten_bind_PointAttribute_byte_stride_0"]=function(){return (_emscripten_bind_PointAttribute_byte_stride_0=Module["_emscripten_bind_PointAttribute_byte_stride_0"]=Module["asm"]["x"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_byte_offset_0=Module["_emscripten_bind_PointAttribute_byte_offset_0"]=function(){return (_emscripten_bind_PointAttribute_byte_offset_0=Module["_emscripten_bind_PointAttribute_byte_offset_0"]=Module["asm"]["y"]).apply(null,arguments)};var _emscripten_bind_PointAttribute_unique_id_0=Module["_emscripten_bind_PointAttribute_unique_id_0"]=function(){return (_emscripten_bind_PointAttribute_unique_id_0=Module["_emscripten_bind_PointAttribute_unique_id_0"]=Module["asm"]["z"]).apply(null,arguments)};var _emscripten_bind_PointAttribute___destroy___0=Module["_emscripten_bind_PointAttribute___destroy___0"]=function(){return (_emscripten_bind_PointAttribute___destroy___0=Module["_emscripten_bind_PointAttribute___destroy___0"]=Module["asm"]["A"]).apply(null,arguments)};var _emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0=Module["_emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0"]=function(){return (_emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0=Module["_emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0"]=Module["asm"]["B"]).apply(null,arguments)};var _emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1=Module["_emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1"]=function(){return (_emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1=Module["_emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1"]=Module["asm"]["C"]).apply(null,arguments)};var _emscripten_bind_AttributeQuantizationTransform_quantization_bits_0=Module["_emscripten_bind_AttributeQuantizationTransform_quantization_bits_0"]=function(){return (_emscripten_bind_AttributeQuantizationTransform_quantization_bits_0=Module["_emscripten_bind_AttributeQuantizationTransform_quantization_bits_0"]=Module["asm"]["D"]).apply(null,arguments)};var _emscripten_bind_AttributeQuantizationTransform_min_value_1=Module["_emscripten_bind_AttributeQuantizationTransform_min_value_1"]=function(){return (_emscripten_bind_AttributeQuantizationTransform_min_value_1=Module["_emscripten_bind_AttributeQuantizationTransform_min_value_1"]=Module["asm"]["E"]).apply(null,arguments)};var _emscripten_bind_AttributeQuantizationTransform_range_0=Module["_emscripten_bind_AttributeQuantizationTransform_range_0"]=function(){return (_emscripten_bind_AttributeQuantizationTransform_range_0=Module["_emscripten_bind_AttributeQuantizationTransform_range_0"]=Module["asm"]["F"]).apply(null,arguments)};var _emscripten_bind_AttributeQuantizationTransform___destroy___0=Module["_emscripten_bind_AttributeQuantizationTransform___destroy___0"]=function(){return (_emscripten_bind_AttributeQuantizationTransform___destroy___0=Module["_emscripten_bind_AttributeQuantizationTransform___destroy___0"]=Module["asm"]["G"]).apply(null,arguments)};var _emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0=Module["_emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0"]=function(){return (_emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0=Module["_emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0"]=Module["asm"]["H"]).apply(null,arguments)};var _emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1=Module["_emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1"]=function(){return (_emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1=Module["_emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1"]=Module["asm"]["I"]).apply(null,arguments)};var _emscripten_bind_AttributeOctahedronTransform_quantization_bits_0=Module["_emscripten_bind_AttributeOctahedronTransform_quantization_bits_0"]=function(){return (_emscripten_bind_AttributeOctahedronTransform_quantization_bits_0=Module["_emscripten_bind_AttributeOctahedronTransform_quantization_bits_0"]=Module["asm"]["J"]).apply(null,arguments)};var _emscripten_bind_AttributeOctahedronTransform___destroy___0=Module["_emscripten_bind_AttributeOctahedronTransform___destroy___0"]=function(){return (_emscripten_bind_AttributeOctahedronTransform___destroy___0=Module["_emscripten_bind_AttributeOctahedronTransform___destroy___0"]=Module["asm"]["K"]).apply(null,arguments)};var _emscripten_bind_PointCloud_PointCloud_0=Module["_emscripten_bind_PointCloud_PointCloud_0"]=function(){return (_emscripten_bind_PointCloud_PointCloud_0=Module["_emscripten_bind_PointCloud_PointCloud_0"]=Module["asm"]["L"]).apply(null,arguments)};var _emscripten_bind_PointCloud_num_attributes_0=Module["_emscripten_bind_PointCloud_num_attributes_0"]=function(){return (_emscripten_bind_PointCloud_num_attributes_0=Module["_emscripten_bind_PointCloud_num_attributes_0"]=Module["asm"]["M"]).apply(null,arguments)};var _emscripten_bind_PointCloud_num_points_0=Module["_emscripten_bind_PointCloud_num_points_0"]=function(){return (_emscripten_bind_PointCloud_num_points_0=Module["_emscripten_bind_PointCloud_num_points_0"]=Module["asm"]["N"]).apply(null,arguments)};var _emscripten_bind_PointCloud___destroy___0=Module["_emscripten_bind_PointCloud___destroy___0"]=function(){return (_emscripten_bind_PointCloud___destroy___0=Module["_emscripten_bind_PointCloud___destroy___0"]=Module["asm"]["O"]).apply(null,arguments)};var _emscripten_bind_Mesh_Mesh_0=Module["_emscripten_bind_Mesh_Mesh_0"]=function(){return (_emscripten_bind_Mesh_Mesh_0=Module["_emscripten_bind_Mesh_Mesh_0"]=Module["asm"]["P"]).apply(null,arguments)};var _emscripten_bind_Mesh_num_faces_0=Module["_emscripten_bind_Mesh_num_faces_0"]=function(){return (_emscripten_bind_Mesh_num_faces_0=Module["_emscripten_bind_Mesh_num_faces_0"]=Module["asm"]["Q"]).apply(null,arguments)};var _emscripten_bind_Mesh_num_attributes_0=Module["_emscripten_bind_Mesh_num_attributes_0"]=function(){return (_emscripten_bind_Mesh_num_attributes_0=Module["_emscripten_bind_Mesh_num_attributes_0"]=Module["asm"]["R"]).apply(null,arguments)};var _emscripten_bind_Mesh_num_points_0=Module["_emscripten_bind_Mesh_num_points_0"]=function(){return (_emscripten_bind_Mesh_num_points_0=Module["_emscripten_bind_Mesh_num_points_0"]=Module["asm"]["S"]).apply(null,arguments)};var _emscripten_bind_Mesh___destroy___0=Module["_emscripten_bind_Mesh___destroy___0"]=function(){return (_emscripten_bind_Mesh___destroy___0=Module["_emscripten_bind_Mesh___destroy___0"]=Module["asm"]["T"]).apply(null,arguments)};var _emscripten_bind_Metadata_Metadata_0=Module["_emscripten_bind_Metadata_Metadata_0"]=function(){return (_emscripten_bind_Metadata_Metadata_0=Module["_emscripten_bind_Metadata_Metadata_0"]=Module["asm"]["U"]).apply(null,arguments)};var _emscripten_bind_Metadata___destroy___0=Module["_emscripten_bind_Metadata___destroy___0"]=function(){return (_emscripten_bind_Metadata___destroy___0=Module["_emscripten_bind_Metadata___destroy___0"]=Module["asm"]["V"]).apply(null,arguments)};var _emscripten_bind_Status_code_0=Module["_emscripten_bind_Status_code_0"]=function(){return (_emscripten_bind_Status_code_0=Module["_emscripten_bind_Status_code_0"]=Module["asm"]["W"]).apply(null,arguments)};var _emscripten_bind_Status_ok_0=Module["_emscripten_bind_Status_ok_0"]=function(){return (_emscripten_bind_Status_ok_0=Module["_emscripten_bind_Status_ok_0"]=Module["asm"]["X"]).apply(null,arguments)};var _emscripten_bind_Status_error_msg_0=Module["_emscripten_bind_Status_error_msg_0"]=function(){return (_emscripten_bind_Status_error_msg_0=Module["_emscripten_bind_Status_error_msg_0"]=Module["asm"]["Y"]).apply(null,arguments)};var _emscripten_bind_Status___destroy___0=Module["_emscripten_bind_Status___destroy___0"]=function(){return (_emscripten_bind_Status___destroy___0=Module["_emscripten_bind_Status___destroy___0"]=Module["asm"]["Z"]).apply(null,arguments)};var _emscripten_bind_DracoFloat32Array_DracoFloat32Array_0=Module["_emscripten_bind_DracoFloat32Array_DracoFloat32Array_0"]=function(){return (_emscripten_bind_DracoFloat32Array_DracoFloat32Array_0=Module["_emscripten_bind_DracoFloat32Array_DracoFloat32Array_0"]=Module["asm"]["_"]).apply(null,arguments)};var _emscripten_bind_DracoFloat32Array_GetValue_1=Module["_emscripten_bind_DracoFloat32Array_GetValue_1"]=function(){return (_emscripten_bind_DracoFloat32Array_GetValue_1=Module["_emscripten_bind_DracoFloat32Array_GetValue_1"]=Module["asm"]["$"]).apply(null,arguments)};var _emscripten_bind_DracoFloat32Array_size_0=Module["_emscripten_bind_DracoFloat32Array_size_0"]=function(){return (_emscripten_bind_DracoFloat32Array_size_0=Module["_emscripten_bind_DracoFloat32Array_size_0"]=Module["asm"]["aa"]).apply(null,arguments)};var _emscripten_bind_DracoFloat32Array___destroy___0=Module["_emscripten_bind_DracoFloat32Array___destroy___0"]=function(){return (_emscripten_bind_DracoFloat32Array___destroy___0=Module["_emscripten_bind_DracoFloat32Array___destroy___0"]=Module["asm"]["ba"]).apply(null,arguments)};var _emscripten_bind_DracoInt8Array_DracoInt8Array_0=Module["_emscripten_bind_DracoInt8Array_DracoInt8Array_0"]=function(){return (_emscripten_bind_DracoInt8Array_DracoInt8Array_0=Module["_emscripten_bind_DracoInt8Array_DracoInt8Array_0"]=Module["asm"]["ca"]).apply(null,arguments)};var _emscripten_bind_DracoInt8Array_GetValue_1=Module["_emscripten_bind_DracoInt8Array_GetValue_1"]=function(){return (_emscripten_bind_DracoInt8Array_GetValue_1=Module["_emscripten_bind_DracoInt8Array_GetValue_1"]=Module["asm"]["da"]).apply(null,arguments)};var _emscripten_bind_DracoInt8Array_size_0=Module["_emscripten_bind_DracoInt8Array_size_0"]=function(){return (_emscripten_bind_DracoInt8Array_size_0=Module["_emscripten_bind_DracoInt8Array_size_0"]=Module["asm"]["ea"]).apply(null,arguments)};var _emscripten_bind_DracoInt8Array___destroy___0=Module["_emscripten_bind_DracoInt8Array___destroy___0"]=function(){return (_emscripten_bind_DracoInt8Array___destroy___0=Module["_emscripten_bind_DracoInt8Array___destroy___0"]=Module["asm"]["fa"]).apply(null,arguments)};var _emscripten_bind_DracoUInt8Array_DracoUInt8Array_0=Module["_emscripten_bind_DracoUInt8Array_DracoUInt8Array_0"]=function(){return (_emscripten_bind_DracoUInt8Array_DracoUInt8Array_0=Module["_emscripten_bind_DracoUInt8Array_DracoUInt8Array_0"]=Module["asm"]["ga"]).apply(null,arguments)};var _emscripten_bind_DracoUInt8Array_GetValue_1=Module["_emscripten_bind_DracoUInt8Array_GetValue_1"]=function(){return (_emscripten_bind_DracoUInt8Array_GetValue_1=Module["_emscripten_bind_DracoUInt8Array_GetValue_1"]=Module["asm"]["ha"]).apply(null,arguments)};var _emscripten_bind_DracoUInt8Array_size_0=Module["_emscripten_bind_DracoUInt8Array_size_0"]=function(){return (_emscripten_bind_DracoUInt8Array_size_0=Module["_emscripten_bind_DracoUInt8Array_size_0"]=Module["asm"]["ia"]).apply(null,arguments)};var _emscripten_bind_DracoUInt8Array___destroy___0=Module["_emscripten_bind_DracoUInt8Array___destroy___0"]=function(){return (_emscripten_bind_DracoUInt8Array___destroy___0=Module["_emscripten_bind_DracoUInt8Array___destroy___0"]=Module["asm"]["ja"]).apply(null,arguments)};var _emscripten_bind_DracoInt16Array_DracoInt16Array_0=Module["_emscripten_bind_DracoInt16Array_DracoInt16Array_0"]=function(){return (_emscripten_bind_DracoInt16Array_DracoInt16Array_0=Module["_emscripten_bind_DracoInt16Array_DracoInt16Array_0"]=Module["asm"]["ka"]).apply(null,arguments)};var _emscripten_bind_DracoInt16Array_GetValue_1=Module["_emscripten_bind_DracoInt16Array_GetValue_1"]=function(){return (_emscripten_bind_DracoInt16Array_GetValue_1=Module["_emscripten_bind_DracoInt16Array_GetValue_1"]=Module["asm"]["la"]).apply(null,arguments)};var _emscripten_bind_DracoInt16Array_size_0=Module["_emscripten_bind_DracoInt16Array_size_0"]=function(){return (_emscripten_bind_DracoInt16Array_size_0=Module["_emscripten_bind_DracoInt16Array_size_0"]=Module["asm"]["ma"]).apply(null,arguments)};var _emscripten_bind_DracoInt16Array___destroy___0=Module["_emscripten_bind_DracoInt16Array___destroy___0"]=function(){return (_emscripten_bind_DracoInt16Array___destroy___0=Module["_emscripten_bind_DracoInt16Array___destroy___0"]=Module["asm"]["na"]).apply(null,arguments)};var _emscripten_bind_DracoUInt16Array_DracoUInt16Array_0=Module["_emscripten_bind_DracoUInt16Array_DracoUInt16Array_0"]=function(){return (_emscripten_bind_DracoUInt16Array_DracoUInt16Array_0=Module["_emscripten_bind_DracoUInt16Array_DracoUInt16Array_0"]=Module["asm"]["oa"]).apply(null,arguments)};var _emscripten_bind_DracoUInt16Array_GetValue_1=Module["_emscripten_bind_DracoUInt16Array_GetValue_1"]=function(){return (_emscripten_bind_DracoUInt16Array_GetValue_1=Module["_emscripten_bind_DracoUInt16Array_GetValue_1"]=Module["asm"]["pa"]).apply(null,arguments)};var _emscripten_bind_DracoUInt16Array_size_0=Module["_emscripten_bind_DracoUInt16Array_size_0"]=function(){return (_emscripten_bind_DracoUInt16Array_size_0=Module["_emscripten_bind_DracoUInt16Array_size_0"]=Module["asm"]["qa"]).apply(null,arguments)};var _emscripten_bind_DracoUInt16Array___destroy___0=Module["_emscripten_bind_DracoUInt16Array___destroy___0"]=function(){return (_emscripten_bind_DracoUInt16Array___destroy___0=Module["_emscripten_bind_DracoUInt16Array___destroy___0"]=Module["asm"]["ra"]).apply(null,arguments)};var _emscripten_bind_DracoInt32Array_DracoInt32Array_0=Module["_emscripten_bind_DracoInt32Array_DracoInt32Array_0"]=function(){return (_emscripten_bind_DracoInt32Array_DracoInt32Array_0=Module["_emscripten_bind_DracoInt32Array_DracoInt32Array_0"]=Module["asm"]["sa"]).apply(null,arguments)};var _emscripten_bind_DracoInt32Array_GetValue_1=Module["_emscripten_bind_DracoInt32Array_GetValue_1"]=function(){return (_emscripten_bind_DracoInt32Array_GetValue_1=Module["_emscripten_bind_DracoInt32Array_GetValue_1"]=Module["asm"]["ta"]).apply(null,arguments)};var _emscripten_bind_DracoInt32Array_size_0=Module["_emscripten_bind_DracoInt32Array_size_0"]=function(){return (_emscripten_bind_DracoInt32Array_size_0=Module["_emscripten_bind_DracoInt32Array_size_0"]=Module["asm"]["ua"]).apply(null,arguments)};var _emscripten_bind_DracoInt32Array___destroy___0=Module["_emscripten_bind_DracoInt32Array___destroy___0"]=function(){return (_emscripten_bind_DracoInt32Array___destroy___0=Module["_emscripten_bind_DracoInt32Array___destroy___0"]=Module["asm"]["va"]).apply(null,arguments)};var _emscripten_bind_DracoUInt32Array_DracoUInt32Array_0=Module["_emscripten_bind_DracoUInt32Array_DracoUInt32Array_0"]=function(){return (_emscripten_bind_DracoUInt32Array_DracoUInt32Array_0=Module["_emscripten_bind_DracoUInt32Array_DracoUInt32Array_0"]=Module["asm"]["wa"]).apply(null,arguments)};var _emscripten_bind_DracoUInt32Array_GetValue_1=Module["_emscripten_bind_DracoUInt32Array_GetValue_1"]=function(){return (_emscripten_bind_DracoUInt32Array_GetValue_1=Module["_emscripten_bind_DracoUInt32Array_GetValue_1"]=Module["asm"]["xa"]).apply(null,arguments)};var _emscripten_bind_DracoUInt32Array_size_0=Module["_emscripten_bind_DracoUInt32Array_size_0"]=function(){return (_emscripten_bind_DracoUInt32Array_size_0=Module["_emscripten_bind_DracoUInt32Array_size_0"]=Module["asm"]["ya"]).apply(null,arguments)};var _emscripten_bind_DracoUInt32Array___destroy___0=Module["_emscripten_bind_DracoUInt32Array___destroy___0"]=function(){return (_emscripten_bind_DracoUInt32Array___destroy___0=Module["_emscripten_bind_DracoUInt32Array___destroy___0"]=Module["asm"]["za"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier_MetadataQuerier_0=Module["_emscripten_bind_MetadataQuerier_MetadataQuerier_0"]=function(){return (_emscripten_bind_MetadataQuerier_MetadataQuerier_0=Module["_emscripten_bind_MetadataQuerier_MetadataQuerier_0"]=Module["asm"]["Aa"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier_HasEntry_2=Module["_emscripten_bind_MetadataQuerier_HasEntry_2"]=function(){return (_emscripten_bind_MetadataQuerier_HasEntry_2=Module["_emscripten_bind_MetadataQuerier_HasEntry_2"]=Module["asm"]["Ba"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier_GetIntEntry_2=Module["_emscripten_bind_MetadataQuerier_GetIntEntry_2"]=function(){return (_emscripten_bind_MetadataQuerier_GetIntEntry_2=Module["_emscripten_bind_MetadataQuerier_GetIntEntry_2"]=Module["asm"]["Ca"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier_GetIntEntryArray_3=Module["_emscripten_bind_MetadataQuerier_GetIntEntryArray_3"]=function(){return (_emscripten_bind_MetadataQuerier_GetIntEntryArray_3=Module["_emscripten_bind_MetadataQuerier_GetIntEntryArray_3"]=Module["asm"]["Da"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier_GetDoubleEntry_2=Module["_emscripten_bind_MetadataQuerier_GetDoubleEntry_2"]=function(){return (_emscripten_bind_MetadataQuerier_GetDoubleEntry_2=Module["_emscripten_bind_MetadataQuerier_GetDoubleEntry_2"]=Module["asm"]["Ea"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier_GetStringEntry_2=Module["_emscripten_bind_MetadataQuerier_GetStringEntry_2"]=function(){return (_emscripten_bind_MetadataQuerier_GetStringEntry_2=Module["_emscripten_bind_MetadataQuerier_GetStringEntry_2"]=Module["asm"]["Fa"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier_NumEntries_1=Module["_emscripten_bind_MetadataQuerier_NumEntries_1"]=function(){return (_emscripten_bind_MetadataQuerier_NumEntries_1=Module["_emscripten_bind_MetadataQuerier_NumEntries_1"]=Module["asm"]["Ga"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier_GetEntryName_2=Module["_emscripten_bind_MetadataQuerier_GetEntryName_2"]=function(){return (_emscripten_bind_MetadataQuerier_GetEntryName_2=Module["_emscripten_bind_MetadataQuerier_GetEntryName_2"]=Module["asm"]["Ha"]).apply(null,arguments)};var _emscripten_bind_MetadataQuerier___destroy___0=Module["_emscripten_bind_MetadataQuerier___destroy___0"]=function(){return (_emscripten_bind_MetadataQuerier___destroy___0=Module["_emscripten_bind_MetadataQuerier___destroy___0"]=Module["asm"]["Ia"]).apply(null,arguments)};var _emscripten_bind_Decoder_Decoder_0=Module["_emscripten_bind_Decoder_Decoder_0"]=function(){return (_emscripten_bind_Decoder_Decoder_0=Module["_emscripten_bind_Decoder_Decoder_0"]=Module["asm"]["Ja"]).apply(null,arguments)};var _emscripten_bind_Decoder_DecodeArrayToPointCloud_3=Module["_emscripten_bind_Decoder_DecodeArrayToPointCloud_3"]=function(){return (_emscripten_bind_Decoder_DecodeArrayToPointCloud_3=Module["_emscripten_bind_Decoder_DecodeArrayToPointCloud_3"]=Module["asm"]["Ka"]).apply(null,arguments)};var _emscripten_bind_Decoder_DecodeArrayToMesh_3=Module["_emscripten_bind_Decoder_DecodeArrayToMesh_3"]=function(){return (_emscripten_bind_Decoder_DecodeArrayToMesh_3=Module["_emscripten_bind_Decoder_DecodeArrayToMesh_3"]=Module["asm"]["La"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeId_2=Module["_emscripten_bind_Decoder_GetAttributeId_2"]=function(){return (_emscripten_bind_Decoder_GetAttributeId_2=Module["_emscripten_bind_Decoder_GetAttributeId_2"]=Module["asm"]["Ma"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeIdByName_2=Module["_emscripten_bind_Decoder_GetAttributeIdByName_2"]=function(){return (_emscripten_bind_Decoder_GetAttributeIdByName_2=Module["_emscripten_bind_Decoder_GetAttributeIdByName_2"]=Module["asm"]["Na"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3=Module["_emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3=Module["_emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3"]=Module["asm"]["Oa"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttribute_2=Module["_emscripten_bind_Decoder_GetAttribute_2"]=function(){return (_emscripten_bind_Decoder_GetAttribute_2=Module["_emscripten_bind_Decoder_GetAttribute_2"]=Module["asm"]["Pa"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeByUniqueId_2=Module["_emscripten_bind_Decoder_GetAttributeByUniqueId_2"]=function(){return (_emscripten_bind_Decoder_GetAttributeByUniqueId_2=Module["_emscripten_bind_Decoder_GetAttributeByUniqueId_2"]=Module["asm"]["Qa"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetMetadata_1=Module["_emscripten_bind_Decoder_GetMetadata_1"]=function(){return (_emscripten_bind_Decoder_GetMetadata_1=Module["_emscripten_bind_Decoder_GetMetadata_1"]=Module["asm"]["Ra"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeMetadata_2=Module["_emscripten_bind_Decoder_GetAttributeMetadata_2"]=function(){return (_emscripten_bind_Decoder_GetAttributeMetadata_2=Module["_emscripten_bind_Decoder_GetAttributeMetadata_2"]=Module["asm"]["Sa"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetFaceFromMesh_3=Module["_emscripten_bind_Decoder_GetFaceFromMesh_3"]=function(){return (_emscripten_bind_Decoder_GetFaceFromMesh_3=Module["_emscripten_bind_Decoder_GetFaceFromMesh_3"]=Module["asm"]["Ta"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetTriangleStripsFromMesh_2=Module["_emscripten_bind_Decoder_GetTriangleStripsFromMesh_2"]=function(){return (_emscripten_bind_Decoder_GetTriangleStripsFromMesh_2=Module["_emscripten_bind_Decoder_GetTriangleStripsFromMesh_2"]=Module["asm"]["Ua"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetTrianglesUInt16Array_3=Module["_emscripten_bind_Decoder_GetTrianglesUInt16Array_3"]=function(){return (_emscripten_bind_Decoder_GetTrianglesUInt16Array_3=Module["_emscripten_bind_Decoder_GetTrianglesUInt16Array_3"]=Module["asm"]["Va"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetTrianglesUInt32Array_3=Module["_emscripten_bind_Decoder_GetTrianglesUInt32Array_3"]=function(){return (_emscripten_bind_Decoder_GetTrianglesUInt32Array_3=Module["_emscripten_bind_Decoder_GetTrianglesUInt32Array_3"]=Module["asm"]["Wa"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeFloat_3=Module["_emscripten_bind_Decoder_GetAttributeFloat_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeFloat_3=Module["_emscripten_bind_Decoder_GetAttributeFloat_3"]=Module["asm"]["Xa"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3"]=Module["asm"]["Ya"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeIntForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeIntForAllPoints_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeIntForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeIntForAllPoints_3"]=Module["asm"]["Za"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3"]=Module["asm"]["_a"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3"]=Module["asm"]["$a"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3"]=Module["asm"]["ab"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3"]=Module["asm"]["bb"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3"]=Module["asm"]["cb"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3"]=function(){return (_emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3=Module["_emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3"]=Module["asm"]["db"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5=Module["_emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5"]=function(){return (_emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5=Module["_emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5"]=Module["asm"]["eb"]).apply(null,arguments)};var _emscripten_bind_Decoder_SkipAttributeTransform_1=Module["_emscripten_bind_Decoder_SkipAttributeTransform_1"]=function(){return (_emscripten_bind_Decoder_SkipAttributeTransform_1=Module["_emscripten_bind_Decoder_SkipAttributeTransform_1"]=Module["asm"]["fb"]).apply(null,arguments)};var _emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1=Module["_emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1"]=function(){return (_emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1=Module["_emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1"]=Module["asm"]["gb"]).apply(null,arguments)};var _emscripten_bind_Decoder_DecodeBufferToPointCloud_2=Module["_emscripten_bind_Decoder_DecodeBufferToPointCloud_2"]=function(){return (_emscripten_bind_Decoder_DecodeBufferToPointCloud_2=Module["_emscripten_bind_Decoder_DecodeBufferToPointCloud_2"]=Module["asm"]["hb"]).apply(null,arguments)};var _emscripten_bind_Decoder_DecodeBufferToMesh_2=Module["_emscripten_bind_Decoder_DecodeBufferToMesh_2"]=function(){return (_emscripten_bind_Decoder_DecodeBufferToMesh_2=Module["_emscripten_bind_Decoder_DecodeBufferToMesh_2"]=Module["asm"]["ib"]).apply(null,arguments)};var _emscripten_bind_Decoder___destroy___0=Module["_emscripten_bind_Decoder___destroy___0"]=function(){return (_emscripten_bind_Decoder___destroy___0=Module["_emscripten_bind_Decoder___destroy___0"]=Module["asm"]["jb"]).apply(null,arguments)};var _emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM=Module["_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM"]=function(){return (_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM=Module["_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM"]=Module["asm"]["kb"]).apply(null,arguments)};var _emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM=Module["_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM"]=function(){return (_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM=Module["_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM"]=Module["asm"]["lb"]).apply(null,arguments)};var _emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM=Module["_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM"]=function(){return (_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM=Module["_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM"]=Module["asm"]["mb"]).apply(null,arguments)};var _emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM=Module["_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM"]=function(){return (_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM=Module["_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM"]=Module["asm"]["nb"]).apply(null,arguments)};var _emscripten_enum_draco_GeometryAttribute_Type_INVALID=Module["_emscripten_enum_draco_GeometryAttribute_Type_INVALID"]=function(){return (_emscripten_enum_draco_GeometryAttribute_Type_INVALID=Module["_emscripten_enum_draco_GeometryAttribute_Type_INVALID"]=Module["asm"]["ob"]).apply(null,arguments)};var _emscripten_enum_draco_GeometryAttribute_Type_POSITION=Module["_emscripten_enum_draco_GeometryAttribute_Type_POSITION"]=function(){return (_emscripten_enum_draco_GeometryAttribute_Type_POSITION=Module["_emscripten_enum_draco_GeometryAttribute_Type_POSITION"]=Module["asm"]["pb"]).apply(null,arguments)};var _emscripten_enum_draco_GeometryAttribute_Type_NORMAL=Module["_emscripten_enum_draco_GeometryAttribute_Type_NORMAL"]=function(){return (_emscripten_enum_draco_GeometryAttribute_Type_NORMAL=Module["_emscripten_enum_draco_GeometryAttribute_Type_NORMAL"]=Module["asm"]["qb"]).apply(null,arguments)};var _emscripten_enum_draco_GeometryAttribute_Type_COLOR=Module["_emscripten_enum_draco_GeometryAttribute_Type_COLOR"]=function(){return (_emscripten_enum_draco_GeometryAttribute_Type_COLOR=Module["_emscripten_enum_draco_GeometryAttribute_Type_COLOR"]=Module["asm"]["rb"]).apply(null,arguments)};var _emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD=Module["_emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD"]=function(){return (_emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD=Module["_emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD"]=Module["asm"]["sb"]).apply(null,arguments)};var _emscripten_enum_draco_GeometryAttribute_Type_GENERIC=Module["_emscripten_enum_draco_GeometryAttribute_Type_GENERIC"]=function(){return (_emscripten_enum_draco_GeometryAttribute_Type_GENERIC=Module["_emscripten_enum_draco_GeometryAttribute_Type_GENERIC"]=Module["asm"]["tb"]).apply(null,arguments)};var _emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE=Module["_emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE"]=function(){return (_emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE=Module["_emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE"]=Module["asm"]["ub"]).apply(null,arguments)};var _emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD=Module["_emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD"]=function(){return (_emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD=Module["_emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD"]=Module["asm"]["vb"]).apply(null,arguments)};var _emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH=Module["_emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH"]=function(){return (_emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH=Module["_emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH"]=Module["asm"]["wb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_INVALID=Module["_emscripten_enum_draco_DataType_DT_INVALID"]=function(){return (_emscripten_enum_draco_DataType_DT_INVALID=Module["_emscripten_enum_draco_DataType_DT_INVALID"]=Module["asm"]["xb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_INT8=Module["_emscripten_enum_draco_DataType_DT_INT8"]=function(){return (_emscripten_enum_draco_DataType_DT_INT8=Module["_emscripten_enum_draco_DataType_DT_INT8"]=Module["asm"]["yb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_UINT8=Module["_emscripten_enum_draco_DataType_DT_UINT8"]=function(){return (_emscripten_enum_draco_DataType_DT_UINT8=Module["_emscripten_enum_draco_DataType_DT_UINT8"]=Module["asm"]["zb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_INT16=Module["_emscripten_enum_draco_DataType_DT_INT16"]=function(){return (_emscripten_enum_draco_DataType_DT_INT16=Module["_emscripten_enum_draco_DataType_DT_INT16"]=Module["asm"]["Ab"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_UINT16=Module["_emscripten_enum_draco_DataType_DT_UINT16"]=function(){return (_emscripten_enum_draco_DataType_DT_UINT16=Module["_emscripten_enum_draco_DataType_DT_UINT16"]=Module["asm"]["Bb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_INT32=Module["_emscripten_enum_draco_DataType_DT_INT32"]=function(){return (_emscripten_enum_draco_DataType_DT_INT32=Module["_emscripten_enum_draco_DataType_DT_INT32"]=Module["asm"]["Cb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_UINT32=Module["_emscripten_enum_draco_DataType_DT_UINT32"]=function(){return (_emscripten_enum_draco_DataType_DT_UINT32=Module["_emscripten_enum_draco_DataType_DT_UINT32"]=Module["asm"]["Db"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_INT64=Module["_emscripten_enum_draco_DataType_DT_INT64"]=function(){return (_emscripten_enum_draco_DataType_DT_INT64=Module["_emscripten_enum_draco_DataType_DT_INT64"]=Module["asm"]["Eb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_UINT64=Module["_emscripten_enum_draco_DataType_DT_UINT64"]=function(){return (_emscripten_enum_draco_DataType_DT_UINT64=Module["_emscripten_enum_draco_DataType_DT_UINT64"]=Module["asm"]["Fb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_FLOAT32=Module["_emscripten_enum_draco_DataType_DT_FLOAT32"]=function(){return (_emscripten_enum_draco_DataType_DT_FLOAT32=Module["_emscripten_enum_draco_DataType_DT_FLOAT32"]=Module["asm"]["Gb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_FLOAT64=Module["_emscripten_enum_draco_DataType_DT_FLOAT64"]=function(){return (_emscripten_enum_draco_DataType_DT_FLOAT64=Module["_emscripten_enum_draco_DataType_DT_FLOAT64"]=Module["asm"]["Hb"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_BOOL=Module["_emscripten_enum_draco_DataType_DT_BOOL"]=function(){return (_emscripten_enum_draco_DataType_DT_BOOL=Module["_emscripten_enum_draco_DataType_DT_BOOL"]=Module["asm"]["Ib"]).apply(null,arguments)};var _emscripten_enum_draco_DataType_DT_TYPES_COUNT=Module["_emscripten_enum_draco_DataType_DT_TYPES_COUNT"]=function(){return (_emscripten_enum_draco_DataType_DT_TYPES_COUNT=Module["_emscripten_enum_draco_DataType_DT_TYPES_COUNT"]=Module["asm"]["Jb"]).apply(null,arguments)};var _emscripten_enum_draco_StatusCode_OK=Module["_emscripten_enum_draco_StatusCode_OK"]=function(){return (_emscripten_enum_draco_StatusCode_OK=Module["_emscripten_enum_draco_StatusCode_OK"]=Module["asm"]["Kb"]).apply(null,arguments)};var _emscripten_enum_draco_StatusCode_DRACO_ERROR=Module["_emscripten_enum_draco_StatusCode_DRACO_ERROR"]=function(){return (_emscripten_enum_draco_StatusCode_DRACO_ERROR=Module["_emscripten_enum_draco_StatusCode_DRACO_ERROR"]=Module["asm"]["Lb"]).apply(null,arguments)};var _emscripten_enum_draco_StatusCode_IO_ERROR=Module["_emscripten_enum_draco_StatusCode_IO_ERROR"]=function(){return (_emscripten_enum_draco_StatusCode_IO_ERROR=Module["_emscripten_enum_draco_StatusCode_IO_ERROR"]=Module["asm"]["Mb"]).apply(null,arguments)};var _emscripten_enum_draco_StatusCode_INVALID_PARAMETER=Module["_emscripten_enum_draco_StatusCode_INVALID_PARAMETER"]=function(){return (_emscripten_enum_draco_StatusCode_INVALID_PARAMETER=Module["_emscripten_enum_draco_StatusCode_INVALID_PARAMETER"]=Module["asm"]["Nb"]).apply(null,arguments)};var _emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION=Module["_emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION"]=function(){return (_emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION=Module["_emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION"]=Module["asm"]["Ob"]).apply(null,arguments)};var _emscripten_enum_draco_StatusCode_UNKNOWN_VERSION=Module["_emscripten_enum_draco_StatusCode_UNKNOWN_VERSION"]=function(){return (_emscripten_enum_draco_StatusCode_UNKNOWN_VERSION=Module["_emscripten_enum_draco_StatusCode_UNKNOWN_VERSION"]=Module["asm"]["Pb"]).apply(null,arguments)};Module["_malloc"]=function(){return (Module["_malloc"]=Module["asm"]["Qb"]).apply(null,arguments)};Module["_free"]=function(){return (Module["_free"]=Module["asm"]["Rb"]).apply(null,arguments)};var ___cxa_is_pointer_type=function(){return (___cxa_is_pointer_type=Module["asm"]["Sb"]).apply(null,arguments)};Module["___start_em_js"]=11660;Module["___stop_em_js"]=11758;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller;};function run(){if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun();}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("");},1);doRun();},1);}else {doRun();}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()();}}run();function WrapperObject(){}WrapperObject.prototype=Object.create(WrapperObject.prototype);WrapperObject.prototype.constructor=WrapperObject;WrapperObject.prototype.__class__=WrapperObject;WrapperObject.__cache__={};Module["WrapperObject"]=WrapperObject;function getCache(__class__){return (__class__||WrapperObject).__cache__}Module["getCache"]=getCache;function wrapPointer(ptr,__class__){var cache=getCache(__class__);var ret=cache[ptr];if(ret)return ret;ret=Object.create((__class__||WrapperObject).prototype);ret.ptr=ptr;return cache[ptr]=ret}Module["wrapPointer"]=wrapPointer;function castObject(obj,__class__){return wrapPointer(obj.ptr,__class__)}Module["castObject"]=castObject;Module["NULL"]=wrapPointer(0);function destroy(obj){if(!obj["__destroy__"])throw "Error: Cannot destroy object. (Did you create it yourself?)";obj["__destroy__"]();delete getCache(obj.__class__)[obj.ptr];}Module["destroy"]=destroy;function compare(obj1,obj2){return obj1.ptr===obj2.ptr}Module["compare"]=compare;function getPointer(obj){return obj.ptr}Module["getPointer"]=getPointer;function getClass(obj){return obj.__class__}Module["getClass"]=getClass;var ensureCache={buffer:0,size:0,pos:0,temps:[],needed:0,prepare:function(){if(ensureCache.needed){for(var i=0;i<ensureCache.temps.length;i++){Module["_free"](ensureCache.temps[i]);}ensureCache.temps.length=0;Module["_free"](ensureCache.buffer);ensureCache.buffer=0;ensureCache.size+=ensureCache.needed;ensureCache.needed=0;}if(!ensureCache.buffer){ensureCache.size+=128;ensureCache.buffer=Module["_malloc"](ensureCache.size);assert(ensureCache.buffer);}ensureCache.pos=0;},alloc:function(array,view){assert(ensureCache.buffer);var bytes=view.BYTES_PER_ELEMENT;var len=array.length*bytes;len=len+7&-8;var ret;if(ensureCache.pos+len>=ensureCache.size){assert(len>0);ensureCache.needed+=len;ret=Module["_malloc"](len);ensureCache.temps.push(ret);}else {ret=ensureCache.buffer+ensureCache.pos;ensureCache.pos+=len;}return ret},copy:function(array,view,offset){offset>>>=0;var bytes=view.BYTES_PER_ELEMENT;switch(bytes){case 2:offset>>>=1;break;case 4:offset>>>=2;break;case 8:offset>>>=3;break}for(var i=0;i<array.length;i++){view[offset+i]=array[i];}}};function ensureString(value){if(typeof value==="string"){var intArray=intArrayFromString(value);var offset=ensureCache.alloc(intArray,HEAP8);ensureCache.copy(intArray,HEAP8,offset);return offset}return value}function ensureInt8(value){if(typeof value==="object"){var offset=ensureCache.alloc(value,HEAP8);ensureCache.copy(value,HEAP8,offset);return offset}return value}function VoidPtr(){throw "cannot construct a VoidPtr, no constructor in IDL"}VoidPtr.prototype=Object.create(WrapperObject.prototype);VoidPtr.prototype.constructor=VoidPtr;VoidPtr.prototype.__class__=VoidPtr;VoidPtr.__cache__={};Module["VoidPtr"]=VoidPtr;VoidPtr.prototype["__destroy__"]=VoidPtr.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_VoidPtr___destroy___0(self);};function DecoderBuffer(){this.ptr=_emscripten_bind_DecoderBuffer_DecoderBuffer_0();getCache(DecoderBuffer)[this.ptr]=this;}DecoderBuffer.prototype=Object.create(WrapperObject.prototype);DecoderBuffer.prototype.constructor=DecoderBuffer;DecoderBuffer.prototype.__class__=DecoderBuffer;DecoderBuffer.__cache__={};Module["DecoderBuffer"]=DecoderBuffer;DecoderBuffer.prototype["Init"]=DecoderBuffer.prototype.Init=function(data,data_size){var self=this.ptr;ensureCache.prepare();if(typeof data=="object"){data=ensureInt8(data);}if(data_size&&typeof data_size==="object")data_size=data_size.ptr;_emscripten_bind_DecoderBuffer_Init_2(self,data,data_size);};DecoderBuffer.prototype["__destroy__"]=DecoderBuffer.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_DecoderBuffer___destroy___0(self);};function AttributeTransformData(){this.ptr=_emscripten_bind_AttributeTransformData_AttributeTransformData_0();getCache(AttributeTransformData)[this.ptr]=this;}AttributeTransformData.prototype=Object.create(WrapperObject.prototype);AttributeTransformData.prototype.constructor=AttributeTransformData;AttributeTransformData.prototype.__class__=AttributeTransformData;AttributeTransformData.__cache__={};Module["AttributeTransformData"]=AttributeTransformData;AttributeTransformData.prototype["transform_type"]=AttributeTransformData.prototype.transform_type=function(){var self=this.ptr;return _emscripten_bind_AttributeTransformData_transform_type_0(self)};AttributeTransformData.prototype["__destroy__"]=AttributeTransformData.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_AttributeTransformData___destroy___0(self);};function GeometryAttribute(){this.ptr=_emscripten_bind_GeometryAttribute_GeometryAttribute_0();getCache(GeometryAttribute)[this.ptr]=this;}GeometryAttribute.prototype=Object.create(WrapperObject.prototype);GeometryAttribute.prototype.constructor=GeometryAttribute;GeometryAttribute.prototype.__class__=GeometryAttribute;GeometryAttribute.__cache__={};Module["GeometryAttribute"]=GeometryAttribute;GeometryAttribute.prototype["__destroy__"]=GeometryAttribute.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_GeometryAttribute___destroy___0(self);};function PointAttribute(){this.ptr=_emscripten_bind_PointAttribute_PointAttribute_0();getCache(PointAttribute)[this.ptr]=this;}PointAttribute.prototype=Object.create(WrapperObject.prototype);PointAttribute.prototype.constructor=PointAttribute;PointAttribute.prototype.__class__=PointAttribute;PointAttribute.__cache__={};Module["PointAttribute"]=PointAttribute;PointAttribute.prototype["size"]=PointAttribute.prototype.size=function(){var self=this.ptr;return _emscripten_bind_PointAttribute_size_0(self)};PointAttribute.prototype["GetAttributeTransformData"]=PointAttribute.prototype.GetAttributeTransformData=function(){var self=this.ptr;return wrapPointer(_emscripten_bind_PointAttribute_GetAttributeTransformData_0(self),AttributeTransformData)};PointAttribute.prototype["attribute_type"]=PointAttribute.prototype.attribute_type=function(){var self=this.ptr;return _emscripten_bind_PointAttribute_attribute_type_0(self)};PointAttribute.prototype["data_type"]=PointAttribute.prototype.data_type=function(){var self=this.ptr;return _emscripten_bind_PointAttribute_data_type_0(self)};PointAttribute.prototype["num_components"]=PointAttribute.prototype.num_components=function(){var self=this.ptr;return _emscripten_bind_PointAttribute_num_components_0(self)};PointAttribute.prototype["normalized"]=PointAttribute.prototype.normalized=function(){var self=this.ptr;return !!_emscripten_bind_PointAttribute_normalized_0(self)};PointAttribute.prototype["byte_stride"]=PointAttribute.prototype.byte_stride=function(){var self=this.ptr;return _emscripten_bind_PointAttribute_byte_stride_0(self)};PointAttribute.prototype["byte_offset"]=PointAttribute.prototype.byte_offset=function(){var self=this.ptr;return _emscripten_bind_PointAttribute_byte_offset_0(self)};PointAttribute.prototype["unique_id"]=PointAttribute.prototype.unique_id=function(){var self=this.ptr;return _emscripten_bind_PointAttribute_unique_id_0(self)};PointAttribute.prototype["__destroy__"]=PointAttribute.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_PointAttribute___destroy___0(self);};function AttributeQuantizationTransform(){this.ptr=_emscripten_bind_AttributeQuantizationTransform_AttributeQuantizationTransform_0();getCache(AttributeQuantizationTransform)[this.ptr]=this;}AttributeQuantizationTransform.prototype=Object.create(WrapperObject.prototype);AttributeQuantizationTransform.prototype.constructor=AttributeQuantizationTransform;AttributeQuantizationTransform.prototype.__class__=AttributeQuantizationTransform;AttributeQuantizationTransform.__cache__={};Module["AttributeQuantizationTransform"]=AttributeQuantizationTransform;AttributeQuantizationTransform.prototype["InitFromAttribute"]=AttributeQuantizationTransform.prototype.InitFromAttribute=function(att){var self=this.ptr;if(att&&typeof att==="object")att=att.ptr;return !!_emscripten_bind_AttributeQuantizationTransform_InitFromAttribute_1(self,att)};AttributeQuantizationTransform.prototype["quantization_bits"]=AttributeQuantizationTransform.prototype.quantization_bits=function(){var self=this.ptr;return _emscripten_bind_AttributeQuantizationTransform_quantization_bits_0(self)};AttributeQuantizationTransform.prototype["min_value"]=AttributeQuantizationTransform.prototype.min_value=function(axis){var self=this.ptr;if(axis&&typeof axis==="object")axis=axis.ptr;return _emscripten_bind_AttributeQuantizationTransform_min_value_1(self,axis)};AttributeQuantizationTransform.prototype["range"]=AttributeQuantizationTransform.prototype.range=function(){var self=this.ptr;return _emscripten_bind_AttributeQuantizationTransform_range_0(self)};AttributeQuantizationTransform.prototype["__destroy__"]=AttributeQuantizationTransform.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_AttributeQuantizationTransform___destroy___0(self);};function AttributeOctahedronTransform(){this.ptr=_emscripten_bind_AttributeOctahedronTransform_AttributeOctahedronTransform_0();getCache(AttributeOctahedronTransform)[this.ptr]=this;}AttributeOctahedronTransform.prototype=Object.create(WrapperObject.prototype);AttributeOctahedronTransform.prototype.constructor=AttributeOctahedronTransform;AttributeOctahedronTransform.prototype.__class__=AttributeOctahedronTransform;AttributeOctahedronTransform.__cache__={};Module["AttributeOctahedronTransform"]=AttributeOctahedronTransform;AttributeOctahedronTransform.prototype["InitFromAttribute"]=AttributeOctahedronTransform.prototype.InitFromAttribute=function(att){var self=this.ptr;if(att&&typeof att==="object")att=att.ptr;return !!_emscripten_bind_AttributeOctahedronTransform_InitFromAttribute_1(self,att)};AttributeOctahedronTransform.prototype["quantization_bits"]=AttributeOctahedronTransform.prototype.quantization_bits=function(){var self=this.ptr;return _emscripten_bind_AttributeOctahedronTransform_quantization_bits_0(self)};AttributeOctahedronTransform.prototype["__destroy__"]=AttributeOctahedronTransform.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_AttributeOctahedronTransform___destroy___0(self);};function PointCloud(){this.ptr=_emscripten_bind_PointCloud_PointCloud_0();getCache(PointCloud)[this.ptr]=this;}PointCloud.prototype=Object.create(WrapperObject.prototype);PointCloud.prototype.constructor=PointCloud;PointCloud.prototype.__class__=PointCloud;PointCloud.__cache__={};Module["PointCloud"]=PointCloud;PointCloud.prototype["num_attributes"]=PointCloud.prototype.num_attributes=function(){var self=this.ptr;return _emscripten_bind_PointCloud_num_attributes_0(self)};PointCloud.prototype["num_points"]=PointCloud.prototype.num_points=function(){var self=this.ptr;return _emscripten_bind_PointCloud_num_points_0(self)};PointCloud.prototype["__destroy__"]=PointCloud.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_PointCloud___destroy___0(self);};function Mesh(){this.ptr=_emscripten_bind_Mesh_Mesh_0();getCache(Mesh)[this.ptr]=this;}Mesh.prototype=Object.create(WrapperObject.prototype);Mesh.prototype.constructor=Mesh;Mesh.prototype.__class__=Mesh;Mesh.__cache__={};Module["Mesh"]=Mesh;Mesh.prototype["num_faces"]=Mesh.prototype.num_faces=function(){var self=this.ptr;return _emscripten_bind_Mesh_num_faces_0(self)};Mesh.prototype["num_attributes"]=Mesh.prototype.num_attributes=function(){var self=this.ptr;return _emscripten_bind_Mesh_num_attributes_0(self)};Mesh.prototype["num_points"]=Mesh.prototype.num_points=function(){var self=this.ptr;return _emscripten_bind_Mesh_num_points_0(self)};Mesh.prototype["__destroy__"]=Mesh.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_Mesh___destroy___0(self);};function Metadata(){this.ptr=_emscripten_bind_Metadata_Metadata_0();getCache(Metadata)[this.ptr]=this;}Metadata.prototype=Object.create(WrapperObject.prototype);Metadata.prototype.constructor=Metadata;Metadata.prototype.__class__=Metadata;Metadata.__cache__={};Module["Metadata"]=Metadata;Metadata.prototype["__destroy__"]=Metadata.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_Metadata___destroy___0(self);};function Status(){throw "cannot construct a Status, no constructor in IDL"}Status.prototype=Object.create(WrapperObject.prototype);Status.prototype.constructor=Status;Status.prototype.__class__=Status;Status.__cache__={};Module["Status"]=Status;Status.prototype["code"]=Status.prototype.code=function(){var self=this.ptr;return _emscripten_bind_Status_code_0(self)};Status.prototype["ok"]=Status.prototype.ok=function(){var self=this.ptr;return !!_emscripten_bind_Status_ok_0(self)};Status.prototype["error_msg"]=Status.prototype.error_msg=function(){var self=this.ptr;return UTF8ToString(_emscripten_bind_Status_error_msg_0(self))};Status.prototype["__destroy__"]=Status.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_Status___destroy___0(self);};function DracoFloat32Array(){this.ptr=_emscripten_bind_DracoFloat32Array_DracoFloat32Array_0();getCache(DracoFloat32Array)[this.ptr]=this;}DracoFloat32Array.prototype=Object.create(WrapperObject.prototype);DracoFloat32Array.prototype.constructor=DracoFloat32Array;DracoFloat32Array.prototype.__class__=DracoFloat32Array;DracoFloat32Array.__cache__={};Module["DracoFloat32Array"]=DracoFloat32Array;DracoFloat32Array.prototype["GetValue"]=DracoFloat32Array.prototype.GetValue=function(index){var self=this.ptr;if(index&&typeof index==="object")index=index.ptr;return _emscripten_bind_DracoFloat32Array_GetValue_1(self,index)};DracoFloat32Array.prototype["size"]=DracoFloat32Array.prototype.size=function(){var self=this.ptr;return _emscripten_bind_DracoFloat32Array_size_0(self)};DracoFloat32Array.prototype["__destroy__"]=DracoFloat32Array.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_DracoFloat32Array___destroy___0(self);};function DracoInt8Array(){this.ptr=_emscripten_bind_DracoInt8Array_DracoInt8Array_0();getCache(DracoInt8Array)[this.ptr]=this;}DracoInt8Array.prototype=Object.create(WrapperObject.prototype);DracoInt8Array.prototype.constructor=DracoInt8Array;DracoInt8Array.prototype.__class__=DracoInt8Array;DracoInt8Array.__cache__={};Module["DracoInt8Array"]=DracoInt8Array;DracoInt8Array.prototype["GetValue"]=DracoInt8Array.prototype.GetValue=function(index){var self=this.ptr;if(index&&typeof index==="object")index=index.ptr;return _emscripten_bind_DracoInt8Array_GetValue_1(self,index)};DracoInt8Array.prototype["size"]=DracoInt8Array.prototype.size=function(){var self=this.ptr;return _emscripten_bind_DracoInt8Array_size_0(self)};DracoInt8Array.prototype["__destroy__"]=DracoInt8Array.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_DracoInt8Array___destroy___0(self);};function DracoUInt8Array(){this.ptr=_emscripten_bind_DracoUInt8Array_DracoUInt8Array_0();getCache(DracoUInt8Array)[this.ptr]=this;}DracoUInt8Array.prototype=Object.create(WrapperObject.prototype);DracoUInt8Array.prototype.constructor=DracoUInt8Array;DracoUInt8Array.prototype.__class__=DracoUInt8Array;DracoUInt8Array.__cache__={};Module["DracoUInt8Array"]=DracoUInt8Array;DracoUInt8Array.prototype["GetValue"]=DracoUInt8Array.prototype.GetValue=function(index){var self=this.ptr;if(index&&typeof index==="object")index=index.ptr;return _emscripten_bind_DracoUInt8Array_GetValue_1(self,index)};DracoUInt8Array.prototype["size"]=DracoUInt8Array.prototype.size=function(){var self=this.ptr;return _emscripten_bind_DracoUInt8Array_size_0(self)};DracoUInt8Array.prototype["__destroy__"]=DracoUInt8Array.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_DracoUInt8Array___destroy___0(self);};function DracoInt16Array(){this.ptr=_emscripten_bind_DracoInt16Array_DracoInt16Array_0();getCache(DracoInt16Array)[this.ptr]=this;}DracoInt16Array.prototype=Object.create(WrapperObject.prototype);DracoInt16Array.prototype.constructor=DracoInt16Array;DracoInt16Array.prototype.__class__=DracoInt16Array;DracoInt16Array.__cache__={};Module["DracoInt16Array"]=DracoInt16Array;DracoInt16Array.prototype["GetValue"]=DracoInt16Array.prototype.GetValue=function(index){var self=this.ptr;if(index&&typeof index==="object")index=index.ptr;return _emscripten_bind_DracoInt16Array_GetValue_1(self,index)};DracoInt16Array.prototype["size"]=DracoInt16Array.prototype.size=function(){var self=this.ptr;return _emscripten_bind_DracoInt16Array_size_0(self)};DracoInt16Array.prototype["__destroy__"]=DracoInt16Array.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_DracoInt16Array___destroy___0(self);};function DracoUInt16Array(){this.ptr=_emscripten_bind_DracoUInt16Array_DracoUInt16Array_0();getCache(DracoUInt16Array)[this.ptr]=this;}DracoUInt16Array.prototype=Object.create(WrapperObject.prototype);DracoUInt16Array.prototype.constructor=DracoUInt16Array;DracoUInt16Array.prototype.__class__=DracoUInt16Array;DracoUInt16Array.__cache__={};Module["DracoUInt16Array"]=DracoUInt16Array;DracoUInt16Array.prototype["GetValue"]=DracoUInt16Array.prototype.GetValue=function(index){var self=this.ptr;if(index&&typeof index==="object")index=index.ptr;return _emscripten_bind_DracoUInt16Array_GetValue_1(self,index)};DracoUInt16Array.prototype["size"]=DracoUInt16Array.prototype.size=function(){var self=this.ptr;return _emscripten_bind_DracoUInt16Array_size_0(self)};DracoUInt16Array.prototype["__destroy__"]=DracoUInt16Array.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_DracoUInt16Array___destroy___0(self);};function DracoInt32Array(){this.ptr=_emscripten_bind_DracoInt32Array_DracoInt32Array_0();getCache(DracoInt32Array)[this.ptr]=this;}DracoInt32Array.prototype=Object.create(WrapperObject.prototype);DracoInt32Array.prototype.constructor=DracoInt32Array;DracoInt32Array.prototype.__class__=DracoInt32Array;DracoInt32Array.__cache__={};Module["DracoInt32Array"]=DracoInt32Array;DracoInt32Array.prototype["GetValue"]=DracoInt32Array.prototype.GetValue=function(index){var self=this.ptr;if(index&&typeof index==="object")index=index.ptr;return _emscripten_bind_DracoInt32Array_GetValue_1(self,index)};DracoInt32Array.prototype["size"]=DracoInt32Array.prototype.size=function(){var self=this.ptr;return _emscripten_bind_DracoInt32Array_size_0(self)};DracoInt32Array.prototype["__destroy__"]=DracoInt32Array.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_DracoInt32Array___destroy___0(self);};function DracoUInt32Array(){this.ptr=_emscripten_bind_DracoUInt32Array_DracoUInt32Array_0();getCache(DracoUInt32Array)[this.ptr]=this;}DracoUInt32Array.prototype=Object.create(WrapperObject.prototype);DracoUInt32Array.prototype.constructor=DracoUInt32Array;DracoUInt32Array.prototype.__class__=DracoUInt32Array;DracoUInt32Array.__cache__={};Module["DracoUInt32Array"]=DracoUInt32Array;DracoUInt32Array.prototype["GetValue"]=DracoUInt32Array.prototype.GetValue=function(index){var self=this.ptr;if(index&&typeof index==="object")index=index.ptr;return _emscripten_bind_DracoUInt32Array_GetValue_1(self,index)};DracoUInt32Array.prototype["size"]=DracoUInt32Array.prototype.size=function(){var self=this.ptr;return _emscripten_bind_DracoUInt32Array_size_0(self)};DracoUInt32Array.prototype["__destroy__"]=DracoUInt32Array.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_DracoUInt32Array___destroy___0(self);};function MetadataQuerier(){this.ptr=_emscripten_bind_MetadataQuerier_MetadataQuerier_0();getCache(MetadataQuerier)[this.ptr]=this;}MetadataQuerier.prototype=Object.create(WrapperObject.prototype);MetadataQuerier.prototype.constructor=MetadataQuerier;MetadataQuerier.prototype.__class__=MetadataQuerier;MetadataQuerier.__cache__={};Module["MetadataQuerier"]=MetadataQuerier;MetadataQuerier.prototype["HasEntry"]=MetadataQuerier.prototype.HasEntry=function(metadata,entry_name){var self=this.ptr;ensureCache.prepare();if(metadata&&typeof metadata==="object")metadata=metadata.ptr;if(entry_name&&typeof entry_name==="object")entry_name=entry_name.ptr;else entry_name=ensureString(entry_name);return !!_emscripten_bind_MetadataQuerier_HasEntry_2(self,metadata,entry_name)};MetadataQuerier.prototype["GetIntEntry"]=MetadataQuerier.prototype.GetIntEntry=function(metadata,entry_name){var self=this.ptr;ensureCache.prepare();if(metadata&&typeof metadata==="object")metadata=metadata.ptr;if(entry_name&&typeof entry_name==="object")entry_name=entry_name.ptr;else entry_name=ensureString(entry_name);return _emscripten_bind_MetadataQuerier_GetIntEntry_2(self,metadata,entry_name)};MetadataQuerier.prototype["GetIntEntryArray"]=MetadataQuerier.prototype.GetIntEntryArray=function(metadata,entry_name,out_values){var self=this.ptr;ensureCache.prepare();if(metadata&&typeof metadata==="object")metadata=metadata.ptr;if(entry_name&&typeof entry_name==="object")entry_name=entry_name.ptr;else entry_name=ensureString(entry_name);if(out_values&&typeof out_values==="object")out_values=out_values.ptr;_emscripten_bind_MetadataQuerier_GetIntEntryArray_3(self,metadata,entry_name,out_values);};MetadataQuerier.prototype["GetDoubleEntry"]=MetadataQuerier.prototype.GetDoubleEntry=function(metadata,entry_name){var self=this.ptr;ensureCache.prepare();if(metadata&&typeof metadata==="object")metadata=metadata.ptr;if(entry_name&&typeof entry_name==="object")entry_name=entry_name.ptr;else entry_name=ensureString(entry_name);return _emscripten_bind_MetadataQuerier_GetDoubleEntry_2(self,metadata,entry_name)};MetadataQuerier.prototype["GetStringEntry"]=MetadataQuerier.prototype.GetStringEntry=function(metadata,entry_name){var self=this.ptr;ensureCache.prepare();if(metadata&&typeof metadata==="object")metadata=metadata.ptr;if(entry_name&&typeof entry_name==="object")entry_name=entry_name.ptr;else entry_name=ensureString(entry_name);return UTF8ToString(_emscripten_bind_MetadataQuerier_GetStringEntry_2(self,metadata,entry_name))};MetadataQuerier.prototype["NumEntries"]=MetadataQuerier.prototype.NumEntries=function(metadata){var self=this.ptr;if(metadata&&typeof metadata==="object")metadata=metadata.ptr;return _emscripten_bind_MetadataQuerier_NumEntries_1(self,metadata)};MetadataQuerier.prototype["GetEntryName"]=MetadataQuerier.prototype.GetEntryName=function(metadata,entry_id){var self=this.ptr;if(metadata&&typeof metadata==="object")metadata=metadata.ptr;if(entry_id&&typeof entry_id==="object")entry_id=entry_id.ptr;return UTF8ToString(_emscripten_bind_MetadataQuerier_GetEntryName_2(self,metadata,entry_id))};MetadataQuerier.prototype["__destroy__"]=MetadataQuerier.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_MetadataQuerier___destroy___0(self);};function Decoder(){this.ptr=_emscripten_bind_Decoder_Decoder_0();getCache(Decoder)[this.ptr]=this;}Decoder.prototype=Object.create(WrapperObject.prototype);Decoder.prototype.constructor=Decoder;Decoder.prototype.__class__=Decoder;Decoder.__cache__={};Module["Decoder"]=Decoder;Decoder.prototype["DecodeArrayToPointCloud"]=Decoder.prototype.DecodeArrayToPointCloud=function(data,data_size,out_point_cloud){var self=this.ptr;ensureCache.prepare();if(typeof data=="object"){data=ensureInt8(data);}if(data_size&&typeof data_size==="object")data_size=data_size.ptr;if(out_point_cloud&&typeof out_point_cloud==="object")out_point_cloud=out_point_cloud.ptr;return wrapPointer(_emscripten_bind_Decoder_DecodeArrayToPointCloud_3(self,data,data_size,out_point_cloud),Status)};Decoder.prototype["DecodeArrayToMesh"]=Decoder.prototype.DecodeArrayToMesh=function(data,data_size,out_mesh){var self=this.ptr;ensureCache.prepare();if(typeof data=="object"){data=ensureInt8(data);}if(data_size&&typeof data_size==="object")data_size=data_size.ptr;if(out_mesh&&typeof out_mesh==="object")out_mesh=out_mesh.ptr;return wrapPointer(_emscripten_bind_Decoder_DecodeArrayToMesh_3(self,data,data_size,out_mesh),Status)};Decoder.prototype["GetAttributeId"]=Decoder.prototype.GetAttributeId=function(pc,type){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(type&&typeof type==="object")type=type.ptr;return _emscripten_bind_Decoder_GetAttributeId_2(self,pc,type)};Decoder.prototype["GetAttributeIdByName"]=Decoder.prototype.GetAttributeIdByName=function(pc,name){var self=this.ptr;ensureCache.prepare();if(pc&&typeof pc==="object")pc=pc.ptr;if(name&&typeof name==="object")name=name.ptr;else name=ensureString(name);return _emscripten_bind_Decoder_GetAttributeIdByName_2(self,pc,name)};Decoder.prototype["GetAttributeIdByMetadataEntry"]=Decoder.prototype.GetAttributeIdByMetadataEntry=function(pc,name,value){var self=this.ptr;ensureCache.prepare();if(pc&&typeof pc==="object")pc=pc.ptr;if(name&&typeof name==="object")name=name.ptr;else name=ensureString(name);if(value&&typeof value==="object")value=value.ptr;else value=ensureString(value);return _emscripten_bind_Decoder_GetAttributeIdByMetadataEntry_3(self,pc,name,value)};Decoder.prototype["GetAttribute"]=Decoder.prototype.GetAttribute=function(pc,att_id){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(att_id&&typeof att_id==="object")att_id=att_id.ptr;return wrapPointer(_emscripten_bind_Decoder_GetAttribute_2(self,pc,att_id),PointAttribute)};Decoder.prototype["GetAttributeByUniqueId"]=Decoder.prototype.GetAttributeByUniqueId=function(pc,unique_id){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(unique_id&&typeof unique_id==="object")unique_id=unique_id.ptr;return wrapPointer(_emscripten_bind_Decoder_GetAttributeByUniqueId_2(self,pc,unique_id),PointAttribute)};Decoder.prototype["GetMetadata"]=Decoder.prototype.GetMetadata=function(pc){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;return wrapPointer(_emscripten_bind_Decoder_GetMetadata_1(self,pc),Metadata)};Decoder.prototype["GetAttributeMetadata"]=Decoder.prototype.GetAttributeMetadata=function(pc,att_id){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(att_id&&typeof att_id==="object")att_id=att_id.ptr;return wrapPointer(_emscripten_bind_Decoder_GetAttributeMetadata_2(self,pc,att_id),Metadata)};Decoder.prototype["GetFaceFromMesh"]=Decoder.prototype.GetFaceFromMesh=function(m,face_id,out_values){var self=this.ptr;if(m&&typeof m==="object")m=m.ptr;if(face_id&&typeof face_id==="object")face_id=face_id.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetFaceFromMesh_3(self,m,face_id,out_values)};Decoder.prototype["GetTriangleStripsFromMesh"]=Decoder.prototype.GetTriangleStripsFromMesh=function(m,strip_values){var self=this.ptr;if(m&&typeof m==="object")m=m.ptr;if(strip_values&&typeof strip_values==="object")strip_values=strip_values.ptr;return _emscripten_bind_Decoder_GetTriangleStripsFromMesh_2(self,m,strip_values)};Decoder.prototype["GetTrianglesUInt16Array"]=Decoder.prototype.GetTrianglesUInt16Array=function(m,out_size,out_values){var self=this.ptr;if(m&&typeof m==="object")m=m.ptr;if(out_size&&typeof out_size==="object")out_size=out_size.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetTrianglesUInt16Array_3(self,m,out_size,out_values)};Decoder.prototype["GetTrianglesUInt32Array"]=Decoder.prototype.GetTrianglesUInt32Array=function(m,out_size,out_values){var self=this.ptr;if(m&&typeof m==="object")m=m.ptr;if(out_size&&typeof out_size==="object")out_size=out_size.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetTrianglesUInt32Array_3(self,m,out_size,out_values)};Decoder.prototype["GetAttributeFloat"]=Decoder.prototype.GetAttributeFloat=function(pa,att_index,out_values){var self=this.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(att_index&&typeof att_index==="object")att_index=att_index.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeFloat_3(self,pa,att_index,out_values)};Decoder.prototype["GetAttributeFloatForAllPoints"]=Decoder.prototype.GetAttributeFloatForAllPoints=function(pc,pa,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeFloatForAllPoints_3(self,pc,pa,out_values)};Decoder.prototype["GetAttributeIntForAllPoints"]=Decoder.prototype.GetAttributeIntForAllPoints=function(pc,pa,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeIntForAllPoints_3(self,pc,pa,out_values)};Decoder.prototype["GetAttributeInt8ForAllPoints"]=Decoder.prototype.GetAttributeInt8ForAllPoints=function(pc,pa,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeInt8ForAllPoints_3(self,pc,pa,out_values)};Decoder.prototype["GetAttributeUInt8ForAllPoints"]=Decoder.prototype.GetAttributeUInt8ForAllPoints=function(pc,pa,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeUInt8ForAllPoints_3(self,pc,pa,out_values)};Decoder.prototype["GetAttributeInt16ForAllPoints"]=Decoder.prototype.GetAttributeInt16ForAllPoints=function(pc,pa,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeInt16ForAllPoints_3(self,pc,pa,out_values)};Decoder.prototype["GetAttributeUInt16ForAllPoints"]=Decoder.prototype.GetAttributeUInt16ForAllPoints=function(pc,pa,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeUInt16ForAllPoints_3(self,pc,pa,out_values)};Decoder.prototype["GetAttributeInt32ForAllPoints"]=Decoder.prototype.GetAttributeInt32ForAllPoints=function(pc,pa,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeInt32ForAllPoints_3(self,pc,pa,out_values)};Decoder.prototype["GetAttributeUInt32ForAllPoints"]=Decoder.prototype.GetAttributeUInt32ForAllPoints=function(pc,pa,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeUInt32ForAllPoints_3(self,pc,pa,out_values)};Decoder.prototype["GetAttributeDataArrayForAllPoints"]=Decoder.prototype.GetAttributeDataArrayForAllPoints=function(pc,pa,data_type,out_size,out_values){var self=this.ptr;if(pc&&typeof pc==="object")pc=pc.ptr;if(pa&&typeof pa==="object")pa=pa.ptr;if(data_type&&typeof data_type==="object")data_type=data_type.ptr;if(out_size&&typeof out_size==="object")out_size=out_size.ptr;if(out_values&&typeof out_values==="object")out_values=out_values.ptr;return !!_emscripten_bind_Decoder_GetAttributeDataArrayForAllPoints_5(self,pc,pa,data_type,out_size,out_values)};Decoder.prototype["SkipAttributeTransform"]=Decoder.prototype.SkipAttributeTransform=function(att_type){var self=this.ptr;if(att_type&&typeof att_type==="object")att_type=att_type.ptr;_emscripten_bind_Decoder_SkipAttributeTransform_1(self,att_type);};Decoder.prototype["GetEncodedGeometryType_Deprecated"]=Decoder.prototype.GetEncodedGeometryType_Deprecated=function(in_buffer){var self=this.ptr;if(in_buffer&&typeof in_buffer==="object")in_buffer=in_buffer.ptr;return _emscripten_bind_Decoder_GetEncodedGeometryType_Deprecated_1(self,in_buffer)};Decoder.prototype["DecodeBufferToPointCloud"]=Decoder.prototype.DecodeBufferToPointCloud=function(in_buffer,out_point_cloud){var self=this.ptr;if(in_buffer&&typeof in_buffer==="object")in_buffer=in_buffer.ptr;if(out_point_cloud&&typeof out_point_cloud==="object")out_point_cloud=out_point_cloud.ptr;return wrapPointer(_emscripten_bind_Decoder_DecodeBufferToPointCloud_2(self,in_buffer,out_point_cloud),Status)};Decoder.prototype["DecodeBufferToMesh"]=Decoder.prototype.DecodeBufferToMesh=function(in_buffer,out_mesh){var self=this.ptr;if(in_buffer&&typeof in_buffer==="object")in_buffer=in_buffer.ptr;if(out_mesh&&typeof out_mesh==="object")out_mesh=out_mesh.ptr;return wrapPointer(_emscripten_bind_Decoder_DecodeBufferToMesh_2(self,in_buffer,out_mesh),Status)};Decoder.prototype["__destroy__"]=Decoder.prototype.__destroy__=function(){var self=this.ptr;_emscripten_bind_Decoder___destroy___0(self);};(function(){function setupEnums(){Module["ATTRIBUTE_INVALID_TRANSFORM"]=_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_INVALID_TRANSFORM();Module["ATTRIBUTE_NO_TRANSFORM"]=_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_NO_TRANSFORM();Module["ATTRIBUTE_QUANTIZATION_TRANSFORM"]=_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_QUANTIZATION_TRANSFORM();Module["ATTRIBUTE_OCTAHEDRON_TRANSFORM"]=_emscripten_enum_draco_AttributeTransformType_ATTRIBUTE_OCTAHEDRON_TRANSFORM();Module["INVALID"]=_emscripten_enum_draco_GeometryAttribute_Type_INVALID();Module["POSITION"]=_emscripten_enum_draco_GeometryAttribute_Type_POSITION();Module["NORMAL"]=_emscripten_enum_draco_GeometryAttribute_Type_NORMAL();Module["COLOR"]=_emscripten_enum_draco_GeometryAttribute_Type_COLOR();Module["TEX_COORD"]=_emscripten_enum_draco_GeometryAttribute_Type_TEX_COORD();Module["GENERIC"]=_emscripten_enum_draco_GeometryAttribute_Type_GENERIC();Module["INVALID_GEOMETRY_TYPE"]=_emscripten_enum_draco_EncodedGeometryType_INVALID_GEOMETRY_TYPE();Module["POINT_CLOUD"]=_emscripten_enum_draco_EncodedGeometryType_POINT_CLOUD();Module["TRIANGULAR_MESH"]=_emscripten_enum_draco_EncodedGeometryType_TRIANGULAR_MESH();Module["DT_INVALID"]=_emscripten_enum_draco_DataType_DT_INVALID();Module["DT_INT8"]=_emscripten_enum_draco_DataType_DT_INT8();Module["DT_UINT8"]=_emscripten_enum_draco_DataType_DT_UINT8();Module["DT_INT16"]=_emscripten_enum_draco_DataType_DT_INT16();Module["DT_UINT16"]=_emscripten_enum_draco_DataType_DT_UINT16();Module["DT_INT32"]=_emscripten_enum_draco_DataType_DT_INT32();Module["DT_UINT32"]=_emscripten_enum_draco_DataType_DT_UINT32();Module["DT_INT64"]=_emscripten_enum_draco_DataType_DT_INT64();Module["DT_UINT64"]=_emscripten_enum_draco_DataType_DT_UINT64();Module["DT_FLOAT32"]=_emscripten_enum_draco_DataType_DT_FLOAT32();Module["DT_FLOAT64"]=_emscripten_enum_draco_DataType_DT_FLOAT64();Module["DT_BOOL"]=_emscripten_enum_draco_DataType_DT_BOOL();Module["DT_TYPES_COUNT"]=_emscripten_enum_draco_DataType_DT_TYPES_COUNT();Module["OK"]=_emscripten_enum_draco_StatusCode_OK();Module["DRACO_ERROR"]=_emscripten_enum_draco_StatusCode_DRACO_ERROR();Module["IO_ERROR"]=_emscripten_enum_draco_StatusCode_IO_ERROR();Module["INVALID_PARAMETER"]=_emscripten_enum_draco_StatusCode_INVALID_PARAMETER();Module["UNSUPPORTED_VERSION"]=_emscripten_enum_draco_StatusCode_UNSUPPORTED_VERSION();Module["UNKNOWN_VERSION"]=_emscripten_enum_draco_StatusCode_UNKNOWN_VERSION();}if(runtimeInitialized)setupEnums();else addOnInit(setupEnums);})();if(typeof Module["onModuleParsed"]==="function"){Module["onModuleParsed"]();}Module["Decoder"].prototype.GetEncodedGeometryType=function(array){if(array.__class__&&array.__class__===Module.DecoderBuffer){return Module.Decoder.prototype.GetEncodedGeometryType_Deprecated(array)}if(array.byteLength<8)return Module.INVALID_GEOMETRY_TYPE;switch(array[7]){case 0:return Module.POINT_CLOUD;case 1:return Module.TRIANGULAR_MESH;default:return Module.INVALID_GEOMETRY_TYPE}};


  return DracoDecoderModule.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = DracoDecoderModule;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return DracoDecoderModule; });
else if (typeof exports === 'object')
  exports["DracoDecoderModule"] = DracoDecoderModule;

class ModelLoader {
    constructor(gl, gpuResources) {
        this.loadedModels = new Map();
        this.gl = gl;
        this.gpuResources = gpuResources;
        this.createWebIO();
    }
    async createWebIO() {
        const dracoDecoder = await DracoDecoderModule();
        console.log('ModelLoader: dracoDecoder loaded');
        this.webio = new WebIO()
            .registerExtensions([...ALL_EXTENSIONS])
            .registerDependencies({
            'draco3d.decoder': dracoDecoder
        });
    }
    async loadModel(url) {
        /*    try { */
        // Generate deterministic model ID from URL
        const modelId = this.generateModelId(url);
        // Check if already loaded
        if (this.loadedModels.has(modelId.id)) {
            return modelId;
        }
        // Load and parse GLB file
        const document = await this.webio.read(url);
        console.log('ModelLoader: read', document);
        const modelData = await this.processDocument(document);
        // Store model data
        this.loadedModels.set(modelId.id, modelData);
        return {
            id: modelId.id,
            meshCount: modelData.meshes.length
        };
        /*        } catch (error: unknown) {
                    const errorMessage = error instanceof Error
                        ? error.message
                        : 'Unknown error';
                        
                    throw this.createModelError(
                        ModelErrorCode.LOAD_FAILED,
                        `Failed to load model: ${errorMessage}`
                    );
                }*/
    }
    getModelData(modelId) {
        return this.loadedModels.get(modelId) || null;
    }
    deleteModel(modelId) {
        const modelData = this.loadedModels.get(modelId);
        if (!modelData)
            return;
        // Clean up GPU resources
        this.cleanupModelResources(modelData);
        this.loadedModels.delete(modelId);
    }
    async processDocument(document) {
        const modelData = {
            meshes: [],
            materials: [],
            animations: new Map(),
            jointData: []
        };
        /*
        await Promise.all([
            this.processMeshes(document, modelData),
            this.processMaterials(document, modelData),
            this.processAnimations(document, modelData),
            this.processJoints(document, modelData)
        ]);
        */
        // Process each component sequentially for easier debugging
        console.log('ModelLoader: processDocument', modelData);
        await this.processMeshes(document, modelData);
        console.log('ModelLoader: processMeshes', modelData);
        await this.processMaterials(document, modelData);
        console.log('ModelLoader: processMaterials', modelData);
        await this.processAnimations(document, modelData);
        console.log('ModelLoader: processAnimations', modelData);
        await this.processJoints(document, modelData);
        console.log('ModelLoader: processJoints', modelData);
        return modelData;
    }
    async processMeshes(document, modelData) {
        const meshes = document.getRoot().listMeshes();
        for (const mesh of meshes) {
            const modelMesh = {
                primitives: [],
                name: mesh.getName() || '',
            };
            for (const primitive of mesh.listPrimitives()) {
                const primData = await this.processPrimitive(primitive, document);
                modelMesh.primitives.push(primData);
            }
            modelData.meshes.push(modelMesh);
        }
    }
    processPrimitive(primitive, document) {
        var _a, _b;
        const vao = this.gpuResources.createVertexArray();
        this.gl.bindVertexArray(vao);
        const attributes = {};
        // Get position attribute first and validate
        const positionAttribute = primitive.getAttribute('POSITION');
        if (!positionAttribute) {
            throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Primitive missing required POSITION attribute');
        }
        const TYPE_TO_SIZE = {
            SCALAR: 1,
            VEC2: 2,
            VEC3: 3,
            VEC4: 4,
            MAT2: 4,
            MAT3: 9,
            MAT4: 16
        };
        // Process vertex attributes
        for (const semantic of primitive.listSemantics()) {
            const accessor = primitive.getAttribute(semantic);
            const buffer = this.createAttributeBuffer(accessor);
            attributes[semantic] = buffer;
            const location = this.getAttributeLocation(semantic);
            console.log('ModelLoader: processPrimitive', location, semantic);
            this.gl.enableVertexAttribArray(location);
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
            const componentType = accessor.getComponentType();
            const elementSize = (_a = TYPE_TO_SIZE[accessor.getType()]) !== null && _a !== void 0 ? _a : 1;
            const normalized = accessor.getNormalized();
            this.gl.vertexAttribPointer(location, elementSize, componentType, normalized, 0, // stride of 0 lets WebGL handle stride automatically
            0 // no offset needed
            );
        }
        // Process indices
        const indices = primitive.getIndices();
        const indexBuffer = indices ? this.createIndexBuffer(indices) : null;
        // Unbind VAO first
        this.gl.bindVertexArray(null);
        // Then unbind buffers
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
        return {
            material: this.getMaterialIndex(primitive, document),
            indexBuffer: indexBuffer,
            indexCount: (_b = indices === null || indices === void 0 ? void 0 : indices.getCount()) !== null && _b !== void 0 ? _b : 0,
            indexType: this.getIndexType(indices !== null && indices !== void 0 ? indices : null),
            vertexCount: positionAttribute.getCount(),
            hasSkin: !!primitive.getAttribute('JOINTS_0'),
            attributes,
            vao
        };
    }
    getMaterialIndex(primitive, document) {
        const material = primitive.getMaterial();
        const materials = document.getRoot().listMaterials();
        return material ? materials.indexOf(material) : 0;
    }
    async processMaterials(document, modelData) {
        var _a, _b;
        const materials = document.getRoot().listMaterials();
        for (const material of materials) {
            const materialData = {
                program: this.gpuResources.getDefaultShader(),
                textures: new Map(),
                uniforms: {
                    u_BaseColorFactor: Array.from(material.getBaseColorFactor() || [1, 1, 1, 1]),
                    u_MetallicFactor: (_a = material.getMetallicFactor()) !== null && _a !== void 0 ? _a : 1.0,
                    u_RoughnessFactor: (_b = material.getRoughnessFactor()) !== null && _b !== void 0 ? _b : 1.0,
                    u_EmissiveFactor: Array.from(material.getEmissiveFactor() || [0, 0, 0])
                }
            };
            // Iterate over the SAMPLER_TEXTURE_UNIT_MAP to assign textures
            for (const [samplerName, textureUnit] of Object.entries(SAMPLER_TEXTURE_UNIT_MAP)) {
                let texturePromise = null;
                switch (samplerName) {
                    case 'u_BaseColorSampler':
                        const baseColorTexture = material.getBaseColorTexture();
                        if (baseColorTexture) {
                            const textureInfo = material.getBaseColorTextureInfo();
                            texturePromise = this.loadTexture(baseColorTexture, textureInfo);
                        }
                        break;
                    case 'u_MetallicRoughnessSampler':
                        const metallicRoughnessTexture = material.getMetallicRoughnessTexture();
                        if (metallicRoughnessTexture) {
                            const textureInfo = material.getMetallicRoughnessTextureInfo();
                            texturePromise = this.loadTexture(metallicRoughnessTexture, textureInfo);
                        }
                        break;
                    case 'u_NormalSampler':
                        const normalTexture = material.getNormalTexture();
                        if (normalTexture) {
                            const textureInfo = material.getNormalTextureInfo();
                            texturePromise = this.loadTexture(normalTexture, textureInfo);
                        }
                        break;
                    case 'u_OcclusionSampler':
                        const occlusionTexture = material.getOcclusionTexture();
                        if (occlusionTexture) {
                            const textureInfo = material.getOcclusionTextureInfo();
                            texturePromise = this.loadTexture(occlusionTexture, textureInfo);
                        }
                        break;
                    case 'u_EmissiveSampler':
                        const emissiveTexture = material.getEmissiveTexture();
                        if (emissiveTexture) {
                            const textureInfo = material.getEmissiveTextureInfo();
                            texturePromise = this.loadTexture(emissiveTexture, textureInfo);
                        }
                        break;
                    // Add more cases here if additional samplers are defined in SAMPLER_TEXTURE_UNIT_MAP
                    default:
                        console.warn(`Unhandled sampler name: ${samplerName}`);
                }
                if (texturePromise) {
                    const texture = await texturePromise;
                    materialData.textures.set(samplerName, texture);
                }
            }
            modelData.materials.push(materialData);
            this.gpuResources.addMaterial(materialData);
        }
    }
    processAnimations(document, modelData) {
        const animations = document.getRoot().listAnimations();
        for (const animation of animations) {
            const clip = {
                name: animation.getName() || '',
                duration: this.calculateAnimationDuration(animation),
                tracks: []
            };
            // Process each channel instead of sampler directly
            for (const channel of animation.listChannels()) {
                const sampler = channel.getSampler();
                const targetNode = channel.getTargetNode();
                if (!sampler || !targetNode) {
                    throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Animation channel missing sampler or target node');
                }
                // Add this: Get the target path (rotation, translation, or scale)
                const targetPath = channel.getTargetPath();
                if (targetPath !== 'translation' &&
                    targetPath !== 'rotation' &&
                    targetPath !== 'scale') {
                    continue; // Skip non-skeletal animation channels
                }
                const jointIndex = modelData.jointData.findIndex(joint => joint.name === targetNode.getName());
                if (jointIndex === -1)
                    continue;
                // Modify to include transform type
                const track = this.processAnimationTrack(sampler, jointIndex, targetPath);
                clip.tracks.push(track);
            }
            modelData.animations.set(clip.name, clip);
        }
    }
    processJoints(document, modelData) {
        const skins = document.getRoot().listSkins();
        if (skins.length === 0)
            return;
        const skin = skins[0];
        const joints = skin.listJoints();
        if (joints.length === 0) {
            throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Skin contains no joints');
        }
        // Get all inverse bind matrices at once
        const inverseBindMatrices = skin.getInverseBindMatrices();
        if (!inverseBindMatrices) {
            throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Skin missing inverse bind matrices');
        }
        const matrices = inverseBindMatrices.getArray();
        if (!matrices) {
            throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Failed to get inverse bind matrices data');
        }
        modelData.jointData = joints.map((joint, index) => {
            // Get the inverse bind matrix for this joint (16 floats per matrix)
            const matrixOffset = index * 16;
            const inverseBindMatrix = new Float32Array(matrices.slice(matrixOffset, matrixOffset + 16));
            // Get child indices, validating each one
            const children = joint.listChildren()
                .map(child => joints.indexOf(child))
                .filter(idx => idx !== -1); // Remove any invalid indices
            return {
                index,
                name: joint.getName() || `joint_${index}`,
                inverseBindMatrix,
                children
            };
        });
    }
    cleanupModelResources(modelData) {
        // Should null-check resources before deletion
        for (const mesh of modelData.meshes) {
            for (const primitive of mesh.primitives) {
                if (primitive.vao)
                    this.gpuResources.deleteVertexArray(primitive.vao);
                if (primitive.indexBuffer)
                    this.gpuResources.deleteBuffer(primitive.indexBuffer);
                // Clean up attribute buffers
                Object.values(primitive.attributes).forEach(buffer => {
                    if (buffer)
                        this.gpuResources.deleteBuffer(buffer);
                });
            }
        }
        // Clean up textures
        for (const material of modelData.materials) {
            // Clean up all texture types
            for (const [_, texture] of material.textures) {
                if (texture) {
                    this.gpuResources.deleteTexture(texture);
                }
            }
        }
    }
    createModelError(code, message) {
        return createModelError(code, message);
    }
    generateModelId(url) {
        // Simple hash function for URL
        const hash = Array.from(url).reduce((hash, char) => ((hash << 5) - hash) + char.charCodeAt(0), 0);
        return {
            id: `model_${Math.abs(hash).toString(16)}`,
            meshCount: 0 // Will be updated after processing
        };
    }
    // Helper methods for buffer creation and texture loading...
    createAttributeBuffer(accessor) {
        const array = accessor.getArray();
        if (!array) {
            throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Accessor array is null');
        }
        return this.gpuResources.createBuffer(array, this.gl.DYNAMIC_DRAW);
    }
    createIndexBuffer(accessor) {
        const array = accessor.getArray();
        if (!array) {
            throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Index accessor array is null');
        }
        return this.gpuResources.createIndexBuffer(array, this.gl.STATIC_DRAW);
    }
    async loadTexture(textureNode, textureInfo) {
        var _a, _b, _c, _d;
        const imageData = await textureNode.getImage();
        if (!imageData) {
            throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Texture image data is null');
        }
        // Create a blob from the array buffer and convert to image
        const blob = new Blob([imageData], { type: 'image/png' });
        const imageUrl = URL.createObjectURL(blob);
        const image = await this.loadImage(imageUrl);
        URL.revokeObjectURL(imageUrl);
        const texture = this.gpuResources.createTexture(image);
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        // Get wrap modes from textureInfo or use defaults
        const wrapS = (_a = textureInfo === null || textureInfo === void 0 ? void 0 : textureInfo.getWrapS()) !== null && _a !== void 0 ? _a : this.gl.REPEAT;
        const wrapT = (_b = textureInfo === null || textureInfo === void 0 ? void 0 : textureInfo.getWrapT()) !== null && _b !== void 0 ? _b : this.gl.REPEAT;
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, wrapS);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, wrapT);
        // Get min/mag filters from textureInfo or use defaults
        const minFilter = (_c = textureInfo === null || textureInfo === void 0 ? void 0 : textureInfo.getMinFilter()) !== null && _c !== void 0 ? _c : this.gl.LINEAR_MIPMAP_LINEAR;
        const magFilter = (_d = textureInfo === null || textureInfo === void 0 ? void 0 : textureInfo.getMagFilter()) !== null && _d !== void 0 ? _d : this.gl.LINEAR;
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, minFilter);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, magFilter);
        // Generate mipmaps if using a mipmap filter
        if (minFilter === this.gl.LINEAR_MIPMAP_LINEAR ||
            minFilter === this.gl.LINEAR_MIPMAP_NEAREST ||
            minFilter === this.gl.NEAREST_MIPMAP_LINEAR ||
            minFilter === this.gl.NEAREST_MIPMAP_NEAREST) {
            this.gl.generateMipmap(this.gl.TEXTURE_2D);
        }
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        return texture;
    }
    loadImage(url) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = url;
        });
    }
    getIndexType(accessor) {
        var _a;
        return (_a = accessor === null || accessor === void 0 ? void 0 : accessor.getComponentType()) !== null && _a !== void 0 ? _a : this.gl.UNSIGNED_SHORT;
    }
    calculateAnimationDuration(animation) {
        let maxTime = 0;
        for (const sampler of animation.listSamplers()) {
            const inputAccessor = sampler.getInput();
            if (!inputAccessor) {
                throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Animation sampler missing input accessor');
            }
            const times = inputAccessor.getArray();
            if (times && times.length > 0) {
                maxTime = Math.max(maxTime, times[times.length - 1]);
            }
        }
        return maxTime;
    }
    processAnimationTrack(sampler, jointIndex, transformType) {
        const input = sampler.getInput();
        const output = sampler.getOutput();
        if (!input || !output) {
            throw this.createModelError(ModelErrorCode.INVALID_DATA, 'Animation sampler missing input or output accessor');
        }
        return {
            jointIndex,
            times: new Float32Array(input.getArray() || []),
            values: new Float32Array(output.getArray() || []),
            interpolation: sampler.getInterpolation(),
            transformType
        };
    }
    getAnimation(modelId, animationName) {
        const modelData = this.getModelData(modelId);
        return modelData === null || modelData === void 0 ? void 0 : modelData.animations.get(animationName);
    }
    createGLBuffer() {
        const buffer = this.gl.createBuffer();
        if (!buffer) {
            throw this.createModelError(ModelErrorCode.LOAD_FAILED, 'Failed to create WebGL buffer');
        }
        return buffer;
    }
    // Helper function to map semantics to attribute locations
    getAttributeLocation(semantic) {
        switch (semantic) {
            case 'POSITION': return 0;
            case 'NORMAL': return 1;
            case 'TEXCOORD_0': return 2;
            case 'JOINTS_0': return 3;
            case 'WEIGHTS_0': return 4;
            case 'TANGENT': return 5;
            default: throw this.createModelError(ModelErrorCode.INVALID_DATA, `Unsupported attribute semantic: ${semantic}`);
        }
    }
}

class GPUResourceManager {
    constructor(gl) {
        // Track resources for cleanup
        this.buffers = new Set();
        this.textures = new Set();
        this.vaos = new Set();
        this.MAX_LIGHTS = 8;
        this.lights = new Array(8);
        this.dirtyLightParams = false;
        this.dirtyLightStates = new Set();
        this.cameraPosition = [0, 0, 0];
        this.dirtyCameraPosition = false;
        this.gl = gl;
        this.shaderSystem = new ShaderSystem(gl);
        this.materialSystem = new MaterialSystem(gl, [], SAMPLER_TEXTURE_UNIT_MAP);
        // Initialize lights array with default values
        this.lights = Array(this.MAX_LIGHTS).fill(null).map(() => ({
            type: 'point',
            enabled: false,
            position: [0, 0, -5],
            color: [1, 1, 1],
            intensity: 0,
            attenuation: 1
        }));
    }
    createBuffer(data, usage) {
        const buffer = this.gl.createBuffer();
        if (!buffer) {
            throw this.createError(ModelErrorCode.GL_ERROR, 'Failed to create WebGL buffer');
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, data, usage);
        this.buffers.add(buffer);
        return buffer;
    }
    createIndexBuffer(data, usage) {
        const buffer = this.gl.createBuffer();
        if (!buffer) {
            throw this.createError(ModelErrorCode.GL_ERROR, 'Failed to create WebGL buffer');
        }
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, buffer);
        this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, data, usage);
        this.buffers.add(buffer);
        return buffer;
    }
    createTexture(image) {
        const texture = this.gl.createTexture();
        if (!texture) {
            throw this.createError(ModelErrorCode.GL_ERROR, 'Failed to create WebGL texture');
        }
        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);
        this.gl.generateMipmap(this.gl.TEXTURE_2D);
        this.textures.add(texture);
        return texture;
    }
    deleteBuffer(buffer) {
        this.gl.deleteBuffer(buffer);
        this.buffers.delete(buffer);
    }
    deleteTexture(texture) {
        this.gl.deleteTexture(texture);
        this.textures.delete(texture);
    }
    deleteVertexArray(vao) {
        this.gl.deleteVertexArray(vao);
        this.vaos.delete(vao);
    }
    createVertexArray() {
        if (!this.gl)
            throw new Error('Error, no gl context');
        const vao = this.gl.createVertexArray();
        if (!vao) {
            throw this.createError(ModelErrorCode.GL_ERROR, 'Failed to create WebGL vertex array object');
        }
        this.vaos.add(vao);
        return vao;
    }
    // Resource cleanup
    dispose() {
        // Clean up all resources
        this.buffers.forEach(buffer => this.deleteBuffer(buffer));
        this.textures.forEach(texture => this.deleteTexture(texture));
        this.vaos.forEach(vao => this.deleteVertexArray(vao));
        this.shaderSystem.dispose();
    }
    createError(code, message) {
        return { name: 'ModelError', code, message };
    }
    getShader(modelId) {
        const shader = this.shaderSystem.getProgram(modelId);
        if (!shader) {
            throw this.createError(ModelErrorCode.RESOURCE_NOT_FOUND, `Shader not found for model: ${modelId}`);
        }
        return shader;
    }
    setNormalMapEnabled(shader, enabled) {
        const location = this.gl.getUniformLocation(shader, 'u_UseNormalMap');
        if (location) {
            this.gl.uniform1i(location, enabled ? 1 : 0);
        }
    }
    setLightPosition(shader, lightPosition) {
        const location = this.gl.getUniformLocation(shader, 'u_LightPosition');
        if (location) {
            this.gl.uniform3fv(location, lightPosition);
        }
    }
    getDefaultShader() {
        const vertexShader = `#version 300 es
        layout(location = 0) in vec3 position;
        layout(location = 1) in vec3 normal;
        layout(location = 2) in vec2 uv;
        layout(location = 3) in vec4 weights;
        layout(location = 4) in uvec4 joints;
        layout(location = 5) in vec4 tangent;

        uniform mat4 u_Model;
        uniform mat4 u_View;
        uniform mat4 u_Projection;
        uniform mat4 u_JointMatrices[64];  // Maximum number of joints
        uniform mat3 u_NormalMatrix;

        out vec2 v_UV;
        out vec3 v_Normal;
        out vec3 v_Position;
        out mat3 v_TBN;

        void main() {
            v_UV = uv;
            vec3 N = normalize(u_NormalMatrix * normal);
            vec3 T = normalize(u_NormalMatrix * tangent.xyz);
            // Calculate bitangent using cross product and tangent.w for handedness
            vec3 B = normalize(cross(N, T)) * tangent.w;
            
            // Create TBN matrix for transforming from tangent space to world space
            v_TBN = mat3(T, B, N);
            
            v_Normal = N;
            v_Position = (u_Model * vec4(position, 1.0)).xyz;
            gl_Position = u_Projection * u_View * u_Model * vec4(position, 1.0);
        }`;
        const fragmentShader = `#version 300 es
        #extension GL_EXT_shader_texture_lod : enable
        #extension GL_OES_standard_derivatives : enable
        precision highp float;

        // Light structure matching TypeScript definitions
        struct Light {
            bool enabled;
            int type;          // 0=point, 1=directional, 2=spot
            vec3 position;     // Used by point/spot
            vec3 direction;    // Used by directional/spot
            vec3 color;
            float intensity;
            float attenuation; // Used by point/spot
            float spotAngle;   // Used by spot
            float spotPenumbra;// Used by spot
        };

        const int MAX_LIGHTS = 8;
        uniform Light u_Lights[MAX_LIGHTS];

        in vec2 v_UV;
        in vec3 v_Normal;
        in vec3 v_Position;
        in mat3 v_TBN;

        uniform vec3 u_CameraPosition;
        uniform vec4 u_BaseColorFactor;
        uniform vec3 u_EmissiveFactor;
        uniform float u_MetallicFactor;
        uniform float u_RoughnessFactor;

        uniform sampler2D u_BaseColorSampler;
        uniform sampler2D u_NormalSampler;
        uniform sampler2D u_MetallicRoughnessSampler;
        uniform sampler2D u_OcclusionSampler;
        uniform sampler2D u_EmissiveSampler;
        uniform bool u_UseNormalMap;

        layout(location = 0) out vec4 fragColor;

        const float PI = 3.141592653589793;
        const float MIN_ROUGHNESS = 0.04;

        // Convert SRGB to Linear space
        vec3 SRGBtoLinear(vec3 srgb) {
            return pow(srgb, vec3(2.2));
        }

        // Obtain the normal vector
        vec3 getNormal() {
            if (u_UseNormalMap) {
                // Sample normal from normal map and transform to [-1,1] range
                vec3 normalMap = texture(u_NormalSampler, v_UV).rgb * 2.0 - 1.0;
                // Transform normal from tangent space to world space using TBN matrix
                return normalize(v_TBN * normalMap);
            } else {
                return normalize(v_Normal);
            }
        }

        // Calculate Fresnel Reflectance
        vec3 fresnelSchlick(float cosTheta, vec3 F0) {
            return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
        }

        // Calculate Geometry Occlusion (G) using Schlick-GGX
        float geometrySchlickGGX(float NdotV, float roughness) {
            float a = roughness;
            float k = (a * a) / 2.0;

            float nom = NdotV;
            float denom = NdotV * (1.0 - k) + k;

            return nom / denom;
        }

        // Calculate Geometry Function (G)
        float geometrySmith(float NdotV, float NdotL, float roughness) {
            float ggx2 = geometrySchlickGGX(NdotV, roughness);
            float ggx1 = geometrySchlickGGX(NdotL, roughness);
            return ggx1 * ggx2;
        }

        // Calculate Normal Distribution Function (D) using GGX
        float distributionGGX(vec3 N, vec3 H, float roughness) {
            float a = roughness * roughness;
            float a2 = a * a;
            float NdotH = max(dot(N, H), 0.0);
            float NdotH2 = NdotH * NdotH;

            float nom = a2;
            float denom = (NdotH2 * (a2 - 1.0) + 1.0);
            denom = PI * denom * denom;

            return nom / denom;
        }

        // Calculate light contribution based on type
        vec3 calculateLightContribution(Light light, vec3 N, vec3 V, vec3 baseColor, float metallic, float roughness) {
            if (!light.enabled) return vec3(0.0);
            
            vec3 L;
            float attenuation = 1.0;
            
            // Calculate light direction and attenuation based on light type
            if (light.type == 0) { // Point light
                vec3 lightDir = light.position - v_Position;
                float distance = length(lightDir);
                L = normalize(lightDir);
                attenuation = 1.0 / (1.0 + light.attenuation * distance * distance);
            } 
            else if (light.type == 1) { // Directional light
                L = normalize(-light.direction);
            }
            else if (light.type == 2) { // Spot light
                vec3 lightDir = light.position - v_Position;
                float distance = length(lightDir);
                L = normalize(lightDir);
                
                // Spot light cone calculation
                float cosTheta = dot(L, normalize(-light.direction));
                float cosCutoff = light.spotAngle;
                float cosOuterCutoff = light.spotAngle * (1.0 - light.spotPenumbra);
                float epsilon = cosCutoff - cosOuterCutoff;
                float spotIntensity = clamp((cosTheta - cosOuterCutoff) / epsilon, 0.0, 1.0);
                
                attenuation = spotIntensity / (1.0 + light.attenuation * distance * distance);
            }
            
            vec3 H = normalize(V + L);
            float NdotL = max(dot(N, L), 0.0);
            
            if (NdotL <= 0.0) return vec3(0.0);
            
            // Calculate F0 (surface reflection at zero incidence)
            vec3 F0 = mix(vec3(0.04), baseColor, metallic);
            
            // Calculate specular and diffuse components
            vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
            float D = distributionGGX(N, H, roughness);
            float G = geometrySmith(max(dot(N, V), 0.0), NdotL, roughness);
            
            vec3 specular = (F * D * G) / max(4.0 * max(dot(N, V), 0.0) * NdotL, 0.001);
            vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);
            vec3 diffuse = kD * baseColor / PI;
            
            return (diffuse + specular) * light.color * light.intensity * NdotL * attenuation;
        }

        void main() {
            vec3 N = getNormal();
            vec3 V = normalize(u_CameraPosition - v_Position);
            
            // Sample material textures
            vec4 baseColorSample = texture(u_BaseColorSampler, v_UV) * u_BaseColorFactor;
            vec4 metallicRoughness = texture(u_MetallicRoughnessSampler, v_UV);
            vec4 emissiveSample = texture(u_EmissiveSampler, v_UV) * vec4(u_EmissiveFactor, 1.0);
            float aoSample = texture(u_OcclusionSampler, v_UV).r;
            
            vec3 baseColor = SRGBtoLinear(baseColorSample.rgb);
            float metallic = metallicRoughness.b * u_MetallicFactor;
            float roughness = max(metallicRoughness.g * u_RoughnessFactor, MIN_ROUGHNESS);
            
            // Calculate lighting
            vec3 color = vec3(0.0);
            for(int i = 0; i < MAX_LIGHTS; i++) {
                color += calculateLightContribution(u_Lights[i], N, V, baseColor, metallic, roughness);
            }
            
            // Add ambient and emissive
            vec3 ambient = vec3(0.03) * baseColor * aoSample;
            vec3 emissive = SRGBtoLinear(emissiveSample.rgb);
            color += ambient + emissive;
            
            // Tone mapping and gamma correction
            color = color / (color + vec3(1.0)); // Simple Reinhard tone mapping
            color = pow(color, vec3(1.0/2.2));   // Gamma correction
            
            fragColor = vec4(color, baseColorSample.a);
            // fragColor = vec4(baseColorSample.rgb * NdotL, baseColorSample.a);
            // Debug: Output normal as color
            // fragColor = vec4(N * 0.5 + 0.5, 1.0);
            // fragColor = vec4(vec3(NdotL), baseColorSample.a);
        }`;
        return this.shaderSystem.createProgram(vertexShader, fragmentShader, 'default');
    }
    bindMaterial(materialIndex, shader) {
        this.materialSystem.bindMaterial(materialIndex, shader);
    }
    addMaterial(material) {
        this.materialSystem.addMaterial(material);
    }
    updateLight(index, lightParams) {
        if (index >= this.MAX_LIGHTS)
            return;
        Object.assign(this.lights[index], lightParams);
        this.dirtyLightParams = true;
    }
    updateCameraPosition(position) {
        this.cameraPosition = position;
        this.dirtyCameraPosition = true;
    }
    setLightEnabled(index, enabled) {
        if (index >= this.MAX_LIGHTS)
            return;
        this.lights[index].enabled = enabled;
        this.dirtyLightStates.add(index);
    }
    updateLightUniforms(shader) {
        if (this.dirtyLightParams) {
            this.updateAllLightUniforms(shader);
            this.dirtyLightParams = false;
            this.dirtyLightStates.clear();
        }
        else if (this.dirtyLightStates.size > 0) {
            this.updateLightEnableStates(shader);
            this.dirtyLightStates.clear();
        }
    }
    updateCameraPositionUniforms(shader) {
        if (this.dirtyCameraPosition) {
            this.gl.uniform3fv(this.gl.getUniformLocation(shader, 'u_CameraPosition'), this.cameraPosition);
            this.dirtyCameraPosition = false;
        }
    }
    updateAllLightUniforms(shader) {
        for (let i = 0; i < this.MAX_LIGHTS; i++) {
            const light = this.lights[i];
            const prefix = `u_Lights[${i}]`;
            this.gl.uniform1i(this.gl.getUniformLocation(shader, `${prefix}.enabled`), light.enabled ? 1 : 0);
            this.gl.uniform1i(this.gl.getUniformLocation(shader, `${prefix}.type`), this.getLightTypeValue(light.type));
            this.gl.uniform3fv(this.gl.getUniformLocation(shader, `${prefix}.color`), light.color);
            this.gl.uniform1f(this.gl.getUniformLocation(shader, `${prefix}.intensity`), light.intensity);
            if ('position' in light) {
                this.gl.uniform3fv(this.gl.getUniformLocation(shader, `${prefix}.position`), light.position);
            }
            if ('direction' in light) {
                this.gl.uniform3fv(this.gl.getUniformLocation(shader, `${prefix}.direction`), light.direction);
            }
            if ('attenuation' in light) {
                this.gl.uniform1f(this.gl.getUniformLocation(shader, `${prefix}.attenuation`), light.attenuation);
            }
            if ('spotAngle' in light) {
                this.gl.uniform1f(this.gl.getUniformLocation(shader, `${prefix}.spotAngle`), light.spotAngle);
                this.gl.uniform1f(this.gl.getUniformLocation(shader, `${prefix}.spotPenumbra`), light.spotPenumbra);
            }
        }
    }
    updateLightEnableStates(shader) {
        for (const index of this.dirtyLightStates) {
            const location = this.gl.getUniformLocation(shader, `u_Lights[${index}].enabled`);
            if (location) {
                this.gl.uniform1i(location, this.lights[index].enabled ? 1 : 0);
            }
        }
    }
    getLightTypeValue(type) {
        switch (type) {
            case 'point': return 0;
            case 'directional': return 1;
            case 'spot': return 2;
            default: return 0;
        }
    }
    bindShaderAndMaterial(shader, materialIndex) {
        this.gl.useProgram(shader);
        this.updateCameraPositionUniforms(shader);
        this.updateLightUniforms(shader);
        this.bindMaterial(materialIndex, shader);
    }
    setLightDirection(index, direction) {
        if (index >= this.MAX_LIGHTS)
            return;
        if (this.lights[index].type !== 'directional')
            return;
        this.lights[index].direction = direction;
        this.dirtyLightParams = true;
    }
    setLightColor(index, color) {
        if (index >= this.MAX_LIGHTS)
            return;
        this.lights[index].color = color;
        this.dirtyLightParams = true;
    }
    setLightIntensity(index, intensity) {
        if (index >= this.MAX_LIGHTS)
            return;
        this.lights[index].intensity = intensity;
        this.dirtyLightParams = true;
    }
    setSpotLightParams(index, angle, penumbra) {
        if (index >= this.MAX_LIGHTS || this.lights[index].type !== 'spot')
            return;
        this.lights[index].spotAngle = angle;
        this.lights[index].spotPenumbra = penumbra;
        this.dirtyLightParams = true;
    }
}
// MaterialSystem for handling materials and shaders
class MaterialSystem {
    constructor(gl, materials, samplerTextureUnitMap) {
        this.currentMaterial = null;
        this.gl = gl;
        this.materials = new Map(materials.map((mat, index) => [index, mat]));
        this.samplerTextureUnitMap = samplerTextureUnitMap;
    }
    addMaterial(material) {
        this.materials.set(this.materials.size, material);
    }
    bindMaterial(materialIndex, shader) {
        if (this.currentMaterial === materialIndex)
            return;
        const material = this.materials.get(materialIndex);
        if (!material)
            return;
        this.applyMaterial(material, shader);
        this.currentMaterial = materialIndex;
    }
    applyMaterial(material, shader) {
        // Bind textures to their fixed texture units based on sampler names
        material.textures.forEach((texture, samplerName) => {
            const textureUnit = this.samplerTextureUnitMap[samplerName];
            if (textureUnit === undefined) {
                console.warn(`No texture unit defined for sampler '${samplerName}'.`);
                return;
            }
            const location = this.gl.getUniformLocation(shader, samplerName);
            if (location === null) {
                console.warn(`Uniform sampler '${samplerName}' not found in shader.`);
                return;
            }
            this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
            this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
            this.gl.uniform1i(location, textureUnit);
            // console.log(`Binding texture to unit ${textureUnit} for sampler '${samplerName}'`);
        });
        // Set material uniforms
        if (material.uniforms) {
            for (const [name, value] of Object.entries(material.uniforms)) {
                const location = this.gl.getUniformLocation(shader, name);
                if (location === null)
                    continue;
                // Handle different uniform types
                if (Array.isArray(value)) {
                    switch (value.length) {
                        case 2:
                            this.gl.uniform2fv(location, value);
                            break;
                        case 3:
                            this.gl.uniform3fv(location, value);
                            break;
                        case 4:
                            this.gl.uniform4fv(location, value);
                            break;
                        case 16:
                            this.gl.uniformMatrix4fv(location, false, value);
                            break;
                        default:
                            console.warn(`Unhandled uniform array length for '${name}': ${value.length}`);
                    }
                }
                else if (typeof value === 'number') {
                    this.gl.uniform1f(location, value);
                }
                else if (typeof value === 'boolean') {
                    this.gl.uniform1i(location, value ? 1 : 0);
                }
                else {
                    console.warn(`Unhandled uniform type for '${name}': ${typeof value}`);
                }
            }
        }
    }
}
// ShaderSystem for managing shaders and programs
class ShaderSystem {
    constructor(gl) {
        this.currentProgram = null;
        this.programs = new Map();
        this.gl = gl;
    }
    createProgram(vertexSource, fragmentSource, name) {
        const program = this.compileProgram(vertexSource, fragmentSource);
        this.programs.set(name, program);
        return program;
    }
    useProgram(name) {
        const program = this.programs.get(name);
        if (!program) {
            throw this.createError(ModelErrorCode.RESOURCE_NOT_FOUND, `Shader program '${name}' not found`);
        }
        if (this.currentProgram !== program) {
            this.gl.useProgram(program);
            this.currentProgram = program;
        }
    }
    compileProgram(vertexSource, fragmentSource) {
        const vertexShader = this.compileShader(vertexSource, this.gl.VERTEX_SHADER);
        const fragmentShader = this.compileShader(fragmentSource, this.gl.FRAGMENT_SHADER);
        const program = this.gl.createProgram();
        if (!program) {
            throw this.createError(ModelErrorCode.GL_ERROR, 'Failed to create shader program');
        }
        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);
        // Check for linking errors
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            const info = this.gl.getProgramInfoLog(program);
            this.gl.deleteProgram(program);
            throw this.createError(ModelErrorCode.GL_ERROR, `Failed to link shader program: ${info}`);
        }
        // Clean up individual shaders as they're no longer needed
        this.gl.deleteShader(vertexShader);
        this.gl.deleteShader(fragmentShader);
        return program;
    }
    compileShader(source, type) {
        const shader = this.gl.createShader(type);
        if (!shader) {
            throw this.createError(ModelErrorCode.GL_ERROR, 'Failed to create shader');
        }
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        // Check for compilation errors
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            const info = this.gl.getShaderInfoLog(shader);
            this.gl.deleteShader(shader);
            throw this.createError(ModelErrorCode.GL_ERROR, `Failed to compile ${type === this.gl.VERTEX_SHADER ? 'vertex' : 'fragment'} shader: ${info}`);
        }
        return shader;
    }
    createError(code, message) {
        return { name: 'ModelError', code, message };
    }
    getProgram(name) {
        const program = this.programs.get(name);
        if (!program) {
            throw this.createError(ModelErrorCode.RESOURCE_NOT_FOUND, `Shader program '${name}' not found`);
        }
        return program;
    }
    dispose() {
        // Clean up all resources
        this.programs.forEach(program => this.gl.deleteProgram(program));
    }
}

/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create$4() {
  var out = new ARRAY_TYPE(9);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create$3() {
  var out = new ARRAY_TYPE(16);

  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
 * which matches WebGL/OpenGL's clip volume.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Alias for {@link mat4.perspectiveNO}
 * @function
 */

var perspective = perspectiveNO;
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create$2() {
  var out = new ARRAY_TYPE(3);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize$2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$2();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
})();

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create$1() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize$1(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

(function () {
  var vec = create$1();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
})();

/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new ARRAY_TYPE(4);

  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > EPSILON) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = normalize$1;
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

(function () {
  var tmpvec3 = create$2();
  var xUnitVec3 = fromValues(1, 0, 0);
  var yUnitVec3 = fromValues(0, 1, 0);
  return function (out, a, b) {
    var dot$1 = dot(a, b);

    if (dot$1 < -0.999999) {
      cross(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
      normalize$2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot$1 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot$1;
      return normalize(out, out);
    }
  };
})();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

(function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
})();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

(function () {
  var matr = create$4();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
})();

class Model {
    constructor(instanceId, manager) {
        this.instanceId = instanceId;
        this.manager = manager;
    }
    setNormalMapEnabled(enabled) {
        this.manager.setModelNormalMapEnabled(enabled, this);
    }
    setPosition(x, y, z) {
        this.manager.setModelPosition(x, y, z, this);
    }
    setRotation(quaternion) {
        this.manager.setModelRotation(quaternion, this);
    }
    setScale(x, y, z) {
        this.manager.setModelScale(x, y, z, this);
    }
    playAnimation(animationName, options) {
        this.manager.playModelAnimation(animationName, this, options);
    }
    stopAnimation() {
        this.manager.stopModelAnimation(this);
    }
    // Additional convenience methods
    setQuaternion(x, y, z, w) {
        const quat = new Float32Array([x, y, z, w]);
        this.manager.setModelRotation(quat, this);
    }
    // Helper for converting Euler angles to quaternion
    eulerToQuaternion(x, y, z) {
        // Create quaternion from Euler angles (XYZ order)
        const quaternion = create();
        fromEuler(quaternion, x, y, z);
        return quaternion;
    }
}

class AnimationController {
    constructor(modelLoader) {
        this.modelLoader = modelLoader;
    }
    updateAnimation(instance, deltaTime) {
        if (!instance.animationState.currentAnimation)
            return;
        // Update time
        const newTime = this.updateAnimationTime(instance.animationState, deltaTime, instance.instanceId.modelId);
        // Get animation data
        const animation = this.modelLoader.getAnimation(instance.instanceId.modelId, instance.animationState.currentAnimation);
        if (!animation) {
            this.stopAnimation(instance);
            return;
        }
        // Update instance state
        instance.animationState.currentTime = newTime;
        // Update joint matrices
        this.updateJointMatrices(instance, animation);
    }
    startAnimation(instance, animationName, options) {
        var _a, _b;
        instance.animationState = {
            currentAnimation: animationName,
            currentTime: 0,
            speed: (_a = options === null || options === void 0 ? void 0 : options.speed) !== null && _a !== void 0 ? _a : 1,
            loop: (_b = options === null || options === void 0 ? void 0 : options.loop) !== null && _b !== void 0 ? _b : true,
            blendFactor: (options === null || options === void 0 ? void 0 : options.blendDuration) ? 0 : undefined
        };
    }
    stopAnimation(instance) {
        instance.animationState.currentAnimation = null;
        instance.animationState.currentTime = 0;
        instance.animationState.blendFactor = undefined;
    }
    updateAnimationTime(state, deltaTime, modelId) {
        const newTime = state.currentTime + (deltaTime * state.speed);
        const animation = this.modelLoader.getAnimation(modelId, state.currentAnimation);
        if (!animation)
            return 0;
        // Handle looping
        if (state.loop) {
            return newTime % animation.duration;
        }
        // Handle non-looping animations
        return Math.min(newTime, animation.duration);
    }
    updateJointMatrices(instance, animation) {
        // Group transforms by joint
        const jointTransforms = new Map();
        // Collect transforms for each joint
        for (const track of animation.tracks) {
            let transforms = jointTransforms.get(track.jointIndex);
            if (!transforms) {
                transforms = {};
                jointTransforms.set(track.jointIndex, transforms);
            }
            const values = this.evaluateTrack(track, instance.animationState.currentTime);
            transforms[track.transformType] = values;
        }
        // Get model data for inverse bind matrices
        const modelData = this.modelLoader.getModelData(instance.instanceId.modelId);
        if (!modelData)
            return;
        // Compose final matrices
        const tempMat = create$3();
        const finalMat = create$3();
        for (const [jointIndex, transforms] of jointTransforms) {
            identity(tempMat);
            // Apply scale if present
            if (transforms.scale) {
                scale(tempMat, tempMat, transforms.scale);
            }
            // Apply rotation if present
            if (transforms.rotation) {
                const rotMat = create$3();
                fromQuat(rotMat, transforms.rotation);
                multiply(tempMat, tempMat, rotMat);
            }
            // Apply translation if present
            if (transforms.translation) {
                translate(tempMat, tempMat, transforms.translation);
            }
            // Apply inverse bind matrix
            const jointData = modelData.jointData[jointIndex];
            if (jointData) {
                multiply(finalMat, tempMat, jointData.inverseBindMatrix);
                instance.jointMatrices.set(finalMat, jointIndex * 16);
            }
            else {
                instance.jointMatrices.set(tempMat, jointIndex * 16);
            }
        }
    }
    evaluateTrack(track, time) {
        // Find the keyframes that bracket the current time
        let startIndex = 0;
        for (let i = 0; i < track.times.length - 1; i++) {
            if (track.times[i] <= time && track.times[i + 1] > time) {
                startIndex = i;
                break;
            }
        }
        const endIndex = startIndex + 1;
        // Handle edge cases
        if (endIndex >= track.times.length) {
            return track.values.slice(startIndex * track.values.length / track.times.length, (startIndex + 1) * track.values.length / track.times.length);
        }
        // Calculate interpolation factor (0 to 1)
        const startTime = track.times[startIndex];
        const endTime = track.times[endIndex];
        const factor = (time - startTime) / (endTime - startTime);
        const stride = track.values.length / track.times.length;
        const startOffset = startIndex * stride;
        const endOffset = endIndex * stride;
        const startValues = track.values.slice(startOffset, startOffset + stride);
        const endValues = track.values.slice(endOffset, endOffset + stride);
        if (track.interpolation === 'STEP') {
            return startValues;
        }
        // Only linear interpolation supported for now
        // TODO: Add support for cubic spline interpolation
        const result = new Float32Array(stride);
        if (track.transformType === 'rotation') {
            slerp(result, startValues, endValues, factor);
        }
        else {
            // Linear interpolation for translation and scale
            for (let i = 0; i < stride; i++) {
                result[i] = startValues[i] + (endValues[i] - startValues[i]) * factor;
            }
        }
        return result;
    }
}

class InstanceManager {
    constructor(gl, modelLoader, gpuResources) {
        this.gpuResources = gpuResources;
        this.instances = new Map();
        this.instancesByModel = new Map();
        // GPU instance data
        this.instanceBuffers = new Map();
        this.nextInstanceId = 1;
        this.dirtyInstances = new Set();
        this.gl = gl;
        this.modelLoader = modelLoader;
        this.animationController = new AnimationController(modelLoader);
        this.defaultShaderProgram = this.gpuResources.getDefaultShader();
    }
    initialize() {
        // Basic WebGL2 initialization
        this.gl.clearColor(0.1, 0.1, 0.1, 1.0);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.CULL_FACE);
        this.gl.cullFace(this.gl.BACK);
        // Enable blending for transparency
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        // Set viewport
        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);
        // Clear any existing buffers/state
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);
        this.gl.bindVertexArray(null);
        this.gl.useProgram(null);
        // Clear instance tracking
        this.dirtyInstances.clear();
        this.instanceBuffers.clear();
        // Clear canvas
        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
        // Enable additional WebGL features
        this.gl.enable(this.gl.SCISSOR_TEST); // For viewport clipping
        // Set pixel store parameters
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false); // Flip textures right-side up
        this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 4); // Standard pixel alignment
        // Set default texture parameters
        this.gl.activeTexture(this.gl.TEXTURE0);
        // Set default line width
        this.gl.lineWidth(1.0);
    }
    createViewProjection(fov, resolution, near, far, eye, center, up) {
        const projectionMatrix = create$3();
        perspective(projectionMatrix, fov * Math.PI / 180, resolution.width / resolution.height, near, far);
        const viewMatrix = create$3();
        lookAt(viewMatrix, eye, center, up);
        return { view: viewMatrix, projection: projectionMatrix };
    }
    createModel(modelId) {
        var _a, _b;
        // Verify model exists
        const modelData = this.modelLoader.getModelData(modelId);
        if (!modelData) {
            throw this.createError(ModelErrorCode.RESOURCE_NOT_FOUND, `Model ${modelId} not found`);
        }
        // Create instance data
        const instanceId = {
            id: this.nextInstanceId++,
            modelId
        };
        const instanceData = {
            instanceId,
            transform: {
                position: new Float32Array([0, 0, 0]),
                rotation: new Float32Array([0, 0, 0, 1]), // Quaternion
                scale: new Float32Array([1, 1, 1])
            },
            renderOptions: {
                useNormalMap: false
            },
            animationState: {
                currentAnimation: null,
                currentTime: 0,
                speed: 1,
                loop: true
            },
            jointMatrices: new Float32Array(((_b = (_a = modelData.jointData) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) * 16),
            worldMatrix: new Float32Array(16) // 4x4 matrix
        };
        // Store instance
        this.instances.set(instanceId.id, instanceData);
        // Add to model group
        this.addToModelGroup(instanceId);
        // Create Model interface
        return new Model(instanceId, this);
    }
    deleteModel(instanceId) {
        this.cleanupInstance(instanceId);
    }
    updateInstance(instanceId, deltaTime) {
        const instance = this.instances.get(instanceId);
        if (!instance)
            return;
        // Update animation if active
        if (instance.animationState.currentAnimation) {
            this.updateAnimation(instance, deltaTime);
        }
        // Update world matrix if transform is dirty
        if (this.dirtyInstances.has(instanceId)) {
            this.updateWorldMatrix(instance);
        }
    }
    render(viewProjection) {
        // Update GPU buffers for dirty instances
        if (this.dirtyInstances.size > 0) {
            this.updateGPUBuffers();
        }
        // Render each model group
        for (const [modelId, instanceGroup] of this.instancesByModel) {
            this.renderModelInstances(modelId, instanceGroup, viewProjection);
        }
    }
    setModelPosition(x, y, z, instance) {
        const instanceData = this.instances.get(instance.instanceId.id);
        if (instanceData) {
            instanceData.transform.position.set([x, y, z]);
            this.dirtyInstances.add(instance.instanceId.id);
        }
    }
    setModelRotation(quaternion, instance) {
        const instanceData = this.instances.get(instance.instanceId.id);
        if (instanceData) {
            instanceData.transform.rotation.set(quaternion);
            this.dirtyInstances.add(instance.instanceId.id);
        }
    }
    setModelScale(x, y, z, instance) {
        const instanceData = this.instances.get(instance.instanceId.id);
        if (instanceData) {
            instanceData.transform.scale.set([x, y, z]);
            this.dirtyInstances.add(instance.instanceId.id);
        }
    }
    playModelAnimation(animationName, instance, options) {
        const instanceData = this.instances.get(instance.instanceId.id);
        if (instanceData) {
            this.startAnimation(instanceData, animationName, options);
        }
    }
    stopModelAnimation(instance) {
        const instanceData = this.instances.get(instance.instanceId.id);
        if (instanceData) {
            instanceData.animationState.currentAnimation = null;
        }
    }
    createError(code, message) {
        return { name: 'ModelError', code, message };
    }
    addToModelGroup(instanceId) {
        let group = this.instancesByModel.get(instanceId.modelId);
        if (!group) {
            group = new Set();
            this.instancesByModel.set(instanceId.modelId, group);
        }
        group.add(instanceId.id);
    }
    removeFromModelGroup(instanceId) {
        const group = this.instancesByModel.get(instanceId.modelId);
        if (group) {
            group.delete(instanceId.id);
            if (group.size === 0) {
                this.instancesByModel.delete(instanceId.modelId);
            }
        }
    }
    updateAnimation(instance, deltaTime) {
        if (!instance.animationState.currentAnimation)
            return;
        this.animationController.updateAnimation(instance, deltaTime);
        this.dirtyInstances.add(instance.instanceId.id);
    }
    updateWorldMatrix(instance) {
        // Calculate world matrix from position, rotation, and scale
        const matrix = create$3();
        // Create translation matrix
        fromTranslation(matrix, instance.transform.position);
        // Create rotation matrix and multiply with existing matrix
        const rotationMatrix = create$3();
        fromQuat(rotationMatrix, instance.transform.rotation);
        multiply(matrix, matrix, rotationMatrix);
        // Apply scale
        scale(matrix, matrix, instance.transform.scale);
        instance.worldMatrix.set(matrix);
    }
    updateGPUBuffers() {
        // Just clear dirty instances as we're not using instance buffers anymore
        this.dirtyInstances.clear();
    }
    updateModelBuffers(modelId, instances) {
        let bufferData = this.instanceBuffers.get(modelId);
        if (!bufferData) {
            const modelMatrix = this.gl.createBuffer();
            const jointMatrices = this.gl.createBuffer();
            if (!modelMatrix || !jointMatrices) {
                throw this.createError(ModelErrorCode.GL_ERROR, 'Failed to create WebGL buffers');
            }
            bufferData = {
                modelMatrix,
                jointMatrices,
                count: instances.length
            };
            this.instanceBuffers.set(modelId, bufferData);
        }
        // Update model matrix buffer
        const modelMatrixData = new Float32Array(instances.length * 16);
        for (let i = 0; i < instances.length; i++) {
            modelMatrixData.set(instances[i].worldMatrix, i * 16);
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.modelMatrix);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, modelMatrixData, this.gl.DYNAMIC_DRAW);
        // Update joint matrices buffer if instances have skinning
        if (instances.some(instance => instance.jointMatrices)) {
            const jointMatrixData = new Float32Array(instances.length *
                Math.max(...instances.map(i => { var _a, _b; return (_b = (_a = i.jointMatrices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0; })));
            let offset = 0;
            for (const instance of instances) {
                if (instance.jointMatrices) {
                    jointMatrixData.set(instance.jointMatrices, offset);
                    offset += instance.jointMatrices.length;
                }
            }
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, bufferData.jointMatrices);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, jointMatrixData, this.gl.DYNAMIC_DRAW);
        }
        // Unbind buffer
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
    }
    renderModelInstances(modelId, instanceGroup, viewProjection) {
        var _a;
        const modelData = this.modelLoader.getModelData(modelId);
        if (!modelData)
            return;
        // Basic shader setup TODO: move to GPUResourceManager
        this.gl.useProgram(this.defaultShaderProgram);
        // For each instance
        for (const instanceId of instanceGroup) {
            const instance = this.instances.get(instanceId);
            if (!instance)
                continue;
            const renderOptions = instance.renderOptions;
            // Set normal map state for this instance
            this.gpuResources.setNormalMapEnabled(this.defaultShaderProgram, (_a = renderOptions.useNormalMap) !== null && _a !== void 0 ? _a : false);
            // Update world matrix
            this.updateWorldMatrix(instance);
            // For each mesh in the model
            for (const mesh of modelData.meshes) {
                for (const primitive of mesh.primitives) {
                    modelData.materials[primitive.material];
                    // const shader = material.program;
                    // TODO: move to GPUResourceManager
                    const shader = this.defaultShaderProgram;
                    // 1. Bind shader
                    // TODO: move to GPUResourceManager
                    this.gl.useProgram(shader);
                    // 2. Bind VAO (contains vertex attributes setup)
                    this.gl.bindVertexArray(primitive.vao);
                    // 3. Set required uniforms
                    const viewLoc = this.gl.getUniformLocation(shader, 'u_View');
                    const projectionLoc = this.gl.getUniformLocation(shader, 'u_Projection');
                    const modelMatrixLoc = this.gl.getUniformLocation(shader, 'u_Model');
                    const normalMatrixLoc = this.gl.getUniformLocation(shader, 'u_NormalMatrix');
                    this.gl.uniformMatrix4fv(viewLoc, false, viewProjection.view);
                    this.gl.uniformMatrix4fv(projectionLoc, false, viewProjection.projection);
                    this.gl.uniformMatrix4fv(modelMatrixLoc, false, instance.worldMatrix);
                    // Calculate normal matrix (inverse transpose of the upper 3x3 model matrix)
                    const normalMatrix = create$4();
                    normalFromMat4(normalMatrix, instance.worldMatrix);
                    // Set the uniform
                    this.gl.uniformMatrix3fv(normalMatrixLoc, false, normalMatrix);
                    // 4. Handle skinning if present
                    if (instance.jointMatrices && instance.jointMatrices.length > 0) {
                        const jointMatricesLoc = this.gl.getUniformLocation(shader, 'u_JointMatrices');
                        if (jointMatricesLoc) {
                            this.gl.uniformMatrix4fv(jointMatricesLoc, false, instance.jointMatrices);
                        }
                    }
                    // 5. Bind material properties (textures and uniforms)
                    this.gpuResources.bindShaderAndMaterial(this.defaultShaderProgram, primitive.material);
                    // 6. Draw
                    if (primitive.indexBuffer) {
                        this.gl.drawElements(this.gl.TRIANGLES, primitive.indexCount, primitive.indexType, 0);
                    }
                    else {
                        this.gl.drawArrays(this.gl.TRIANGLES, 0, primitive.vertexCount);
                    }
                }
            }
        }
        // 7. Cleanup
        this.gl.bindVertexArray(null);
        this.gl.useProgram(null);
    }
    startAnimation(instance, animationName, options) {
        var _a, _b;
        instance.animationState.currentAnimation = animationName;
        instance.animationState.currentTime = 0;
        if (options) {
            instance.animationState.speed = (_a = options.speed) !== null && _a !== void 0 ? _a : 1;
            instance.animationState.loop = (_b = options.loop) !== null && _b !== void 0 ? _b : true;
        }
    }
    cleanupInstance(instanceId) {
        const instance = this.instances.get(instanceId);
        if (!instance)
            return;
        // Remove from model group
        this.removeFromModelGroup(instance.instanceId);
        // Clear GPU resources
        const buffers = this.instanceBuffers.get(instance.instanceId.modelId);
        if (buffers) {
            // Clean up instance-specific GPU resources
            this.gpuResources.deleteBuffer(buffers.modelMatrix);
            this.gpuResources.deleteBuffer(buffers.jointMatrices);
        }
        // Remove instance data
        this.instances.delete(instanceId);
        this.dirtyInstances.delete(instanceId);
    }
    setModelNormalMapEnabled(enabled, instance) {
        const instanceData = this.instances.get(instance.instanceId.id);
        if (instanceData) {
            instanceData.renderOptions.useNormalMap = enabled;
            this.dirtyInstances.add(instance.instanceId.id);
        }
    }
}

export { GPUResourceManager, InstanceManager, ModelLoader };
